This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
.gitignore
build-test.sh
compile-test.sh
Dockerfile
docs/a/architecture/04-security-audit.md
docs/a/architecture/04-security-performance.md
docs/a/architecture/04-security-testing.md
docs/a/architecture/04-security.md
docs/a/README.md
docs/architecture/01-core-architecture.md
docs/architecture/02-design-patterns.md
docs/EXAM_API.md
docs/EXAM_IMPLEMENTATION_SUMMARY.md
docs/EXAM_IMPLEMENTATION_VERIFICATION.md
docs/EXAM_INTEGRATION_GUIDE.md
docs/EXAM_RECURSION_FIX.md
docs/exception-handling.md
docs/RBAC-ENHANCEMENTS.md
docs/README.md
mvnw
mvnw.cmd
pom.xml
RBAC-CHANGES.md
RBAC-TEST-FIXES.md
README.md
src/main/java/com/pharmacyhub/config/CorsConfig.java
src/main/java/com/pharmacyhub/config/ExamMapperConfig.java
src/main/java/com/pharmacyhub/config/GlobalExceptionHandler.java
src/main/java/com/pharmacyhub/config/RequestLoggingFilter.java
src/main/java/com/pharmacyhub/constants/APIConstants.java
src/main/java/com/pharmacyhub/constants/ErrorConstants.java
src/main/java/com/pharmacyhub/constants/RoleEnum.java
src/main/java/com/pharmacyhub/constants/StateEnum.java
src/main/java/com/pharmacyhub/constants/UserEnum.java
src/main/java/com/pharmacyhub/controller/AuthController.java
src/main/java/com/pharmacyhub/controller/base/BaseController.java
src/main/java/com/pharmacyhub/controller/EntryController.java
src/main/java/com/pharmacyhub/controller/ErrorDemoController.java
src/main/java/com/pharmacyhub/controller/ExamAttemptController.java
src/main/java/com/pharmacyhub/controller/ExamController.java
src/main/java/com/pharmacyhub/controller/FeatureAccessController.java
src/main/java/com/pharmacyhub/controller/ForwardingController.java
src/main/java/com/pharmacyhub/controller/HealthCheckController.java
src/main/java/com/pharmacyhub/controller/OtpController.java
src/main/java/com/pharmacyhub/controller/PermissionApiController.java
src/main/java/com/pharmacyhub/controller/PharmacistController.java
src/main/java/com/pharmacyhub/controller/PharmacyManagerController.java
src/main/java/com/pharmacyhub/controller/ProprietorController.java
src/main/java/com/pharmacyhub/controller/QuestionController.java
src/main/java/com/pharmacyhub/controller/RBACController.java
src/main/java/com/pharmacyhub/controller/SalesmanController.java
src/main/java/com/pharmacyhub/controller/UserController.java
src/main/java/com/pharmacyhub/controller/UserProfileController.java
src/main/java/com/pharmacyhub/domain/entity/Exam.java
src/main/java/com/pharmacyhub/domain/entity/ExamAttempt.java
src/main/java/com/pharmacyhub/domain/entity/ExamResult.java
src/main/java/com/pharmacyhub/domain/entity/FlaggedQuestion.java
src/main/java/com/pharmacyhub/domain/entity/Option.java
src/main/java/com/pharmacyhub/domain/entity/Question.java
src/main/java/com/pharmacyhub/domain/entity/UserAnswer.java
src/main/java/com/pharmacyhub/domain/repository/ExamAttemptRepository.java
src/main/java/com/pharmacyhub/domain/repository/ExamRepository.java
src/main/java/com/pharmacyhub/domain/repository/ExamResultRepository.java
src/main/java/com/pharmacyhub/domain/repository/FlaggedQuestionRepository.java
src/main/java/com/pharmacyhub/domain/repository/OptionRepository.java
src/main/java/com/pharmacyhub/domain/repository/QuestionRepository.java
src/main/java/com/pharmacyhub/domain/repository/UserAnswerRepository.java
src/main/java/com/pharmacyhub/dto/BaseDTO.java
src/main/java/com/pharmacyhub/dto/ChangePasswordDTO.java
src/main/java/com/pharmacyhub/dto/display/ConnectionDisplayDTO.java
src/main/java/com/pharmacyhub/dto/display/UserDisplayDTO.java
src/main/java/com/pharmacyhub/dto/display/UserResponseDTO.java
src/main/java/com/pharmacyhub/dto/ExamAttemptDTO.java
src/main/java/com/pharmacyhub/dto/ExamDTO.java
src/main/java/com/pharmacyhub/dto/ExamResultDTO.java
src/main/java/com/pharmacyhub/dto/ExamStatsDTO.java
src/main/java/com/pharmacyhub/dto/FlaggedQuestionDTO.java
src/main/java/com/pharmacyhub/dto/LoggedInUserDTO.java
src/main/java/com/pharmacyhub/dto/OptionDTO.java
src/main/java/com/pharmacyhub/dto/PharmacistDTO.java
src/main/java/com/pharmacyhub/dto/PharmacyManagerDTO.java
src/main/java/com/pharmacyhub/dto/PHUserConnectionDTO.java
src/main/java/com/pharmacyhub/dto/PHUserDTO.java
src/main/java/com/pharmacyhub/dto/ProprietorDTO.java
src/main/java/com/pharmacyhub/dto/ReportingUserDTO.java
src/main/java/com/pharmacyhub/dto/request/AnswerSubmissionDTO.java
src/main/java/com/pharmacyhub/dto/request/ExamFilterRequestDTO.java
src/main/java/com/pharmacyhub/dto/request/ExamRequestDTO.java
src/main/java/com/pharmacyhub/dto/request/JsonExamUploadRequestDTO.java
src/main/java/com/pharmacyhub/dto/request/LoginRequestDTO.java
src/main/java/com/pharmacyhub/dto/request/UserCreateRequestDTO.java
src/main/java/com/pharmacyhub/dto/request/UserUpdateRequestDTO.java
src/main/java/com/pharmacyhub/dto/response/ApiError.java
src/main/java/com/pharmacyhub/dto/response/ApiErrorResponse.java
src/main/java/com/pharmacyhub/dto/response/ApiResponse.java
src/main/java/com/pharmacyhub/dto/response/AuthResponseDTO.java
src/main/java/com/pharmacyhub/dto/response/ExamAttemptResponseDTO.java
src/main/java/com/pharmacyhub/dto/response/ExamResponseDTO.java
src/main/java/com/pharmacyhub/dto/response/FlaggedQuestionResponseDTO.java
src/main/java/com/pharmacyhub/dto/response/QuestionResponseDTO.java
src/main/java/com/pharmacyhub/dto/response/TokensDTO.java
src/main/java/com/pharmacyhub/dto/response/UserResponseDTO.java
src/main/java/com/pharmacyhub/dto/SalesmanDTO.java
src/main/java/com/pharmacyhub/dto/UserAnswerDTO.java
src/main/java/com/pharmacyhub/dto/UserDTO.java
src/main/java/com/pharmacyhub/dto/UserProfileDTO.java
src/main/java/com/pharmacyhub/engine/PHEngine.java
src/main/java/com/pharmacyhub/engine/PHMapper.java
src/main/java/com/pharmacyhub/engine/SeederEngine.java
src/main/java/com/pharmacyhub/entity/connections/PharmacistsConnections.java
src/main/java/com/pharmacyhub/entity/connections/PharmacyManagerConnections.java
src/main/java/com/pharmacyhub/entity/connections/ProprietorsConnections.java
src/main/java/com/pharmacyhub/entity/connections/SalesmenConnections.java
src/main/java/com/pharmacyhub/entity/Entry.java
src/main/java/com/pharmacyhub/entity/enums/UserType.java
src/main/java/com/pharmacyhub/entity/Otp.java
src/main/java/com/pharmacyhub/entity/Pharmacist.java
src/main/java/com/pharmacyhub/entity/PharmacyManager.java
src/main/java/com/pharmacyhub/entity/Proprietor.java
src/main/java/com/pharmacyhub/entity/Salesman.java
src/main/java/com/pharmacyhub/entity/SystemRole.java
src/main/java/com/pharmacyhub/entity/User.java
src/main/java/com/pharmacyhub/exception/BadRequestException.java
src/main/java/com/pharmacyhub/exception/BaseException.java
src/main/java/com/pharmacyhub/exception/ConflictException.java
src/main/java/com/pharmacyhub/exception/ForbiddenException.java
src/main/java/com/pharmacyhub/exception/ResourceNotFoundException.java
src/main/java/com/pharmacyhub/exception/UnauthorizedException.java
src/main/java/com/pharmacyhub/PharmacyHubApplication.java
src/main/java/com/pharmacyhub/repository/connections/PharmacistsConnectionsRepository.java
src/main/java/com/pharmacyhub/repository/connections/PharmacyManagerConnectionsRepository.java
src/main/java/com/pharmacyhub/repository/connections/ProprietorsConnectionsRepository.java
src/main/java/com/pharmacyhub/repository/connections/SalesmenConnectionsRepository.java
src/main/java/com/pharmacyhub/repository/EntryRepository.java
src/main/java/com/pharmacyhub/repository/OtpRepository.java
src/main/java/com/pharmacyhub/repository/PharmacistRepository.java
src/main/java/com/pharmacyhub/repository/PharmacyManagerRepository.java
src/main/java/com/pharmacyhub/repository/ProprietorRepository.java
src/main/java/com/pharmacyhub/repository/RoleRepository.java
src/main/java/com/pharmacyhub/repository/SalesmanRepository.java
src/main/java/com/pharmacyhub/repository/UserRepository.java
src/main/java/com/pharmacyhub/security/annotation/RequiresPermission.java
src/main/java/com/pharmacyhub/security/aspect/PermissionAspect.java
src/main/java/com/pharmacyhub/security/config/AccessEvaluatorConfig.java
src/main/java/com/pharmacyhub/security/config/RBACCacheConfig.java
src/main/java/com/pharmacyhub/security/constants/AuthPermissionConstants.java
src/main/java/com/pharmacyhub/security/constants/ExamPermissionConstants.java
src/main/java/com/pharmacyhub/security/constants/PermissionConstants.java
src/main/java/com/pharmacyhub/security/constants/RoleConstants.java
src/main/java/com/pharmacyhub/security/controller/FeatureController.java
src/main/java/com/pharmacyhub/security/controller/PermissionController.java
src/main/java/com/pharmacyhub/security/controller/RoleHierarchyController.java
src/main/java/com/pharmacyhub/security/controller/SecurityCheckController.java
src/main/java/com/pharmacyhub/security/CustomUserDetailsService.java
src/main/java/com/pharmacyhub/security/domain/AuditLog.java
src/main/java/com/pharmacyhub/security/domain/exception/RBACException.java
src/main/java/com/pharmacyhub/security/domain/Feature.java
src/main/java/com/pharmacyhub/security/domain/FeaturePermission.java
src/main/java/com/pharmacyhub/security/domain/Group.java
src/main/java/com/pharmacyhub/security/domain/OperationType.java
src/main/java/com/pharmacyhub/security/domain/Permission.java
src/main/java/com/pharmacyhub/security/domain/PermissionEnum.java
src/main/java/com/pharmacyhub/security/domain/ResourceType.java
src/main/java/com/pharmacyhub/security/domain/Role.java
src/main/java/com/pharmacyhub/security/dto/AccessCheckRequest.java
src/main/java/com/pharmacyhub/security/dto/FeatureAccessDTO.java
src/main/java/com/pharmacyhub/security/dto/FeatureAccessRequest.java
src/main/java/com/pharmacyhub/security/dto/FeatureAccessResponse.java
src/main/java/com/pharmacyhub/security/dto/FeatureDTO.java
src/main/java/com/pharmacyhub/security/dto/FeaturePermissionDTO.java
src/main/java/com/pharmacyhub/security/dto/GroupDTO.java
src/main/java/com/pharmacyhub/security/dto/PermissionDTO.java
src/main/java/com/pharmacyhub/security/dto/RoleDTO.java
src/main/java/com/pharmacyhub/security/dto/UserFeatureAccessDTO.java
src/main/java/com/pharmacyhub/security/evaluator/ExamAccessEvaluator.java
src/main/java/com/pharmacyhub/security/evaluator/PHPermissionEvaluator.java
src/main/java/com/pharmacyhub/security/exception/RBACException.java
src/main/java/com/pharmacyhub/security/exception/RBACExceptionHandler.java
src/main/java/com/pharmacyhub/security/handler/CustomAccessDeniedHandler.java
src/main/java/com/pharmacyhub/security/handler/CustomAuthenticationEntryPoint.java
src/main/java/com/pharmacyhub/security/infrastructure/AuditLogRepository.java
src/main/java/com/pharmacyhub/security/infrastructure/configuration/AuthenticationConfig.java
src/main/java/com/pharmacyhub/security/infrastructure/configuration/SecurityConfig.java
src/main/java/com/pharmacyhub/security/infrastructure/exception/AuthenticationExceptionHandler.java
src/main/java/com/pharmacyhub/security/infrastructure/exception/UnverifiedAccountException.java
src/main/java/com/pharmacyhub/security/infrastructure/FeaturePermissionRepository.java
src/main/java/com/pharmacyhub/security/infrastructure/FeatureRepository.java
src/main/java/com/pharmacyhub/security/infrastructure/GroupRepository.java
src/main/java/com/pharmacyhub/security/infrastructure/GroupRepositoryInterface.java
src/main/java/com/pharmacyhub/security/infrastructure/PermissionRepository.java
src/main/java/com/pharmacyhub/security/infrastructure/PermissionRepositoryInterface.java
src/main/java/com/pharmacyhub/security/infrastructure/RoleRepositoryInterface.java
src/main/java/com/pharmacyhub/security/infrastructure/RolesRepository.java
src/main/java/com/pharmacyhub/security/initializer/ExamRolePermissionInitializer.java
src/main/java/com/pharmacyhub/security/initializer/RoleHierarchyInitializer.java
src/main/java/com/pharmacyhub/security/initializer/RoleInitializer.java
src/main/java/com/pharmacyhub/security/JwtAuthenticationEntryPoint.java
src/main/java/com/pharmacyhub/security/JwtAuthenticationFilter.java
src/main/java/com/pharmacyhub/security/JwtHelper.java
src/main/java/com/pharmacyhub/security/model/ErrorResponse.java
src/main/java/com/pharmacyhub/security/model/LoginRequest.java
src/main/java/com/pharmacyhub/security/service/AuditService.java
src/main/java/com/pharmacyhub/security/service/AuthenticationService.java
src/main/java/com/pharmacyhub/security/service/FeatureService.java
src/main/java/com/pharmacyhub/security/service/PermissionDataLoaderService.java
src/main/java/com/pharmacyhub/security/service/RBACService.java
src/main/java/com/pharmacyhub/security/service/RBACValidationService.java
src/main/java/com/pharmacyhub/security/service/RoleHierarchyService.java
src/main/java/com/pharmacyhub/security/service/UserRoleService.java
src/main/java/com/pharmacyhub/security/users/controller/UserManagementController.java
src/main/java/com/pharmacyhub/security/users/dto/UserCreationRequest.java
src/main/java/com/pharmacyhub/security/users/factory/UserTypeFactory.java
src/main/java/com/pharmacyhub/security/users/groups/GroupSeeder.java
src/main/java/com/pharmacyhub/security/users/initializer/DefaultUsersInitializer.java
src/main/java/com/pharmacyhub/security/users/README.md
src/main/java/com/pharmacyhub/security/users/service/UserTypeService.java
src/main/java/com/pharmacyhub/security/users/util/UserConverter.java
src/main/java/com/pharmacyhub/security/users/util/UserCreator.java
src/main/java/com/pharmacyhub/seeder/AdminUserSeeder.java
src/main/java/com/pharmacyhub/seeder/PharmacistSeeder.java
src/main/java/com/pharmacyhub/seeder/PharmacyManagerSeeder.java
src/main/java/com/pharmacyhub/seeder/ProprietorSeeder.java
src/main/java/com/pharmacyhub/seeder/RoleSeeder.java
src/main/java/com/pharmacyhub/seeder/SalesmanSeeder.java
src/main/java/com/pharmacyhub/service/EmailService.java
src/main/java/com/pharmacyhub/service/EntryService.java
src/main/java/com/pharmacyhub/service/ExamAttemptService.java
src/main/java/com/pharmacyhub/service/ExamAttemptServiceImpl.java
src/main/java/com/pharmacyhub/service/ExamService.java
src/main/java/com/pharmacyhub/service/ExamServiceImpl.java
src/main/java/com/pharmacyhub/service/GoogleContactService.java
src/main/java/com/pharmacyhub/service/HealthService.java
src/main/java/com/pharmacyhub/service/JsonExamUploadService.java
src/main/java/com/pharmacyhub/service/OptionService.java
src/main/java/com/pharmacyhub/service/OptionServiceImpl.java
src/main/java/com/pharmacyhub/service/OtpService.java
src/main/java/com/pharmacyhub/service/PermissionApiService.java
src/main/java/com/pharmacyhub/service/PharmacistService.java
src/main/java/com/pharmacyhub/service/PharmacyManagerService.java
src/main/java/com/pharmacyhub/service/PHUserService.java
src/main/java/com/pharmacyhub/service/ProprietorService.java
src/main/java/com/pharmacyhub/service/QuestionService.java
src/main/java/com/pharmacyhub/service/QuestionServiceImpl.java
src/main/java/com/pharmacyhub/service/SalesmanService.java
src/main/java/com/pharmacyhub/service/UserService.java
src/main/java/com/pharmacyhub/utils/EntityMapper.java
src/main/java/com/pharmacyhub/utils/LogUtils.java
src/main/java/com/pharmacyhub/utils/SecurityUtils.java
src/main/resources/application.yml
src/main/resources/credentials.json
src/main/resources/db/migration/V3__add_feature_operations.sql
src/main/resources/db/migration/V3__add_features_tables.sql
src/main/resources/db/migration/V4__add_exam_feature_operations.sql
src/main/resources/logback-spring.xml
src/main/resources/sql/flagged_questions.sql
src/main/resources/templates/EmailVerification.html
src/main/resources/templates/OtpEmail.html
TEST-GUIDE.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".gitignore">
HELP.md
target/
!.mvn/wrapper/maven-wrapper.jar
!**/src/main/**/target/
!**/src/test/**/target/

### STS ###
.apt_generated
.classpath
.factorypath
.project
.settings
.springBeans
.sts4-cache

### IntelliJ IDEA ###
.idea
*.iws
*.iml
*.ipr

### NetBeans ###
/nbproject/private/
/nbbuild/
/dist/
/nbdist/
/.nb-gradle/
build/
!**/src/main/**/build/
!**/src/test/**/build/

### VS Code ###
.vscode/
</file>

<file path="build-test.sh">
#!/bin/bash
# This is a simple script to build and test the application
cd D:\code\PharmacyHub\pharmacyhub-backend
./mvnw clean compile test
</file>

<file path="compile-test.sh">
#!/bin/bash
mvn clean compile > output.log 2>&1
cat output.log
</file>

<file path="Dockerfile">
# Use the official OpenJDK image for Java 17 as the base image
FROM openjdk:17

# Add Maintainer Info
LABEL maintainer="syedus06@gmail.com"

# Make port 8080 available to the world outside this container
EXPOSE 8080

# The application's jar file
ARG JAR_FILE=target/*.jar

# Add the application's jar to the container
ADD ${JAR_FILE} pharmacy-hub.jar

# Run the jar file
ENTRYPOINT ["java","-jar","/pharmacy-hub.jar"]
</file>

<file path="docs/a/architecture/04-security-audit.md">
# RBAC Audit Logging

## Overview

PharmacyHub's RBAC system includes comprehensive audit logging to track all security-related actions. This document outlines the audit logging system's architecture, implementation, and usage.

## Audit Log Structure

### 1. Log Entry Fields
```java
public class AuditLog {
    private Long id;
    private String action;
    private String details;
    private String outcome;
    private Long userId;
    private LocalDateTime timestamp;
    private String ipAddress;
    private String userAgent;
    private Map<String, Object> additionalData;
}
```

### 2. Logged Actions
- Role assignments and modifications
- Permission changes and checks
- Group modifications
- Access attempts (success/failure)
- Configuration changes
- User session activities

## API Endpoints

### 1. Log Access
```
GET     /api/audit/logs                   # Get all logs with pagination
GET     /api/audit/logs/{id}             # Get specific log entry
GET     /api/audit/logs/user/{userId}    # Get logs for specific user
GET     /api/audit/logs/action/{action}  # Get logs by action type
GET     /api/audit/logs/export           # Export logs in CSV format
```

### 2. Log Management
```
DELETE  /api/audit/logs/{id}             # Delete specific log (Admin only)
POST    /api/audit/logs/archive          # Archive old logs
GET     /api/audit/logs/statistics       # Get logging statistics
```

## Implementation Guidelines

### 1. Logging Service
```java
@Service
public class AuditService {
    // Core logging method
    public void logSecurityEvent(
        String action,
        String details,
        String outcome
    );

    // Specialized logging methods
    public void logRoleAssignment(
        Long userId, 
        Long roleId, 
        String outcome
    );

    public void logPermissionCheck(
        String resource,
        String operation,
        String outcome
    );

    public void logConfigChange(
        String component,
        String change,
        String outcome
    );
}
```

### 2. Integration Points
```java
// In RBACService
@Autowired
private AuditService auditService;

public void assignRole(Long userId, Long roleId) {
    try {
        // Role assignment logic
        auditService.logRoleAssignment(userId, roleId, "SUCCESS");
    } catch (Exception e) {
        auditService.logRoleAssignment(userId, roleId, "FAILED: " + e.getMessage());
        throw e;
    }
}
```

## Log Retention and Archival

### 1. Retention Policy
- Active logs: 90 days in main database
- Archived logs: 1 year in archive storage
- Compliance logs: 7 years in secure storage
- Regular cleanup of old logs

### 2. Archival Process
```java
@Scheduled(cron = "0 0 1 * * ?")  // Run at 1 AM daily
public void archiveOldLogs() {
    LocalDateTime cutoffDate = LocalDateTime.now().minusDays(90);
    List<AuditLog> oldLogs = auditLogRepository
        .findByTimestampBefore(cutoffDate);
    
    archiveService.archiveLogs(oldLogs);
    auditLogRepository.deleteAll(oldLogs);
}
```

## Security Monitoring

### 1. Real-time Alerts
```java
@Component
public class SecurityMonitor {
    @EventListener
    public void onAuditEvent(AuditEvent event) {
        if (isSecurityCritical(event)) {
            notificationService.sendAlert(
                "Security Alert",
                formatAlertMessage(event)
            );
        }
    }
}
```

### 2. Reporting System
- Daily security summaries
- Weekly access pattern analysis
- Monthly compliance reports
- Quarterly security reviews

## Compliance Features

### 1. Data Protection
- Encryption of sensitive log data
- Masking of personal information
- Access control for log viewers
- Tamper-evident logging

### 2. Audit Trail
- Immutable log entries
- Digital signatures
- Chain of custody tracking
- Compliance reporting

## Performance Optimization

### 1. Logging Strategy
```java
@Configuration
public class AuditConfig {
    @Bean
    public AsyncAuditLogger asyncAuditLogger() {
        return new AsyncAuditLogger(
            threadPoolExecutor(),
            logRepository
        );
    }
    
    @Bean
    public ThreadPoolExecutor threadPoolExecutor() {
        return new ThreadPoolExecutor(
            2, 5, 60, TimeUnit.SECONDS,
            new LinkedBlockingQueue<>(1000)
        );
    }
}
```

### 2. Caching Configuration
```java
@Configuration
@EnableCaching
public class CacheConfig {
    @Bean
    public CacheManager auditCacheManager() {
        return new ConcurrentMapCacheManager(
            "auditLogs",
            "userAuditLogs",
            "actionAuditLogs"
        );
    }
}
```

## Error Handling

### 1. Log Failures
```java
@ControllerAdvice
public class AuditErrorHandler {
    @ExceptionHandler(AuditLogException.class)
    public ResponseEntity<String> handleAuditError(
        AuditLogException ex
    ) {
        // Emergency logging to file system
        emergencyLogger.log(ex);
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body("Audit logging failed");
    }
}
```

### 2. Recovery Procedures
- Automatic retry mechanism
- Backup logging system
- Manual recovery tools
- Data consistency checks

## Testing Guidelines

### 1. Unit Tests
```java
@Test
public void shouldLogSuccessfulRoleAssignment() {
    auditService.logRoleAssignment(userId, roleId, "SUCCESS");
    AuditLog log = auditLogRepository.findLatestByUserId(userId);
    
    assertThat(log.getAction()).isEqualTo("ROLE_ASSIGNMENT");
    assertThat(log.getOutcome()).isEqualTo("SUCCESS");
}
```

### 2. Integration Tests
```java
@SpringBootTest
public class AuditIntegrationTest {
    @Test
    public void shouldCreateAuditTrailForRoleChanges() {
        rbacService.assignRole(userId, roleId);
        
        List<AuditLog> logs = auditService
            .getUserAuditLogs(userId);
        
        assertThat(logs).isNotEmpty();
        assertThat(logs.get(0).getAction())
            .isEqualTo("ROLE_ASSIGNMENT");
    }
}
```

## Monitoring and Maintenance

### 1. Health Checks
```java
@Component
public class AuditHealthIndicator implements HealthIndicator {
    @Override
    public Health health() {
        try {
            auditService.checkHealth();
            return Health.up().build();
        } catch (Exception e) {
            return Health.down()
                .withException(e)
                .build();
        }
    }
}
```

### 2. Maintenance Tasks
- Regular performance monitoring
- Log analysis for patterns
- Storage optimization
- Index maintenance
</file>

<file path="docs/a/architecture/04-security-performance.md">
# RBAC Performance Optimization Guide

## Overview

This document provides guidance on optimizing the performance of PharmacyHub's RBAC system. It covers caching strategies, database optimization, and best practices for efficient permission evaluation.

## Caching Strategy

### 1. Permission Cache
```java
@Configuration
@EnableCaching
public class RBACCacheConfig {
    @Bean
    public CacheManager rbacCacheManager() {
        return new ConcurrentMapCacheManager(
            "userPermissions",    // User's effective permissions
            "roleHierarchy",      // Role hierarchy relationships
            "groupRoles",         // Group role assignments
            "userRoles"          // User role assignments
        );
    }
}
```

### 2. Cache Usage
```java
@Service
public class RBACService {
    @Cacheable(value = "userPermissions", key = "#userId")
    public Set<Permission> getUserEffectivePermissions(Long userId) {
        // Permission calculation logic
    }

    @CacheEvict(value = "userPermissions", key = "#userId")
    public void clearUserPermissionCache(Long userId) {
        // Cache eviction logic
    }
}
```

## Database Optimization

### 1. Index Strategy
```sql
-- Role table indexes
CREATE INDEX idx_role_name ON roles(name);
CREATE INDEX idx_role_precedence ON roles(precedence);

-- Permission table indexes
CREATE INDEX idx_permission_name ON permissions(name);
CREATE INDEX idx_permission_resource ON permissions(resource_type);

-- User role mapping indexes
CREATE INDEX idx_user_roles ON user_roles(user_id, role_id);
```

### 2. Query Optimization
```java
@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    @Query("SELECT r FROM Role r " +
           "LEFT JOIN FETCH r.permissions " +
           "LEFT JOIN FETCH r.childRoles " +
           "WHERE r.id = :roleId")
    Optional<Role> findByIdWithRelations(Long roleId);
}
```

## Permission Evaluation

### 1. Fast Path Evaluation
```java
public class PermissionEvaluator {
    public boolean hasPermission(User user, String resource, String operation) {
        // Check cache first
        Set<Permission> cachedPermissions = permissionCache.get(user.getId());
        if (cachedPermissions != null) {
            return evaluateFromCache(cachedPermissions, resource, operation);
        }

        // Fall back to database
        return evaluateFromDatabase(user, resource, operation);
    }
}
```

### 2. Batch Permission Loading
```java
@Service
public class PermissionLoader {
    public Map<Long, Set<Permission>> loadPermissionsForUsers(Set<Long> userIds) {
        return userIds.stream()
            .collect(Collectors.toMap(
                userId -> userId,
                this::getUserEffectivePermissions
            ));
    }
}
```

## Role Hierarchy Optimization

### 1. Hierarchy Traversal
```java
public class RoleHierarchyManager {
    private Map<Long, Set<Long>> hierarchyCache = new ConcurrentHashMap<>();

    public Set<Role> getInheritedRoles(Long roleId) {
        Set<Long> inheritedIds = hierarchyCache.get(roleId);
        if (inheritedIds == null) {
            inheritedIds = calculateInheritedRoles(roleId);
            hierarchyCache.put(roleId, inheritedIds);
        }
        return roleRepository.findAllById(inheritedIds);
    }
}
```

### 2. Precedence-Based Optimization
```java
public class RoleManager {
    public boolean canAssignRole(User assigner, User assignee, Role roleToAssign) {
        // Quick check based on role precedence
        return assigner.getHighestRolePrecedence() < 
               roleToAssign.getPrecedence();
    }
}
```

## Memory Management

### 1. Cache Size Control
```java
@Configuration
public class CacheConfiguration {
    @Bean
    public CacheManager cacheManager() {
        GuavaCache userPermissions = new GuavaCache(
            "userPermissions",
            CacheBuilder.newBuilder()
                .maximumSize(10000)
                .expireAfterWrite(1, TimeUnit.HOURS)
                .build()
        );
        
        return new SimpleCacheManager(
            Arrays.asList(userPermissions)
        );
    }
}
```

### 2. Memory-Efficient Data Structures
```java
public class PermissionSet {
    private final BitSet permissions;
    private final int[] resourceMap;

    public boolean hasPermission(int resourceId, int operationId) {
        int bitIndex = resourceMap[resourceId] + operationId;
        return permissions.get(bitIndex);
    }
}
```

## Monitoring and Metrics

### 1. Performance Metrics
```java
@Component
public class RBACMetrics {
    private final MeterRegistry registry;

    public void recordPermissionCheck(long startTime) {
        registry.timer("rbac.permission.check")
            .record(System.nanoTime() - startTime, TimeUnit.NANOSECONDS);
    }

    public void recordCacheHit(String cache) {
        registry.counter("rbac.cache.hit", "cache", cache)
            .increment();
    }
}
```

### 2. Performance Alerts
```java
@Component
public class PerformanceMonitor {
    @Scheduled(fixedRate = 5000)
    public void checkPerformance() {
        double p99LatencyMs = getPermissionCheckLatency(0.99);
        if (p99LatencyMs > 100) {
            alertService.sendAlert(
                "High RBAC latency detected: " + p99LatencyMs + "ms"
            );
        }
    }
}
```

## Best Practices

### 1. Permission Design
- Keep permissions granular but not too fine-grained
- Use role hierarchy effectively
- Cache frequently accessed permissions
- Optimize permission checks

### 2. Database Access
- Use appropriate indexes
- Batch related queries
- Minimize cross-table joins
- Cache query results

### 3. Cache Management
- Set appropriate cache sizes
- Define clear eviction policies
- Monitor cache hit rates
- Update cache strategically

### 4. Memory Usage
- Control cache sizes
- Use efficient data structures
- Implement pagination
- Clean up unused data

## Performance Testing

### 1. Load Testing
```java
@Test
public void permissionCheckUnderLoad() {
    // Simulate 1000 concurrent permission checks
    ExecutorService executor = Executors.newFixedThreadPool(10);
    for (int i = 0; i < 1000; i++) {
        executor.submit(() -> {
            rbacService.hasPermission(user, "INVENTORY", "READ");
        });
    }
}
```

### 2. Monitoring Tests
```java
@Test
public void monitorCachePerformance() {
    Metrics metrics = new Metrics();
    for (int i = 0; i < 10000; i++) {
        long start = System.nanoTime();
        rbacService.getUserEffectivePermissions(userId);
        metrics.recordLatency(System.nanoTime() - start);
    }
    
    assertThat(metrics.getP95Latency())
        .isLessThan(Duration.ofMillis(10));
}
```
</file>

<file path="docs/a/architecture/04-security-testing.md">
# RBAC Testing Strategy

## Overview

This document outlines the testing strategy for PharmacyHub's Role-Based Access Control (RBAC) system. It covers different types of tests, test scenarios, and best practices for ensuring the security and reliability of the RBAC implementation.

## Test Categories

### 1. Unit Tests

#### Permission Tests
```java
@Test
void shouldGrantPermissionWhenUserHasDirectPermission() {
    // Test implementation
}

@Test
void shouldDenyPermissionWhenUserLacksAccess() {
    // Test implementation
}
```

#### Role Hierarchy Tests
```java
@Test
void shouldInheritPermissionsFromParentRole() {
    // Test implementation
}

@Test
void shouldDetectCircularDependency() {
    // Test implementation
}
```

#### Group Permission Tests
```java
@Test
void shouldInheritPermissionsFromGroup() {
    // Test implementation
}
```

### 2. Integration Tests

#### Role Management Tests
```java
@Test
void shouldSuccessfullyCreateAndAssignRole() {
    // Test implementation
}

@Test
void shouldEnforceRolePrecedence() {
    // Test implementation
}
```

#### Permission Evaluation Tests
```java
@Test
void shouldEvaluateComplexPermissionRules() {
    // Test implementation
}
```

#### Audit Logging Tests
```java
@Test
void shouldLogRBACOperations() {
    // Test implementation
}
```

### 3. Security Tests

#### Access Control Tests
- Verify URL protection
- Test method-level security
- Check permission inheritance

#### Authentication Tests
- Test user authentication
- Verify role-based access
- Check permission evaluation

#### Authorization Tests
- Test permission combinations
- Verify role hierarchies
- Check group permissions

## Test Scenarios

### 1. Role Assignment

```gherkin
Scenario: Assign role to user
  Given a user with no roles
  When an admin assigns a role
  Then the user should have the role's permissions
  And the assignment should be logged
```

### 2. Permission Inheritance

```gherkin
Scenario: Inherit parent role permissions
  Given a role hierarchy
  When a user is assigned a child role
  Then they should have both child and parent permissions
```

### 3. Group Management

```gherkin
Scenario: Manage group permissions
  Given a group with multiple roles
  When a user is added to the group
  Then they should have all group role permissions
```

## Test Data

### 1. Test Users
```json
{
  "admin": {
    "roles": ["ADMIN"],
    "permissions": ["*"]
  },
  "pharmacist": {
    "roles": ["PHARMACIST"],
    "permissions": ["VIEW_INVENTORY", "MANAGE_PRESCRIPTIONS"]
  }
}
```

### 2. Test Roles
```json
{
  "ADMIN": {
    "precedence": 0,
    "childRoles": ["PROPRIETOR"]
  },
  "PHARMACIST": {
    "precedence": 3,
    "permissions": ["VIEW_INVENTORY"]
  }
}
```

## Test Environment

### 1. Setup
- Clean database before tests
- Initialize default roles
- Create test users
- Configure test permissions

### 2. Teardown
- Clean up test data
- Reset permissions
- Clear audit logs
- Restore defaults

## Performance Testing

### 1. Permission Evaluation
- Test cache effectiveness
- Measure evaluation time
- Check system under load

### 2. Role Hierarchy
- Test deep hierarchies
- Measure inheritance chain
- Check circular detection

## Security Testing

### 1. Penetration Testing
- Test permission bypass
- Check role escalation
- Verify audit logging

### 2. Access Control Testing
- Test URL protection
- Check method security
- Verify role boundaries

## Test Automation

### 1. CI/CD Integration
```yaml
rbac-tests:
  stage: test
  script:
    - ./gradlew test
  tags:
    - security
    - rbac
```

### 2. Test Reports
- Generate coverage reports
- Track security metrics
- Monitor test results

## Best Practices

### 1. Test Organization
- Group related tests
- Use descriptive names
- Maintain test independence

### 2. Test Data
- Use realistic data
- Maintain test isolation
- Clean up after tests

### 3. Security Testing
- Test edge cases
- Check error handling
- Verify audit trails

## Maintenance

### 1. Test Updates
- Update for new features
- Maintain test data
- Review test coverage

### 2. Documentation
- Document test cases
- Maintain scenarios
- Update test guides

## Troubleshooting

### 1. Common Issues
- Permission conflicts
- Role hierarchy issues
- Cache problems

### 2. Resolution Steps
- Check test data
- Verify configurations
- Review logs

## Metrics

### 1. Coverage
- Permission coverage
- Role coverage
- Test coverage

### 2. Performance
- Evaluation time
- Cache hit rate
- Response time
</file>

<file path="docs/a/architecture/04-security.md">
# Role-Based Access Control (RBAC) System

## Overview

PharmacyHub implements a comprehensive Role-Based Access Control (RBAC) system that provides fine-grained access control through a combination of roles, permissions, and groups. The system supports role hierarchy, permission inheritance, and group-based access management.

## Core Components

### 1. Permissions
- Atomic units of access control
- Defined by resource type and operation type
- Can require approval for sensitive operations
- Support conditional access through JSON-based rules

### 2. Roles
- Collections of permissions
- Support hierarchical relationships
- Have precedence levels
- Can be system-defined or custom

### 3. Groups
- Collections of roles
- Simplify role assignment
- Enable organizational structure mapping
- Support bulk permission management

## Role Hierarchy

The system implements a hierarchical role structure with the following characteristics:

```mermaid
graph TD
    A[Admin] --> B[Proprietor]
    B --> C[Pharmacy Manager]
    C --> D[Pharmacist]
    B --> E[Salesman]
```

### Precedence Levels
1. Admin (0) - Highest precedence
2. Proprietor (1)
3. Pharmacy Manager (2)
4. Pharmacist (3)
5. Salesman (4)

## Permission Structure

Permissions are structured as combinations of:

1. Resource Types:
   - PHARMACIST
   - PHARMACY_MANAGER
   - PROPRIETOR
   - SALESMAN
   - INVENTORY
   - PRESCRIPTION
   - ORDER
   - CONNECTION
   - ROLE
   - GROUP
   - AUDIT_LOG
   - SYSTEM_SETTING

2. Operation Types:
   - CREATE
   - READ
   - UPDATE
   - DELETE
   - APPROVE
   - REJECT
   - MANAGE
   - EXPORT
   - IMPORT
   - VIEW_ALL
   - VIEW_OWN

## Default Role Configuration

### Admin Role
- Full system access
- Can manage roles and permissions
- Can view audit logs
- Can manage system settings

### Proprietor Role
- View all branches
- Manage branches
- View financial reports
- Manage pharmacy managers

### Pharmacy Manager Role
- Manage inventory
- View sales reports
- Manage staff
- Oversee pharmacists

### Pharmacist Role
- View pharmacy inventory
- Manage prescriptions
- View patient history
- Handle medication dispensing

### Salesman Role
- Create orders
- View orders
- Update order status
- Manage customer relationships

## Security Features

1. Permission Evaluation
   - Method-level security using @RequiresPermission
   - URL-based security through SecurityConfig
   - Custom permission evaluator for complex rules

2. Audit Logging
   - Tracks all RBAC-related actions
   - Records user, action, timestamp
   - Supports audit trail review

3. Caching
   - Caches user permissions
   - Caches role hierarchies
   - Improves performance

## Implementation Details

### 1. Permission Checks
```java
@RequiresPermission(resource = "INVENTORY", operation = "MANAGE")
public void updateInventory(InventoryDTO dto) {
    // Implementation
}
```

### 2. Role Assignment
```java
rbacService.assignRoleToUser(userId, roleId);
```

### 3. Group Management
```java
rbacService.assignGroupToUser(userId, groupId);
```

## Best Practices

1. Role Assignment
   - Follow principle of least privilege
   - Use groups for organizational units
   - Regularly review role assignments

2. Permission Management
   - Keep permissions atomic
   - Use role hierarchy for inheritance
   - Document permission combinations

3. Security Considerations
   - Validate role assignments
   - Check circular dependencies
   - Maintain audit logs

## API Endpoints

### Role Management
```
POST    /api/rbac/roles
GET     /api/rbac/roles
PUT     /api/rbac/roles/{id}
DELETE  /api/rbac/roles/{id}
```

### Permission Management
```
POST    /api/rbac/permissions
GET     /api/rbac/permissions
PUT     /api/rbac/permissions/{id}
DELETE  /api/rbac/permissions/{id}
```

### Group Management
```
POST    /api/rbac/groups
GET     /api/rbac/groups
PUT     /api/rbac/groups/{id}
DELETE  /api/rbac/groups/{id}
```

### Role Hierarchy
```
POST    /api/rbac/roles/hierarchy/{parentRoleId}/children/{childRoleId}
DELETE  /api/rbac/roles/hierarchy/{parentRoleId}/children/{childRoleId}
GET     /api/rbac/roles/hierarchy/{roleId}/children
GET     /api/rbac/roles/hierarchy/precedence
```

## Error Handling

The system defines specific error codes for RBAC operations:

- RBAC_001: Permission denied
- RBAC_002: Invalid role hierarchy
- RBAC_003: Entity not found
- RBAC_004: Invalid operation

## Configuration

### Cache Configuration
```java
@EnableCaching
public class RBACCacheConfig {
    // Cache configurations for permissions and roles
}
```

### Security Configuration
```java
@EnableMethodSecurity
public class SecurityConfig {
    // Security configurations for RBAC
}
```

## Migration Guide

When upgrading or modifying the RBAC system:

1. Back up existing role assignments
2. Update permission definitions
3. Migrate role hierarchies
4. Verify group memberships
5. Test permission evaluations

## Troubleshooting

Common issues and solutions:

1. Permission Denied
   - Check role assignments
   - Verify permission definitions
   - Review role hierarchy

2. Circular Dependencies
   - Review role relationships
   - Check inheritance chains
   - Validate role assignments

3. Performance Issues
   - Review cache configuration
   - Check permission evaluations
   - Optimize role hierarchy
</file>

<file path="docs/a/README.md">
# PharmacyHub Frontend Documentation

Welcome to the PharmacyHub frontend documentation. This repository provides comprehensive information about the project's architecture, features, and development guidelines.

## Documentation Structure

1. [Overview](../../../pharmacyhub-frontend/docs/01-overview/README.md)
   - System purpose and requirements
   - Technical stack
   - Getting started

2. [Architecture](../../../pharmacyhub-frontend/docs/02-architecture/README.md)
   - Project structure
   - Design patterns
   - Component organization
   - State management

3. [Authentication](../../../pharmacyhub-frontend/docs/03-authentication/README.md)
   - Authentication system
   - Keycloak integration
   - Permission system
   - Security considerations

4. [Features](../../../pharmacyhub-frontend/docs/04-features/README.md)
   - Licensing management
   - Exam preparation
   - Pharmacy operations
   - Reporting & analytics

5. [Development](../../../pharmacyhub-frontend/docs/05-development/README.md)
   - Development standards
   - Coding patterns
   - API integration
   - Testing guidelines

6. [Deployment](../../../pharmacyhub-frontend/docs/06-deployment/README.md)
   - Deployment architecture
   - CI/CD pipeline
   - Environment configuration
   - Monitoring & logging

7. [Assets](../../../pharmacyhub-frontend/docs/07-assets/README.md)
   - Image requirements
   - Asset organization
   - Optimization guidelines

## Quick Start

```bash
# Install dependencies
npm install

# Run development server
npm run dev
```

## Project Overview

PharmacyHub is a comprehensive pharmacy management and licensing platform built with Next.js 15, TypeScript, and Keycloak for authentication. The application follows Feature-Sliced Design (FSD) principles and Domain-Driven Design (DDD) for maintainable, scalable architecture.

For detailed information, please navigate to the appropriate section in the documentation structure.
</file>

<file path="docs/architecture/01-core-architecture.md">
# Core Architecture

## Overview

PharmacyHub backend follows a layered architecture pattern with clear separation of concerns. This document outlines the core architectural components and their interactions.

## Architectural Layers

### 1. Presentation Layer (Controllers)
- Located in `com.pharmacyhub.controller`
- Handles HTTP requests and responses
- Implements REST endpoints
- Manages request validation
- Handles response formatting

### 2. Business Layer (Services)
- Located in `com.pharmacyhub.service`
- Implements business logic
- Manages transactions
- Handles data transformation
- Implements business rules

### 3. Data Access Layer (Repositories)
- Located in `com.pharmacyhub.repository`
- Manages database operations
- Implements data access patterns
- Handles database transactions
- Manages entity relationships

### 4. Domain Layer (Entities)
- Located in `com.pharmacyhub.entity`
- Defines domain models
- Implements business rules
- Manages entity relationships
- Defines domain constraints

## Core Components

### PHEngine
```java
@Component
public class PHEngine {
    public User getLoggedInUser() {
        UserDetails userDetails = (UserDetails) SecurityContextHolder
            .getContext()
            .getAuthentication()
            .getPrincipal();
        return (User) userDetails;
    }
}
```

### PHMapper
```java
@Component
public class PHMapper {
    private ModelMapper modelMapper = new ModelMapper();
    
    // DTO to Entity mapping methods
    public User getUser(UserDTO userDTO) {
        return modelMapper.map(userDTO, User.class);
    }
    
    // Entity to DTO mapping methods
    public UserDTO getUserDTO(User user) {
        return modelMapper.map(user, UserDTO.class);
    }
}
```

## Component Interactions

```mermaid
graph TD
    A[Controller] --> B[Service]
    B --> C[Repository]
    B --> D[PHMapper]
    B --> E[PHEngine]
    C --> F[Database]
```

## Key Design Decisions

1. **Base Engine Pattern**
   - All services extend PHEngine
   - Provides common functionality
   - Centralizes cross-cutting concerns

2. **Mapper Pattern**
   - Centralized mapping through PHMapper
   - Consistent DTO-Entity conversion
   - Clear transformation rules

3. **Repository Pattern**
   - Interface-based repositories
   - Spring Data JPA implementation
   - Clean data access separation

4. **Service Pattern**
   - Interface-based service definitions
   - Clear business logic separation
   - Transaction management

## Code Organization

```
com.pharmacyhub/
├── config/           # Configuration classes
├── constants/        # Enums and constants
├── controller/       # REST controllers
├── dto/             # Data transfer objects
├── engine/          # Core engine components
├── entity/          # Domain entities
├── repository/      # Data access layer
├── security/        # Security components
├── service/         # Business logic
└── util/            # Utility classes
```

## Configuration Management

- Application properties in `application.yml`
- Environment-specific configurations
- Security configurations
- Database configurations

## Cross-Cutting Concerns

1. **Security**
   - JWT authentication
   - Role-based authorization
   - Security filters

2. **Logging**
   - Centralized logging
   - Log levels
   - Log formatting

3. **Exception Handling**
   - Global exception handler
   - Custom exceptions
   - Error responses

4. **Validation**
   - Input validation
   - Business rule validation
   - Cross-field validation

## Best Practices

1. **Code Organization**
   - Follow package structure
   - Maintain separation of concerns
   - Use proper naming conventions

2. **Error Handling**
   - Use custom exceptions
   - Implement proper logging
   - Return appropriate responses

3. **Security**
   - Implement proper authentication
   - Use authorization
   - Follow security best practices

4. **Testing**
   - Write unit tests
   - Implement integration tests
   - Follow testing best practices
</file>

<file path="docs/architecture/02-design-patterns.md">
# Design Patterns

This document outlines the key design patterns used in the PharmacyHub backend application.

## Core Patterns

### 1. Base Engine Pattern

The Base Engine Pattern is implemented through `PHEngine` and provides common functionality across services.

```java
@Component
public class PHEngine {
    public User getLoggedInUser() {
        // Implementation
    }
    
    // Other common methods
}

@Service
public class UserService extends PHEngine {
    // Service implementation using base functionality
}
```

**When to use:**
- When implementing new services that need access to common functionality
- When adding features that require user context
- For cross-cutting concerns

### 2. Mapper Pattern

Centralized mapping through `PHMapper` using ModelMapper.

```java
@Component
public class PHMapper {
    private ModelMapper modelMapper = new ModelMapper();
    
    // Entity to DTO
    public UserDTO getUserDTO(User user) {
        return modelMapper.map(user, UserDTO.class);
    }
    
    // DTO to Entity
    public User getUser(UserDTO userDTO) {
        return modelMapper.map(userDTO, User.class);
    }
}
```

**When to use:**
- When adding new DTOs
- When implementing new entity mappings
- For consistent object transformation

### 3. Repository Pattern

Interface-based repositories using Spring Data JPA.

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByEmailAddress(String emailAddress);
    List<User> findByUserType(String userType);
}
```

**When to use:**
- When adding new entities
- When implementing custom queries
- For data access operations

### 4. Service Pattern

Interface-based services with clear business logic separation.

```java
public interface UserService {
    UserDTO createUser(UserDTO userDTO);
    UserDTO updateUser(UserDTO userDTO);
    void deleteUser(Long id);
}

@Service
public class UserServiceImpl implements UserService {
    // Implementation
}
```

**When to use:**
- When adding new business functionality
- When implementing business rules
- For transaction management

## Implementation Guidelines

### 1. SOLID Principles

#### Single Responsibility
```java
// Good
public class UserService {
    public User createUser() { }
    public User updateUser() { }
}

// Bad
public class UserService {
    public User createUser() { }
    public void sendEmail() { }
}
```

#### Open/Closed
```java
// Good
public interface UserValidator {
    boolean validate(User user);
}

public class EmailValidator implements UserValidator {
    public boolean validate(User user) { }
}
```

#### Liskov Substitution
```java
// Good
public class Pharmacist extends User {
    @Override
    public void updateProfile() {
        // Specific implementation
    }
}
```

#### Interface Segregation
```java
// Good
public interface UserReader {
    User getUser(Long id);
    List<User> getAllUsers();
}

public interface UserWriter {
    User createUser(User user);
    User updateUser(User user);
}
```

#### Dependency Inversion
```java
// Good
@Service
public class UserService {
    private final UserRepository userRepository;
    
    @Autowired
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
}
```

### 2. Pattern Usage Guidelines

1. **When Creating New Features**
   - Identify required patterns
   - Follow existing implementations
   - Maintain consistency

2. **When Extending Functionality**
   - Use appropriate patterns
   - Maintain separation of concerns
   - Follow SOLID principles

3. **When Implementing Business Logic**
   - Use service pattern
   - Implement proper validation
   - Handle errors appropriately

## Common Anti-patterns to Avoid

1. **God Objects**
```java
// Bad
public class UserService {
    public User createUser() { }
    public void sendEmail() { }
    public void generateReport() { }
    public void processPayment() { }
}
```

2. **Anemic Domain Model**
```java
// Bad
public class User {
    private String name;
    private String email;
    // Only getters and setters
}
```

3. **Mixed Responsibilities**
```java
// Bad
public class UserController {
    public User createUser() {
        // Direct database operations
        // Email sending
        // PDF generation
    }
}
```

## Best Practices

1. **Pattern Selection**
   - Choose appropriate patterns
   - Consider maintainability
   - Follow existing patterns

2. **Implementation**
   - Follow SOLID principles
   - Maintain clean code
   - Write proper documentation

3. **Testing**
   - Test pattern implementations
   - Verify pattern behavior
   - Ensure pattern consistency
</file>

<file path="docs/EXAM_API.md">
# Exam Feature API Documentation

This document describes the RESTful API endpoints available for the Exam feature in the PharmacyHub application.

## Table of Contents

- [Exam API](#exam-api)
- [Exam Paper API](#exam-paper-api)
- [Exam Attempt API](#exam-attempt-api)

## Exam API

### Get All Exams

```
GET /api/exams
```

Returns a list of all active exams.

### Get Published Exams

```
GET /api/exams/published
```

Returns a list of all published exams.

### Get Exam by ID

```
GET /api/exams/{id}
```

Returns a specific exam by its ID.

### Create Exam

```
POST /api/exams
```

Creates a new exam.

**Request Body:**

```json
{
  "title": "Basic Pharmacology Exam",
  "description": "Test your knowledge of basic pharmacology concepts",
  "duration": 30,
  "totalMarks": 100,
  "passingMarks": 60
}
```

### Update Exam

```
PUT /api/exams/{id}
```

Updates an existing exam.

**Request Body:**

Same as create exam.

### Delete Exam

```
DELETE /api/exams/{id}
```

Marks an exam as deleted (soft delete).

### Get Exams by Status

```
GET /api/exams/status/{status}
```

Returns exams filtered by status (DRAFT, PUBLISHED, ARCHIVED).

### Publish Exam

```
POST /api/exams/{id}/publish
```

Changes an exam's status to PUBLISHED.

### Archive Exam

```
POST /api/exams/{id}/archive
```

Changes an exam's status to ARCHIVED.

## Exam Paper API

### Get All Papers

```
GET /api/exams/papers
```

Returns a list of all active exam papers.

### Get Model Papers

```
GET /api/exams/papers/model
```

Returns a list of all model papers.

### Get Past Papers

```
GET /api/exams/papers/past
```

Returns a list of all past papers.

### Get Paper by ID

```
GET /api/exams/papers/{id}
```

Returns a specific exam paper by its ID.

### Get Exam Stats

```
GET /api/exams/papers/stats
```

Returns statistics about exams including total papers, average duration, completion rate, and active users.

**Response:**

```json
{
  "totalPapers": 10,
  "avgDuration": 45,
  "completionRate": 75,
  "activeUsers": 125
}
```

### Create Paper

```
POST /api/exams/papers
```

Creates a new exam paper.

**Request Body:**

```json
{
  "title": "Pharmacology Basics 2024",
  "description": "Comprehensive review of basic pharmacology principles",
  "difficulty": "easy",
  "questionCount": 50,
  "durationMinutes": 60,
  "tags": ["Basic Pharmacology", "Drug Classification", "Mechanisms of Action"],
  "premium": false,
  "type": "MODEL",
  "examId": 1
}
```

### Update Paper

```
PUT /api/exams/papers/{id}
```

Updates an existing exam paper.

**Request Body:**

Same as create paper.

### Delete Paper

```
DELETE /api/exams/papers/{id}
```

Marks a paper as deleted (soft delete).

## Exam Attempt API

### Start Exam

```
POST /api/exams/{id}/start?userId={userId}
```

Starts an exam attempt for the specified user.

**Response:**

```json
{
  "id": 1,
  "examId": 1,
  "userId": "user123",
  "startTime": "2024-02-26T10:30:00Z",
  "status": "IN_PROGRESS",
  "answers": []
}
```

### Submit Exam

```
POST /api/exams/attempts/{attemptId}/submit
```

Submits an exam attempt with user answers.

**Request Body:**

```json
[
  {
    "questionId": 1,
    "selectedOptionId": "A",
    "timeSpent": 45
  },
  {
    "questionId": 2,
    "selectedOptionId": "B",
    "timeSpent": 30
  }
]
```

**Response:**

```json
{
  "examId": 1,
  "examTitle": "Basic Pharmacology Exam",
  "score": 75.0,
  "totalMarks": 100,
  "passingMarks": 60,
  "isPassed": true,
  "timeSpent": 320,
  "questionResults": [
    {
      "questionId": 1,
      "questionText": "Which of the following is NOT a phase of pharmacokinetics?",
      "userAnswerId": "A",
      "correctAnswerId": "E",
      "isCorrect": false,
      "explanation": "Receptor binding is a part of pharmacodynamics, not pharmacokinetics.",
      "points": 10,
      "earnedPoints": 0
    },
    {
      "questionId": 2,
      "questionText": "Which of the following best describes first-pass metabolism?",
      "userAnswerId": "B",
      "correctAnswerId": "B",
      "isCorrect": true,
      "explanation": "First-pass metabolism refers to the metabolic degradation of a drug in the liver after absorption from the GI tract but before it reaches the systemic circulation.",
      "points": 10,
      "earnedPoints": 10
    }
  ]
}
```

### Get User's Attempts

```
GET /api/exams/attempts/user/{userId}
```

Returns all exam attempts for a specific user.

### Get Attempt by ID

```
GET /api/exams/attempts/{id}
```

Returns a specific exam attempt by its ID.

### Get Attempts by Exam and User

```
GET /api/exams/{examId}/attempts?userId={userId}
```

Returns all attempts for a specific exam by a specific user.

## Data Models

### Exam

```json
{
  "id": 1,
  "title": "Basic Pharmacology Exam",
  "description": "Test your knowledge of basic pharmacology concepts",
  "duration": 30,
  "totalMarks": 100,
  "passingMarks": 60,
  "status": "PUBLISHED",
  "questions": [...]
}
```

### Exam Paper

```json
{
  "id": 1,
  "title": "Pharmacology Basics 2024",
  "description": "Comprehensive review of basic pharmacology principles",
  "difficulty": "easy",
  "questionCount": 50,
  "durationMinutes": 60,
  "tags": ["Basic Pharmacology", "Drug Classification", "Mechanisms of Action"],
  "premium": false,
  "attemptCount": 1250,
  "successRatePercent": 78.5,
  "lastUpdatedDate": "2024-02-15",
  "type": "MODEL",
  "examId": 1
}
```

### Question

```json
{
  "id": 1,
  "questionNumber": 1,
  "questionText": "Which of the following is NOT a phase of pharmacokinetics?",
  "options": [...],
  "correctAnswer": "E",
  "explanation": "Receptor binding is a part of pharmacodynamics, not pharmacokinetics.",
  "marks": 10
}
```

### Exam Attempt

```json
{
  "id": 1,
  "examId": 1,
  "userId": "user123",
  "startTime": "2024-02-26T10:30:00Z",
  "status": "IN_PROGRESS",
  "answers": [...]
}
```

### User Answer

```json
{
  "questionId": 1,
  "selectedOptionId": "A",
  "timeSpent": 45
}
```

### Exam Result

```json
{
  "examId": 1,
  "examTitle": "Basic Pharmacology Exam",
  "score": 75.0,
  "totalMarks": 100,
  "passingMarks": 60,
  "isPassed": true,
  "timeSpent": 320,
  "questionResults": [...]
}
```

## Error Responses

The API returns appropriate HTTP status codes for different types of errors:

- `400 Bad Request` - Invalid input data
- `404 Not Found` - Resource not found
- `500 Internal Server Error` - Server-side error

Error responses include a message in the following format:

```json
{
  "timestamp": "2024-02-26T12:34:56.789Z",
  "status": 404,
  "error": "Not Found",
  "message": "Exam not found with id: 123",
  "path": "/api/exams/123"
}
```
</file>

<file path="docs/EXAM_IMPLEMENTATION_SUMMARY.md">
# Exam Feature Implementation Summary

## Overview

This document summarizes the implementation of the exam feature in the PharmacyHub application, integrating the frontend with a robust backend.

## Completed Work

### Backend Implementation

1. **Entity Classes**
   - Created `ExamPaper.java` - For model and past papers
   - Created `ExamAttempt.java` - For tracking user attempts
   - Created `UserAnswer.java` - For storing user answers
   - Created `ExamResult.java` - For storing exam results

2. **Repository Interfaces**
   - Created `ExamPaperRepository.java`
   - Created `ExamAttemptRepository.java`
   - Created `UserAnswerRepository.java`
   - Created `ExamResultRepository.java`

3. **DTOs**
   - Created `ExamPaperDTO.java`
   - Created `ExamAttemptDTO.java`
   - Created `UserAnswerDTO.java`
   - Created `ExamResultDTO.java`
   - Created `ExamStatsDTO.java`

4. **Services**
   - Created `ExamPaperService.java` (interface)
   - Created `ExamPaperServiceImpl.java` (implementation)
   - Created `ExamAttemptService.java` (interface)
   - Created `ExamAttemptServiceImpl.java` (implementation)

5. **Controllers**
   - Created `ExamPaperController.java` for handling exam paper endpoints
   - Created `ExamAttemptController.java` for handling exam attempt endpoints

### Frontend Integration

1. **API Services**
   - Updated `examService.ts` to use real API calls
   - Updated `mcqService.ts` to use real API calls
   - Created adapters for transforming backend data to frontend models

2. **State Management**
   - Created `examPaperStore.ts` for managing exam papers

3. **Removed Mock Data**
   - Removed all mock data in favor of real API calls

### Documentation

1. **API Documentation**
   - Created `EXAM_API.md` documenting all API endpoints

2. **Integration Guide**
   - Created `EXAM_INTEGRATION_GUIDE.md` to guide developers through the integration process

## API Endpoints

The following API endpoints have been implemented:

### Exam Papers
- `GET /api/exams/papers` - Get all exam papers
- `GET /api/exams/papers/model` - Get model papers
- `GET /api/exams/papers/past` - Get past papers
- `GET /api/exams/papers/{id}` - Get paper by ID
- `GET /api/exams/papers/stats` - Get exam statistics
- `POST /api/exams/papers` - Create a new exam paper
- `PUT /api/exams/papers/{id}` - Update an exam paper
- `DELETE /api/exams/papers/{id}` - Delete an exam paper

### Exam Attempts
- `POST /api/exams/{id}/start` - Start an exam attempt
- `POST /api/exams/attempts/{id}/submit` - Submit an exam attempt
- `GET /api/exams/attempts/user/{userId}` - Get user's exam attempts
- `GET /api/exams/attempts/{id}` - Get exam attempt by ID
- `GET /api/exams/{examId}/attempts` - Get attempts for a specific exam

## Database Schema

The following database tables have been created:

1. `exam_papers` - Stores model and past papers
2. `exam_paper_tags` - Stores tags for exam papers
3. `exam_attempts` - Stores user attempts at exams
4. `user_answers` - Stores user answers to questions
5. `exam_results` - Stores results of completed exams

## Testing

The implementation has been tested with:

1. **Unit Tests** - For individual components
2. **Integration Tests** - For API endpoints
3. **End-to-End Tests** - For the complete flow

## Next Steps

1. **User Interface Improvements**
   - Add progress tracking for users
   - Implement performance analytics
   - Add study recommendations based on exam results

2. **Performance Optimization**
   - Optimize database queries
   - Implement caching for frequently accessed data
   - Reduce API payload sizes

3. **Extended Features**
   - Add timed practice mode
   - Implement study groups
   - Add discussion forums for questions

## Conclusion

The exam feature has been successfully implemented, integrating the frontend with a robust backend. The feature now supports browsing exam papers, taking exams, and viewing results and progress.
</file>

<file path="docs/EXAM_IMPLEMENTATION_VERIFICATION.md">
# Exam Feature Implementation Summary

## Overview

This document summarizes the implementation of the exam feature, including the improvements made to ensure proper functionality and integration between frontend and backend components.

## Key Components Implemented/Improved

### Model Types
- Updated `mcqTypes.ts` to include proper `ExamQuestion` and `ExamOption` types needed by the UI components
- Fixed inconsistencies between model types and API adapter
- Ensured UserAnswer type properly reflects the backend API requirements

### UI Components
- Created smaller, reusable components instead of monolithic ones:
  - `McqQuestionCard.tsx` - For displaying questions and recording answers
  - `McqQuestionNavigation.tsx` - For navigating between questions
  - `ExamTimer.tsx` - For showing remaining time and allowing pause/resume functionality
  - `McqExamResults.tsx` - For displaying comprehensive exam results

### Page Implementation
- Created dedicated page components:
  - `/exams/page.tsx` - Main entry point for browsing exams
  - `/exams/[id]/page.tsx` - Dynamic route for taking a specific exam
  - `/exams/results/page.tsx` - For displaying exam results

### State Management
- Improved the Zustand store implementation in `mcqExamStore.ts`:
  - Better error handling
  - Type safety improvements
  - Added functions for flagging/unflagging questions
  - Added setCurrentQuestionIndex method for direct navigation

### API Integration
- Fixed adapters to properly convert between backend and frontend data models
- Updated `examService.ts` to properly handle API calls
- Added proper error handling for API failures

## User Experience Improvements

### Exam Taking
- Added responsive question navigation
- Implemented flagging for questions that need review
- Improved timer with pause/resume functionality
- Better visual feedback for answered questions

### Results Viewing
- Comprehensive results page with:
  - Summary tab showing overall performance
  - Questions tab for reviewing each question and answer
  - Analytics tab for visualizing performance metrics

## Data Flow
1. **Exam Browsing**:
   - User selects from model papers or past papers
   - Backend provides list of available exams

2. **Exam Taking**:
   - User starts exam which creates an attempt record in backend
   - Questions are presented one by one with navigation
   - User answers are tracked in frontend state
   - User can flag questions for review

3. **Exam Submission**:
   - Answers are submitted to backend for evaluation
   - Backend returns detailed results
   - Results are displayed in the results page

## Implementation Notes

### Performance Considerations
- Minimized re-renders in the exam UI
- Used efficient state management with Zustand
- Implemented component modularity for better code organization

### Error Handling
- Added proper error states throughout the application
- Implemented error recovery mechanisms
- Improved user feedback for error conditions

### Accessibility
- Ensured all interactive elements are keyboard accessible
- Added appropriate ARIA attributes
- Used semantic HTML for better screen reader support

## Future Improvements
- Add exam categories and filtering options
- Implement user progress tracking across multiple exams
- Add study recommendations based on exam performance
- Implement offline mode for taking exams without internet connection
- Add ability to pause exam and continue later

## Testing Recommendations
1. Test exam navigation with keyboard and mouse
2. Verify timer functionality, especially pause/resume
3. Test flagging and unflagging questions
4. Verify submission with different numbers of answered questions
5. Test results page for various score scenarios
6. Verify error handling with network interruptions
</file>

<file path="docs/EXAM_INTEGRATION_GUIDE.md">
# Exam Feature Integration Guide

This document provides a guide for integrating the backend and frontend exam features in PharmacyHub.

## Overview

The exam feature allows users to:
1. Browse model papers and past papers
2. Take exams
3. View results and progress

## Backend Components

The backend implementation includes:

### Entities
- `Exam.java` - Basic exam entity
- `Question.java` - Questions for exams
- `Option.java` - Options for questions
- `ExamPaper.java` - Model papers and past papers
- `ExamAttempt.java` - User attempts at exams
- `UserAnswer.java` - User answers to questions
- `ExamResult.java` - Results of completed exams

### Services
- `ExamService` - Manages exams
- `QuestionService` - Manages questions
- `OptionService` - Manages options
- `ExamPaperService` - Manages exam papers
- `ExamAttemptService` - Manages exam attempts

### Controllers
- `ExamController` - API for exams
- `ExamPaperController` - API for exam papers
- `ExamAttemptController` - API for exam attempts

## Frontend Components

The frontend implementation uses:

### API Services
- `examService.ts` - API client for exams
- `mcqService.ts` - API client for MCQs
- `examPaperService.ts` - API client for exam papers

### State Management
- `examStore.ts` - Zustand store for exams
- `mcqExamStore.ts` - Zustand store for MCQs
- `examPaperStore.ts` - Zustand store for exam papers

## API Endpoints

### Exam Papers
- `GET /api/exams/papers/model` - Get model papers
- `GET /api/exams/papers/past` - Get past papers
- `GET /api/exams/papers/:id` - Get paper by ID
- `GET /api/exams/papers/stats` - Get exam statistics

### Exams
- `GET /api/exams/published` - Get published exams
- `GET /api/exams/:id` - Get exam by ID

### Exam Attempts
- `POST /api/exams/:id/start` - Start an exam attempt
- `POST /api/exams/attempts/:id/submit` - Submit an exam attempt

## Integration Steps

### 1. Database Migration

Run the following SQL migration script to create the new tables:

```sql
-- Create exam_papers table
CREATE TABLE exam_papers (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    description TEXT,
    difficulty VARCHAR(10) NOT NULL,
    question_count INT NOT NULL,
    duration_minutes INT NOT NULL,
    premium BOOLEAN DEFAULT FALSE,
    attempt_count INT DEFAULT 0,
    success_rate_percent DOUBLE DEFAULT 0.0,
    last_updated_date DATE DEFAULT CURRENT_DATE,
    type VARCHAR(10) NOT NULL,
    exam_id BIGINT,
    deleted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (exam_id) REFERENCES exams(id)
);

-- Create exam_paper_tags table
CREATE TABLE exam_paper_tags (
    exam_paper_id BIGINT NOT NULL,
    tag VARCHAR(255) NOT NULL,
    PRIMARY KEY (exam_paper_id, tag),
    FOREIGN KEY (exam_paper_id) REFERENCES exam_papers(id)
);

-- Create exam_attempts table
CREATE TABLE exam_attempts (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    exam_id BIGINT NOT NULL,
    user_id VARCHAR(255) NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP,
    score DOUBLE,
    status VARCHAR(20) NOT NULL,
    deleted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (exam_id) REFERENCES exams(id)
);

-- Create user_answers table
CREATE TABLE user_answers (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    attempt_id BIGINT NOT NULL,
    question_id BIGINT NOT NULL,
    selected_option_id VARCHAR(10),
    time_spent INT NOT NULL,
    deleted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (attempt_id) REFERENCES exam_attempts(id),
    FOREIGN KEY (question_id) REFERENCES questions(id)
);

-- Create exam_results table
CREATE TABLE exam_results (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    attempt_id BIGINT NOT NULL,
    score DOUBLE NOT NULL,
    total_questions INT NOT NULL,
    correct_answers INT NOT NULL,
    incorrect_answers INT NOT NULL,
    unanswered INT NOT NULL,
    time_spent INT NOT NULL,
    is_passed BOOLEAN NOT NULL,
    completed_at TIMESTAMP NOT NULL,
    deleted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (attempt_id) REFERENCES exam_attempts(id)
);
```

### 2. Backend Implementation

1. **Add Entity Classes**
   - Copy the new entity classes (`ExamPaper.java`, `ExamAttempt.java`, `UserAnswer.java`, `ExamResult.java`) to the `com.pharmacyhub.domain.entity` package.

2. **Add Repository Interfaces**
   - Copy the new repository interfaces (`ExamPaperRepository.java`, `ExamAttemptRepository.java`, `UserAnswerRepository.java`, `ExamResultRepository.java`) to the `com.pharmacyhub.domain.repository` package.

3. **Add DTOs**
   - Copy the new DTO classes (`ExamPaperDTO.java`, `ExamAttemptDTO.java`, `UserAnswerDTO.java`, `ExamResultDTO.java`, `ExamStatsDTO.java`) to the `com.pharmacyhub.dto` package.

4. **Add Service Interfaces and Implementations**
   - Copy the service interfaces (`ExamPaperService.java`, `ExamAttemptService.java`) to the `com.pharmacyhub.service` package.
   - Copy the service implementations (`ExamPaperServiceImpl.java`, `ExamAttemptServiceImpl.java`) to the `com.pharmacyhub.service` package.

5. **Add Controllers**
   - Copy the controllers (`ExamPaperController.java`, `ExamAttemptController.java`) to the `com.pharmacyhub.controller` package.

6. **Update Existing ExamController**
   - Modify `ExamController.java` to include the new endpoints for starting and submitting exams.

### 3. Create Sample Data

Insert sample data for testing:

```sql
-- Insert sample exam papers (MODEL)
INSERT INTO exam_papers (title, description, difficulty, question_count, duration_minutes, premium, attempt_count, success_rate_percent, type, exam_id)
VALUES 
('Pharmacology Basics 2024', 'Comprehensive review of basic pharmacology principles', 'EASY', 50, 60, false, 1250, 78.5, 'MODEL', 1),
('Clinical Pharmacy Practice', 'Advanced clinical pharmacy scenarios and case studies', 'HARD', 75, 90, true, 850, 65.0, 'MODEL', 2),
('Pharmaceutical Calculations', 'Essential calculations for pharmacy practice', 'MEDIUM', 40, 60, false, 2000, 72.3, 'MODEL', 3),
('Pharmacy Law & Ethics', 'Latest updates on pharmacy regulations and ethical practices', 'MEDIUM', 60, 75, true, 1500, 70.0, 'MODEL', 4);

-- Insert sample exam papers (PAST)
INSERT INTO exam_papers (title, description, difficulty, question_count, duration_minutes, premium, attempt_count, success_rate_percent, type, exam_id)
VALUES 
('2023 Board Exam Paper 1', 'Official board examination from 2023', 'HARD', 100, 180, true, 3000, 68.0, 'PAST', 5),
('2023 Board Exam Paper 2', 'Second paper from 2023 board examination', 'HARD', 100, 180, true, 2800, 65.0, 'PAST', 6);

-- Insert sample tags for exam papers
INSERT INTO exam_paper_tags (exam_paper_id, tag)
VALUES 
(1, 'Basic Pharmacology'),
(1, 'Drug Classification'),
(1, 'Mechanisms of Action'),
(2, 'Patient Care'),
(2, 'Clinical Decision Making'),
(2, 'Therapeutic Management'),
(3, 'Dosage Calculations'),
(3, 'Concentration Calculations'),
(3, 'Compounding'),
(4, 'Pharmacy Laws'),
(4, 'Professional Ethics'),
(4, 'Regulatory Compliance'),
(5, 'Comprehensive'),
(5, 'Clinical Practice'),
(5, 'Pharmacy Management'),
(6, 'Drug Therapy'),
(6, 'Patient Care'),
(6, 'Pharmacy Operations');
```

### 4. Frontend Integration

1. **Update API Services**
   - Update `examService.ts` to use real API calls instead of mock data
   - Update `mcqService.ts` to use real API calls instead of mock data
   - Create `examPaperService.ts` to handle exam paper related API calls

2. **Update State Management**
   - Update existing Zustand stores to work with the new API endpoints
   - Create `examPaperStore.ts` for managing exam papers state

3. **Update UI Components**
   - Update UI components to use the new stores and APIs
   - Ensure error handling is in place for API calls
   - Add loading states for better user experience

### 5. Testing

1. **Backend Testing**
   - Test each API endpoint using Postman or similar tools
   - Verify data is correctly stored in the database
   - Check error handling for edge cases

2. **Frontend Testing**
   - Test the browse exams feature
   - Test the take exam flow from start to finish
   - Test viewing results and progress

### 6. Integration Testing

1. **Full Flow Testing**
   - Test browsing exam papers
   - Test starting an exam
   - Test submitting answers
   - Test viewing results

### 7. Deployment

1. **Database Migration**
   - Run migration scripts on production database
   - Verify tables are created correctly

2. **Backend Deployment**
   - Deploy backend changes
   - Verify API endpoints are accessible

3. **Frontend Deployment**
   - Deploy frontend changes
   - Verify integration is working in production

## Data Formats

### Frontend to Backend

When starting an exam:
```
POST /api/exams/{id}/start?userId={userId}
```

When submitting answers:
```json
[
  {
    "questionId": 1,
    "selectedOptionId": "A",
    "timeSpent": 45
  },
  {
    "questionId": 2,
    "selectedOptionId": "B",
    "timeSpent": 30
  }
]
```

### Backend to Frontend

Exam papers:
```json
[
  {
    "id": 1,
    "title": "Pharmacology Basics 2024",
    "description": "Comprehensive review...",
    "difficulty": "easy",
    "questionCount": 50,
    "durationMinutes": 60,
    "tags": ["Basic Pharmacology", "Drug Classification"],
    "premium": false,
    "attemptCount": 1250,
    "successRatePercent": 78.5,
    "lastUpdatedDate": "2024-02-15",
    "type": "MODEL"
  }
]
```

Exam stats:
```json
{
  "totalPapers": 10,
  "avgDuration": 45,
  "completionRate": 75,
  "activeUsers": 125
}
```

Exam result:
```json
{
  "examId": 1,
  "examTitle": "Basic Pharmacology Exam",
  "score": 75.0,
  "totalMarks": 100,
  "passingMarks": 60,
  "isPassed": true,
  "timeSpent": 320,
  "questionResults": [
    {
      "questionId": 1,
      "questionText": "Which of the following is NOT a phase of pharmacokinetics?",
      "userAnswerId": "A",
      "correctAnswerId": "E",
      "isCorrect": false,
      "explanation": "Receptor binding is part of pharmacodynamics...",
      "points": 10,
      "earnedPoints": 0
    }
  ]
}
```

## Troubleshooting

### Common Issues

1. **API Errors**
   - Check API endpoint URLs in frontend services
   - Verify authentication headers are being sent
   - Check backend logs for detailed error messages

2. **Database Issues**
   - Verify foreign key constraints
   - Check database connection settings
   - Ensure database migrations have been applied

3. **Frontend State Management**
   - Debug Zustand stores with browser dev tools
   - Verify actions are properly updating state
   - Check for race conditions in async operations

### Support Contacts

For backend issues, contact:
- Backend Team Lead: backendlead@pharmacyhub.com

For frontend issues, contact:
- Frontend Team Lead: frontendlead@pharmacyhub.com

For database issues, contact:
- Database Administrator: dba@pharmacyhub.com
</file>

<file path="docs/EXAM_RECURSION_FIX.md">
# Exam Feature Recursion Issue Fix

## Problem Overview

The exam feature was experiencing recursion issues during API serialization. This was causing the exam data not to be properly retrieved from the backend, resulting in frontend integration issues.

### Root Cause Analysis

The problem was caused by bidirectional relationships in the entity model:

1. **Circular References**: The `Exam` entity had a bidirectional relationship with `Question` entities. When Jackson attempted to serialize an `Exam` object, it would include all `Question` objects, which in turn referenced back to the `Exam`, creating an infinite recursion.

2. **Entity-to-DTO Conversion**: The static conversion methods in the DTO classes were triggering the recursive loading of related entities.

3. **Lazy Loading Issues**: The JPA lazy loading mechanism, combined with entity-to-DTO conversion, was causing additional queries to be executed during serialization.

## Solution Implemented

We implemented the following changes to fix the recursion issue:

### 1. Controller-Based DTO Conversion

Moved the entity-to-DTO conversion logic from the DTO classes to the controllers:

```java
private ExamDTO convertToDTO(Exam exam) {
    ExamDTO dto = new ExamDTO();
    dto.setId(exam.getId());
    dto.setTitle(exam.getTitle());
    dto.setDescription(exam.getDescription());
    dto.setDuration(exam.getDuration());
    dto.setTotalMarks(exam.getTotalMarks());
    dto.setPassingMarks(exam.getPassingMarks());
    dto.setStatus(exam.getStatus());
    dto.setQuestionCount(exam.getQuestions() != null ? exam.getQuestions().size() : 0);
    return dto;
}
```

This approach:
- Moves the transformation logic closer to the API layer
- Maintains the clear separation between entities and DTOs
- Gives more control over what data is exposed in the API responses

### 2. Service Layer Refactoring

Modified the service layer to work directly with entities instead of DTOs:

```java
public interface ExamService {
    List<Exam> findAllActive();
    List<Exam> findAllPublished();
    Optional<Exam> findById(Long id);
    // ...
}
```

This change:
- Simplifies the service layer responsibilities to focus on business logic
- Avoids redundant conversions between entities and DTOs
- Makes the code more maintainable by clearly defining responsibilities

### 3. Reference Management

Updated the DTO conversion to only include necessary IDs for relationships:

```java
// Only take the ID of the exam entity to prevent recursion
dto.setExamId(paper.getExam() != null ? paper.getExam().getId() : null);
```

This approach:
- Prevents circular references during serialization
- Reduces payload size in API responses
- Ensures the API sends only the necessary data

## Benefits of the Solution

The implemented changes provide several benefits:

1. **Improved Performance**: Fewer database queries due to more controlled entity loading
2. **Reduced Memory Usage**: Smaller object graphs in memory during API calls
3. **Cleaner Architecture**: Better separation of concerns between layers
4. **More Maintainable Code**: Simplified entity and DTO structure
5. **Consistent API Responses**: Predictable JSON structure for frontend integration

## Future Recommendations

To further improve the architecture and prevent similar issues:

1. **API Documentation**: Add detailed API documentation using Swagger/OpenAPI
2. **DTO Validation**: Add validation rules directly to DTOs
3. **Pagination**: Implement pagination for listing endpoints to handle large datasets
4. **Caching**: Add caching for frequently accessed exam data
5. **JSON Annotations**: Consider using Jackson annotations to better control serialization

## Testing Guidelines

When testing the refactored functionality, ensure:

1. **Endpoint Testing**: All endpoints return the expected data structure
2. **Performance Testing**: Response times remain consistent with large datasets
3. **Edge Cases**: Test with nested relationships and complex entity graphs
4. **Security**: Ensure that sensitive data is not exposed through the API

## Conclusion

The implemented solution resolves the recursion issue by properly separating entity and DTO conversion logic, moving that responsibility to the controller layer. This creates a cleaner architecture that is more maintainable and performs better.
</file>

<file path="docs/exception-handling.md">
# PharmacyHub Exception Handling

## Overview

This document describes how exceptions and error responses are handled in the PharmacyHub backend application.

## Exception Handling Architecture

The application implements a global exception handling mechanism that ensures consistent error responses across all controllers. Key components include:

### 1. `GlobalExceptionHandler`

A centralized exception handler that captures and processes all exceptions thrown within the application. It maps exceptions to appropriate HTTP status codes and formats error responses consistently.

### 2. Standard Error Response Format

All error responses follow this structure:

```json
{
  "status": 400,
  "errorCode": "ERR_VALIDATION",
  "message": "Validation failed. Please check your input.",
  "timestamp": "2023-07-21T14:30:45",
  "path": "/api/resource",
  "details": {
    "field1": "Error message for field1",
    "field2": "Error message for field2"
  }
}
```

### 3. Custom Exception Types

The application uses custom exception types to represent different error scenarios:

- `BaseException`: Abstract base class for all application exceptions
- `ResourceNotFoundException`: For 404 errors
- `BadRequestException`: For 400 errors
- `ForbiddenException`: For 403 errors
- `ConflictException`: For 409 errors
- `UnauthorizedException`: For 401 errors

### 4. Security Exception Handling

Security exceptions (401, 403) are handled through:

- `CustomAuthenticationEntryPoint`: Handles unauthenticated requests
- `CustomAccessDeniedHandler`: Handles unauthorized access attempts
- Provides detailed logging for security violations

## Best Practices for Exception Handling

1. **Use Custom Exceptions**: When writing service or controller methods, use appropriate custom exceptions to signal specific error conditions.

```java
// Example
if (user == null) {
    throw new ResourceNotFoundException("User", "id", userId);
}

if (!isValidOperation(status)) {
    throw new BadRequestException("Cannot change status from " + currentStatus + " to " + newStatus);
}

if (!hasPermission(user, "EDIT_RESOURCE")) {
    throw new ForbiddenException("resource", "EDIT");
}
```

2. **Include Meaningful Error Messages**: Error messages should be clear, concise, and actionable for the client.

3. **Validate Input Early**: Use Bean Validation and validate input parameters as early as possible.

4. **Log Appropriately**: Sensitive information should not be included in client-facing error messages but should be logged for troubleshooting.

5. **Don't Expose Implementation Details**: Error responses should never expose internal implementation details, stack traces, or sensitive information.

## Handling 403 Forbidden Errors

When a 403 Forbidden error occurs, the system:

1. Logs detailed information about the request, user, and attempted action
2. Returns a standardized error response with appropriate error code
3. Captures diagnostics information for later analysis

### Common Causes of 403 Errors

- User lacks required role or permission
- JWT token is valid but doesn't have sufficient privileges
- Access policy restriction based on time, IP, or other factors
- Cross-tenant access attempt

### Troubleshooting 403 Errors

For developers/admins: Check the security logs (`logs/security.log`) which contain detailed diagnostics about:

- User identity and roles/permissions
- Requested resource and required permission
- Security context details

## Error Logging

All exceptions are logged with appropriate severity levels:

- ERROR: For 5xx errors
- WARN: For 4xx errors
- INFO: For normal operations

Security-related exceptions are logged with additional context to assist in troubleshooting.
</file>

<file path="docs/RBAC-ENHANCEMENTS.md">
# PharmacyHub RBAC System Enhancements

## Overview

This document outlines the enhancements made to the Role-Based Access Control (RBAC) system in the PharmacyHub backend application. These improvements strengthen security, add more granular access control, and improve audit logging capabilities.

## Key Enhancements

### 1. Improved Permission Evaluation

- Enhanced the `PHPermissionEvaluator` to provide more granular permission checking
- Added support for generic permission checks without specific target objects
- Implemented targeted permission evaluation with resource type and operation matching
- Integrated audit logging during permission checks for better traceability

### 2. Enhanced RBAC Service

- Added proper exception handling with specific error codes and messages
- Implemented cache management with appropriate cache evictions
- Added permission inheritance through role hierarchies
- Implemented user permission overrides with both grant and deny capabilities
- Added group-based permission management
- Added methods for querying users by roles, groups, and permissions
- Added comprehensive validation for resource access

### 3. Validation and Error Handling

- Implemented `RBACValidationService` for validating role, permission, and group operations
- Added circular dependency detection in role hierarchies
- Added validation for resource and operation type combinations
- Implemented proper exception handling with specific error codes

### 4. Audit Logging

- Enhanced audit logging with detailed information about security events
- Added user context to audit logs
- Added outcome (SUCCESS/DENIED) to audit logs
- Implemented logging for permission checks, role assignments, and other security-related operations

### 5. User Repository Extensions

- Added methods for finding users by roles and groups
- Added methods for finding users with specific permissions
- Added support for checking permission overrides

### 6. Comprehensive Testing

- Created integration tests for the RBAC system
- Added JSON test fixtures for different access control scenarios
- Implemented tests for role hierarchy, group-based permissions, and permission overrides
- Added dynamic access control tests based on resource attributes

## Implementation Details

### Permission Inheritance

Permissions are inherited through:
1. Direct role assignments
2. Group memberships
3. Role hierarchies
4. Permission overrides

The system computes the effective permissions by:
1. Collecting permissions from directly assigned roles
2. Adding permissions from parent roles in the hierarchy
3. Adding permissions from roles assigned to groups the user belongs to
4. Applying permission overrides (both grants and denials)

### Cache Management

The system uses caching to improve performance:
- `userPermissions`: Caches effective permissions for users
- `userRoles`: Caches all roles assigned to users (directly and through groups)
- `roleHierarchy`: Caches role hierarchies to avoid traversing the tree repeatedly
- `groupRoles`: Caches roles assigned to groups
- `userHasPermission` and `userHasRole`: Caches specific permission and role checks

Cache eviction is managed carefully during operations that modify roles, permissions, or group assignments.

### Security Annotations

The system uses Spring Security's method-level security annotations:
```java
@PreAuthorize("hasPermission('ROLE', 'MANAGE')")
public Role createRole(RoleDTO roleDTO) {
    // Implementation
}
```

### Role Hierarchy

The system supports role hierarchies where parent roles inherit permissions from child roles:
```java
// Example: ADMIN -> PHARMACY_MANAGER -> SENIOR_PHARMACIST -> PHARMACIST
```

A permission granted to a PHARMACIST is automatically available to SENIOR_PHARMACIST, PHARMACY_MANAGER, and ADMIN.

## Usage Examples

### Basic Permission Check
```java
boolean hasAccess = rbacService.validateAccess(userId, "MEDICINE", "READ", medicineId);
```

### Assigning Roles and Groups
```java
rbacService.assignRoleToUser(userId, roleId);
rbacService.assignGroupToUser(userId, groupId);
```

### Permission Overrides
```java
// Grant a specific permission
rbacService.addPermissionOverride(userId, "APPROVE_PRESCRIPTION", true);

// Deny a specific permission
rbacService.addPermissionOverride(userId, "DELETE_MEDICINE", false);
```

### Finding Users with Specific Access
```java
List<User> approvers = rbacService.getUsersByPermission("APPROVE_PRESCRIPTION");
List<User> pharmacists = rbacService.getUsersByRole("PHARMACIST");
```

## Conclusion

These enhancements significantly improve the security posture of the PharmacyHub application by providing:

1. More granular access control
2. Better audit traceability
3. Flexible permission management through roles, groups, and overrides
4. Improved performance through intelligent caching
5. Comprehensive validation of security operations

These changes maintain backward compatibility with existing functionality while adding new capabilities to support more sophisticated access control requirements.
</file>

<file path="docs/README.md">
# PharmacyHub Backend Documentation

Welcome to the PharmacyHub Backend documentation. This documentation provides comprehensive information about the architecture, design patterns, and development guidelines for the PharmacyHub backend application.

## Documentation Structure

### Architecture
- [Core Architecture](./architecture/01-core-architecture.md)
- [Design Patterns](./architecture/02-design-patterns.md)
- [Domain Model](./architecture/03-domain-model.md)
- [Security Implementation](./architecture/04-security.md)
- [Service Layer](./architecture/05-service-layer.md)
- [Development Guidelines](./architecture/06-development-guidelines.md)
- [Testing Strategy](./architecture/07-testing.md)
- [Error Handling](./architecture/08-error-handling.md)
- [API Design](./architecture/09-api-design.md)
- [Performance](./architecture/10-performance.md)
- [Security Checklist](./architecture/11-security-checklist.md)
- [Monitoring and Logging](./architecture/12-monitoring.md)
- [Deployment](./architecture/13-deployment.md)

## Getting Started

1. Review the Core Architecture document first to understand the overall system design
2. Follow the Development Guidelines for consistent code implementation
3. Use the provided patterns and templates for new feature development
4. Ensure compliance with the Security Checklist
5. Follow the Testing Strategy for quality assurance

## Contributing

When contributing to this project:
1. Follow the established architectural patterns
2. Adhere to the coding standards
3. Update documentation as needed
4. Include appropriate tests
5. Submit detailed pull requests

## Quick Links

- Project Repository: [GitHub Repository]
- Issue Tracker: [JIRA/GitHub Issues]
- CI/CD Pipeline: [Jenkins/GitHub Actions]
- Production Environment: [Production URL]
- Staging Environment: [Staging URL]
</file>

<file path="mvnw">
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Maven Start Up Batch script
#
# Required ENV vars:
# ------------------
#   JAVA_HOME - location of a JDK home dir
#
# Optional ENV vars
# -----------------
#   M2_HOME - location of maven2's installed home dir
#   MAVEN_OPTS - parameters passed to the Java VM when running Maven
#     e.g. to debug Maven itself, use
#       set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
#   MAVEN_SKIP_RC - flag to disable loading of mavenrc files
# ----------------------------------------------------------------------------

if [ -z "$MAVEN_SKIP_RC" ] ; then

  if [ -f /usr/local/etc/mavenrc ] ; then
    . /usr/local/etc/mavenrc
  fi

  if [ -f /etc/mavenrc ] ; then
    . /etc/mavenrc
  fi

  if [ -f "$HOME/.mavenrc" ] ; then
    . "$HOME/.mavenrc"
  fi

fi

# OS specific support.  $var _must_ be set to either true or false.
cygwin=false;
darwin=false;
mingw=false
case "`uname`" in
  CYGWIN*) cygwin=true ;;
  MINGW*) mingw=true;;
  Darwin*) darwin=true
    # Use /usr/libexec/java_home if available, otherwise fall back to /Library/Java/Home
    # See https://developer.apple.com/library/mac/qa/qa1170/_index.html
    if [ -z "$JAVA_HOME" ]; then
      if [ -x "/usr/libexec/java_home" ]; then
        export JAVA_HOME="`/usr/libexec/java_home`"
      else
        export JAVA_HOME="/Library/Java/Home"
      fi
    fi
    ;;
esac

if [ -z "$JAVA_HOME" ] ; then
  if [ -r /etc/gentoo-release ] ; then
    JAVA_HOME=`java-config --jre-home`
  fi
fi

if [ -z "$M2_HOME" ] ; then
  ## resolve links - $0 may be a link to maven's home
  PRG="$0"

  # need this for relative symlinks
  while [ -h "$PRG" ] ; do
    ls=`ls -ld "$PRG"`
    link=`expr "$ls" : '.*-> \(.*\)$'`
    if expr "$link" : '/.*' > /dev/null; then
      PRG="$link"
    else
      PRG="`dirname "$PRG"`/$link"
    fi
  done

  saveddir=`pwd`

  M2_HOME=`dirname "$PRG"`/..

  # make it fully qualified
  M2_HOME=`cd "$M2_HOME" && pwd`

  cd "$saveddir"
  # echo Using m2 at $M2_HOME
fi

# For Cygwin, ensure paths are in UNIX format before anything is touched
if $cygwin ; then
  [ -n "$M2_HOME" ] &&
    M2_HOME=`cygpath --unix "$M2_HOME"`
  [ -n "$JAVA_HOME" ] &&
    JAVA_HOME=`cygpath --unix "$JAVA_HOME"`
  [ -n "$CLASSPATH" ] &&
    CLASSPATH=`cygpath --path --unix "$CLASSPATH"`
fi

# For Mingw, ensure paths are in UNIX format before anything is touched
if $mingw ; then
  [ -n "$M2_HOME" ] &&
    M2_HOME="`(cd "$M2_HOME"; pwd)`"
  [ -n "$JAVA_HOME" ] &&
    JAVA_HOME="`(cd "$JAVA_HOME"; pwd)`"
fi

if [ -z "$JAVA_HOME" ]; then
  javaExecutable="`which javac`"
  if [ -n "$javaExecutable" ] && ! [ "`expr \"$javaExecutable\" : '\([^ ]*\)'`" = "no" ]; then
    # readlink(1) is not available as standard on Solaris 10.
    readLink=`which readlink`
    if [ ! `expr "$readLink" : '\([^ ]*\)'` = "no" ]; then
      if $darwin ; then
        javaHome="`dirname \"$javaExecutable\"`"
        javaExecutable="`cd \"$javaHome\" && pwd -P`/javac"
      else
        javaExecutable="`readlink -f \"$javaExecutable\"`"
      fi
      javaHome="`dirname \"$javaExecutable\"`"
      javaHome=`expr "$javaHome" : '\(.*\)/bin'`
      JAVA_HOME="$javaHome"
      export JAVA_HOME
    fi
  fi
fi

if [ -z "$JAVACMD" ] ; then
  if [ -n "$JAVA_HOME"  ] ; then
    if [ -x "$JAVA_HOME/jre/sh/java" ] ; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="$JAVA_HOME/jre/sh/java"
    else
      JAVACMD="$JAVA_HOME/bin/java"
    fi
  else
    JAVACMD="`\\unset -f command; \\command -v java`"
  fi
fi

if [ ! -x "$JAVACMD" ] ; then
  echo "Error: JAVA_HOME is not defined correctly." >&2
  echo "  We cannot execute $JAVACMD" >&2
  exit 1
fi

if [ -z "$JAVA_HOME" ] ; then
  echo "Warning: JAVA_HOME environment variable is not set."
fi

CLASSWORLDS_LAUNCHER=org.codehaus.plexus.classworlds.launcher.Launcher

# traverses directory structure from process work directory to filesystem root
# first directory with .mvn subdirectory is considered project base directory
find_maven_basedir() {

  if [ -z "$1" ]
  then
    echo "Path not specified to find_maven_basedir"
    return 1
  fi

  basedir="$1"
  wdir="$1"
  while [ "$wdir" != '/' ] ; do
    if [ -d "$wdir"/.mvn ] ; then
      basedir=$wdir
      break
    fi
    # workaround for JBEAP-8937 (on Solaris 10/Sparc)
    if [ -d "${wdir}" ]; then
      wdir=`cd "$wdir/.."; pwd`
    fi
    # end of workaround
  done
  echo "${basedir}"
}

# concatenates all lines of a file
concat_lines() {
  if [ -f "$1" ]; then
    echo "$(tr -s '\n' ' ' < "$1")"
  fi
}

BASE_DIR=`find_maven_basedir "$(pwd)"`
if [ -z "$BASE_DIR" ]; then
  exit 1;
fi

##########################################################################################
# Extension to allow automatically downloading the maven-wrapper.jar from Maven-central
# This allows using the maven wrapper in projects that prohibit checking in binary data.
##########################################################################################
if [ -r "$BASE_DIR/.mvn/wrapper/maven-wrapper.jar" ]; then
    if [ "$MVNW_VERBOSE" = true ]; then
      echo "Found .mvn/wrapper/maven-wrapper.jar"
    fi
else
    if [ "$MVNW_VERBOSE" = true ]; then
      echo "Couldn't find .mvn/wrapper/maven-wrapper.jar, downloading it ..."
    fi
    if [ -n "$MVNW_REPOURL" ]; then
      jarUrl="$MVNW_REPOURL/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"
    else
      jarUrl="https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"
    fi
    while IFS="=" read key value; do
      case "$key" in (wrapperUrl) jarUrl="$value"; break ;;
      esac
    done < "$BASE_DIR/.mvn/wrapper/maven-wrapper.properties"
    if [ "$MVNW_VERBOSE" = true ]; then
      echo "Downloading from: $jarUrl"
    fi
    wrapperJarPath="$BASE_DIR/.mvn/wrapper/maven-wrapper.jar"
    if $cygwin; then
      wrapperJarPath=`cygpath --path --windows "$wrapperJarPath"`
    fi

    if command -v wget > /dev/null; then
        if [ "$MVNW_VERBOSE" = true ]; then
          echo "Found wget ... using wget"
        fi
        if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then
            wget "$jarUrl" -O "$wrapperJarPath" || rm -f "$wrapperJarPath"
        else
            wget --http-user=$MVNW_USERNAME --http-password=$MVNW_PASSWORD "$jarUrl" -O "$wrapperJarPath" || rm -f "$wrapperJarPath"
        fi
    elif command -v curl > /dev/null; then
        if [ "$MVNW_VERBOSE" = true ]; then
          echo "Found curl ... using curl"
        fi
        if [ -z "$MVNW_USERNAME" ] || [ -z "$MVNW_PASSWORD" ]; then
            curl -o "$wrapperJarPath" "$jarUrl" -f
        else
            curl --user $MVNW_USERNAME:$MVNW_PASSWORD -o "$wrapperJarPath" "$jarUrl" -f
        fi

    else
        if [ "$MVNW_VERBOSE" = true ]; then
          echo "Falling back to using Java to download"
        fi
        javaClass="$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.java"
        # For Cygwin, switch paths to Windows format before running javac
        if $cygwin; then
          javaClass=`cygpath --path --windows "$javaClass"`
        fi
        if [ -e "$javaClass" ]; then
            if [ ! -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then
                if [ "$MVNW_VERBOSE" = true ]; then
                  echo " - Compiling MavenWrapperDownloader.java ..."
                fi
                # Compiling the Java class
                ("$JAVA_HOME/bin/javac" "$javaClass")
            fi
            if [ -e "$BASE_DIR/.mvn/wrapper/MavenWrapperDownloader.class" ]; then
                # Running the downloader
                if [ "$MVNW_VERBOSE" = true ]; then
                  echo " - Running MavenWrapperDownloader.java ..."
                fi
                ("$JAVA_HOME/bin/java" -cp .mvn/wrapper MavenWrapperDownloader "$MAVEN_PROJECTBASEDIR")
            fi
        fi
    fi
fi
##########################################################################################
# End of extension
##########################################################################################

export MAVEN_PROJECTBASEDIR=${MAVEN_BASEDIR:-"$BASE_DIR"}
if [ "$MVNW_VERBOSE" = true ]; then
  echo $MAVEN_PROJECTBASEDIR
fi
MAVEN_OPTS="$(concat_lines "$MAVEN_PROJECTBASEDIR/.mvn/jvm.config") $MAVEN_OPTS"

# For Cygwin, switch paths to Windows format before running java
if $cygwin; then
  [ -n "$M2_HOME" ] &&
    M2_HOME=`cygpath --path --windows "$M2_HOME"`
  [ -n "$JAVA_HOME" ] &&
    JAVA_HOME=`cygpath --path --windows "$JAVA_HOME"`
  [ -n "$CLASSPATH" ] &&
    CLASSPATH=`cygpath --path --windows "$CLASSPATH"`
  [ -n "$MAVEN_PROJECTBASEDIR" ] &&
    MAVEN_PROJECTBASEDIR=`cygpath --path --windows "$MAVEN_PROJECTBASEDIR"`
fi

# Provide a "standardized" way to retrieve the CLI args that will
# work with both Windows and non-Windows executions.
MAVEN_CMD_LINE_ARGS="$MAVEN_CONFIG $@"
export MAVEN_CMD_LINE_ARGS

WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain

exec "$JAVACMD" \
  $MAVEN_OPTS \
  $MAVEN_DEBUG_OPTS \
  -classpath "$MAVEN_PROJECTBASEDIR/.mvn/wrapper/maven-wrapper.jar" \
  "-Dmaven.home=${M2_HOME}" \
  "-Dmaven.multiModuleProjectDirectory=${MAVEN_PROJECTBASEDIR}" \
  ${WRAPPER_LAUNCHER} $MAVEN_CONFIG "$@"
</file>

<file path="mvnw.cmd">
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    https://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Maven Start Up Batch script
@REM
@REM Required ENV vars:
@REM JAVA_HOME - location of a JDK home dir
@REM
@REM Optional ENV vars
@REM M2_HOME - location of maven2's installed home dir
@REM MAVEN_BATCH_ECHO - set to 'on' to enable the echoing of the batch commands
@REM MAVEN_BATCH_PAUSE - set to 'on' to wait for a keystroke before ending
@REM MAVEN_OPTS - parameters passed to the Java VM when running Maven
@REM     e.g. to debug Maven itself, use
@REM set MAVEN_OPTS=-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=8000
@REM MAVEN_SKIP_RC - flag to disable loading of mavenrc files
@REM ----------------------------------------------------------------------------

@REM Begin all REM lines with '@' in case MAVEN_BATCH_ECHO is 'on'
@echo off
@REM set title of command window
title %0
@REM enable echoing by setting MAVEN_BATCH_ECHO to 'on'
@if "%MAVEN_BATCH_ECHO%" == "on"  echo %MAVEN_BATCH_ECHO%

@REM set %HOME% to equivalent of $HOME
if "%HOME%" == "" (set "HOME=%HOMEDRIVE%%HOMEPATH%")

@REM Execute a user defined script before this one
if not "%MAVEN_SKIP_RC%" == "" goto skipRcPre
@REM check for pre script, once with legacy .bat ending and once with .cmd ending
if exist "%USERPROFILE%\mavenrc_pre.bat" call "%USERPROFILE%\mavenrc_pre.bat" %*
if exist "%USERPROFILE%\mavenrc_pre.cmd" call "%USERPROFILE%\mavenrc_pre.cmd" %*
:skipRcPre

@setlocal

set ERROR_CODE=0

@REM To isolate internal variables from possible post scripts, we use another setlocal
@setlocal

@REM ==== START VALIDATION ====
if not "%JAVA_HOME%" == "" goto OkJHome

echo.
echo Error: JAVA_HOME not found in your environment. >&2
echo Please set the JAVA_HOME variable in your environment to match the >&2
echo location of your Java installation. >&2
echo.
goto error

:OkJHome
if exist "%JAVA_HOME%\bin\java.exe" goto init

echo.
echo Error: JAVA_HOME is set to an invalid directory. >&2
echo JAVA_HOME = "%JAVA_HOME%" >&2
echo Please set the JAVA_HOME variable in your environment to match the >&2
echo location of your Java installation. >&2
echo.
goto error

@REM ==== END VALIDATION ====

:init

@REM Find the project base dir, i.e. the directory that contains the folder ".mvn".
@REM Fallback to current working directory if not found.

set MAVEN_PROJECTBASEDIR=%MAVEN_BASEDIR%
IF NOT "%MAVEN_PROJECTBASEDIR%"=="" goto endDetectBaseDir

set EXEC_DIR=%CD%
set WDIR=%EXEC_DIR%
:findBaseDir
IF EXIST "%WDIR%"\.mvn goto baseDirFound
cd ..
IF "%WDIR%"=="%CD%" goto baseDirNotFound
set WDIR=%CD%
goto findBaseDir

:baseDirFound
set MAVEN_PROJECTBASEDIR=%WDIR%
cd "%EXEC_DIR%"
goto endDetectBaseDir

:baseDirNotFound
set MAVEN_PROJECTBASEDIR=%EXEC_DIR%
cd "%EXEC_DIR%"

:endDetectBaseDir

IF NOT EXIST "%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config" goto endReadAdditionalConfig

@setlocal EnableExtensions EnableDelayedExpansion
for /F "usebackq delims=" %%a in ("%MAVEN_PROJECTBASEDIR%\.mvn\jvm.config") do set JVM_CONFIG_MAVEN_PROPS=!JVM_CONFIG_MAVEN_PROPS! %%a
@endlocal & set JVM_CONFIG_MAVEN_PROPS=%JVM_CONFIG_MAVEN_PROPS%

:endReadAdditionalConfig

SET MAVEN_JAVA_EXE="%JAVA_HOME%\bin\java.exe"
set WRAPPER_JAR="%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.jar"
set WRAPPER_LAUNCHER=org.apache.maven.wrapper.MavenWrapperMain

set DOWNLOAD_URL="https://repo.maven.apache.org/maven2/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"

FOR /F "usebackq tokens=1,2 delims==" %%A IN ("%MAVEN_PROJECTBASEDIR%\.mvn\wrapper\maven-wrapper.properties") DO (
    IF "%%A"=="wrapperUrl" SET DOWNLOAD_URL=%%B
)

@REM Extension to allow automatically downloading the maven-wrapper.jar from Maven-central
@REM This allows using the maven wrapper in projects that prohibit checking in binary data.
if exist %WRAPPER_JAR% (
    if "%MVNW_VERBOSE%" == "true" (
        echo Found %WRAPPER_JAR%
    )
) else (
    if not "%MVNW_REPOURL%" == "" (
        SET DOWNLOAD_URL="%MVNW_REPOURL%/org/apache/maven/wrapper/maven-wrapper/3.1.0/maven-wrapper-3.1.0.jar"
    )
    if "%MVNW_VERBOSE%" == "true" (
        echo Couldn't find %WRAPPER_JAR%, downloading it ...
        echo Downloading from: %DOWNLOAD_URL%
    )

    powershell -Command "&{"^
		"$webclient = new-object System.Net.WebClient;"^
		"if (-not ([string]::IsNullOrEmpty('%MVNW_USERNAME%') -and [string]::IsNullOrEmpty('%MVNW_PASSWORD%'))) {"^
		"$webclient.Credentials = new-object System.Net.NetworkCredential('%MVNW_USERNAME%', '%MVNW_PASSWORD%');"^
		"}"^
		"[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12; $webclient.DownloadFile('%DOWNLOAD_URL%', '%WRAPPER_JAR%')"^
		"}"
    if "%MVNW_VERBOSE%" == "true" (
        echo Finished downloading %WRAPPER_JAR%
    )
)
@REM End of extension

@REM Provide a "standardized" way to retrieve the CLI args that will
@REM work with both Windows and non-Windows executions.
set MAVEN_CMD_LINE_ARGS=%*

%MAVEN_JAVA_EXE% ^
  %JVM_CONFIG_MAVEN_PROPS% ^
  %MAVEN_OPTS% ^
  %MAVEN_DEBUG_OPTS% ^
  -classpath %WRAPPER_JAR% ^
  "-Dmaven.multiModuleProjectDirectory=%MAVEN_PROJECTBASEDIR%" ^
  %WRAPPER_LAUNCHER% %MAVEN_CONFIG% %*
if ERRORLEVEL 1 goto error
goto end

:error
set ERROR_CODE=1

:end
@endlocal & set ERROR_CODE=%ERROR_CODE%

if not "%MAVEN_SKIP_RC%"=="" goto skipRcPost
@REM check for post script, once with legacy .bat ending and once with .cmd ending
if exist "%USERPROFILE%\mavenrc_post.bat" call "%USERPROFILE%\mavenrc_post.bat"
if exist "%USERPROFILE%\mavenrc_post.cmd" call "%USERPROFILE%\mavenrc_post.cmd"
:skipRcPost

@REM pause the script if MAVEN_BATCH_PAUSE is set to 'on'
if "%MAVEN_BATCH_PAUSE%"=="on" pause

if "%MAVEN_TERMINATE_CMD%"=="on" exit %ERROR_CODE%

cmd /C exit /B %ERROR_CODE%
</file>

<file path="pom.xml">
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
  <modelVersion>4.0.0</modelVersion>
  <parent>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-parent</artifactId>
    <version>3.1.5</version>
    <relativePath/> <!-- lookup parent from repository -->
  </parent>
  <groupId>com.pharmacy.hub</groupId>
  <artifactId>pharmacy-hub</artifactId>
  <version>0.0.1-SNAPSHOT</version>
  <name>PharmacyHub</name>
  <description>Pharmacy Hub</description>
  <properties>
    <java.version>17</java.version>
    <flyway.version>9.16.3</flyway.version>
  </properties>
  <dependencies>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-mail</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.security</groupId>
      <artifactId>spring-security-test</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-data-jpa</artifactId>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>
    <dependency>
      <groupId>org.postgresql</groupId>
      <artifactId>postgresql</artifactId>
      <version>42.5.0</version>
    </dependency>
    <dependency>
      <groupId>org.projectlombok</groupId>
      <artifactId>lombok</artifactId>
      <optional>true</optional>
    </dependency>
    <dependency>
      <groupId>org.flywaydb</groupId>
      <artifactId>flyway-core</artifactId>
      <version>${flyway.version}</version>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <!-- JWT Dependencies -->
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-api</artifactId>
      <version>0.11.5</version>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-impl</artifactId>
      <version>0.11.5</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>io.jsonwebtoken</groupId>
      <artifactId>jjwt-jackson</artifactId>
      <version>0.11.5</version>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.modelmapper</groupId>
      <artifactId>modelmapper</artifactId>
      <version>3.1.1</version>
    </dependency>
    <dependency>
      <groupId>org.springdoc</groupId>
      <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
      <version>2.0.0</version>
    </dependency>
    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-tomcat</artifactId>
      <scope>provided</scope>
    </dependency>
    <dependency>
      <groupId>com.google.apis</groupId>
      <artifactId>google-api-services-people</artifactId>
      <version>v1-rev20210903-1.32.1</version>
    </dependency>
    <dependency>
      <groupId>com.google.auth</groupId>
      <artifactId>google-auth-library-oauth2-http</artifactId>
      <version>1.3.0</version>
    </dependency>
    <dependency>
      <groupId>com.google.api-client</groupId>
      <artifactId>google-api-client-jackson2</artifactId>
      <version>1.28.1</version>
    </dependency>
    
    <!-- Database dependencies -->
    <dependency>
      <groupId>com.h2database</groupId>
      <artifactId>h2</artifactId>
      <scope>runtime</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-api</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-core</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.mockito</groupId>
      <artifactId>mockito-junit-jupiter</artifactId>
      <scope>test</scope>
    </dependency>
    <dependency>
      <groupId>org.hamcrest</groupId>
      <artifactId>hamcrest</artifactId>
      <scope>test</scope>
    </dependency>
  </dependencies>

  <build>
    <finalName>pharmacy-hub</finalName>
    <plugins>
      <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
          <excludes>
            <exclude>
              <groupId>org.projectlombok</groupId>
              <artifactId>lombok</artifactId>
            </exclude>
          </excludes>
        </configuration>
      </plugin>
      
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-compiler-plugin</artifactId>
        <configuration>
          <source>17</source>
          <target>17</target>
          <annotationProcessorPaths>
            <path>
              <groupId>org.projectlombok</groupId>
              <artifactId>lombok</artifactId>
              <version>${lombok.version}</version>
            </path>
          </annotationProcessorPaths>
        </configuration>
      </plugin>
      
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-surefire-plugin</artifactId>
        <configuration>
          <includes>
            <include>**/*Test.java</include>
          </includes>
        </configuration>
      </plugin>
      
      <plugin>
        <groupId>org.jacoco</groupId>
        <artifactId>jacoco-maven-plugin</artifactId>
        <version>0.8.10</version>
        <executions>
          <execution>
            <goals>
              <goal>prepare-agent</goal>
            </goals>
          </execution>
          <execution>
            <id>report</id>
            <phase>test</phase>
            <goals>
              <goal>report</goal>
            </goals>
          </execution>
        </executions>
      </plugin>
    </plugins>
  </build>

</project>
</file>

<file path="RBAC-CHANGES.md">
# Enhanced Role-Based Access Control (RBAC) Implementation

## Overview
This document details the implementation of an enhanced Role-Based Access Control (RBAC) system in the PharmacyHub backend application. The system includes user roles, permissions, groups, and audit logging capabilities.

## Major Changes

### 1. Dependency Updates
- Removed Keycloak and Redis dependencies
- Added Flyway for database migrations
- Retained core Spring Security and JWT dependencies

### 2. Security Model

#### Entities
- **User**: Extended with groups and enhanced role relationships
- **Role**: Enhanced with permissions and role hierarchy
- **Permission**: New entity for granular access control
- **Group**: New entity for role grouping
- **AuditLog**: New entity for security event tracking

#### Database Schema Changes
```sql
- permissions (id, name, description)
- groups (id, name, description)
- role_permissions (role_id, permission_id)
- role_hierarchy (parent_role_id, child_role_id)
- group_roles (group_id, role_id)
- user_groups (user_id, group_id)
- audit_logs (id, action, details, user_id, timestamp, etc.)
```

### 3. Security Configuration

#### JWT Authentication
```java
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {
    // JWT Filter chain configuration
    // Method security with custom permission evaluator
    // CORS configuration
    // Authentication manager setup
}
```

#### Permission Evaluation
```java
@PreAuthorize("hasRole('ADMIN') or hasPermission(null, 'VIEW_PHARMACIST')")
public PharmacistDTO findUser(long id) {
    // Method implementation
}
```

### 4. Available Permissions
```java
public enum PermissionEnum {
    CREATE_PHARMACIST,
    UPDATE_PHARMACIST,
    VIEW_PHARMACIST,
    VIEW_ALL_PHARMACISTS,
    MANAGE_CONNECTIONS,
    VIEW_CONNECTIONS,
    VIEW_ALL_CONNECTIONS,
    // ... more permissions
}
```

### 5. Database Migration
Flyway migrations are set up to manage database schema changes:
- V1__init_schema.sql: Baseline schema
- V2__add_rbac_tables.sql: RBAC-related tables

### 6. Default Role Permissions

#### Admin Role
- Has access to all permissions
- Can manage roles, permissions, and groups
- Full access to audit logs

#### Pharmacist Role
- VIEW_PHARMACIST
- UPDATE_PHARMACIST
- MANAGE_CONNECTIONS
- VIEW_CONNECTIONS

#### Proprietor Role
- VIEW_PHARMACIST
- VIEW_ALL_PHARMACISTS
- MANAGE_CONNECTIONS
- VIEW_CONNECTIONS
- VIEW_ALL_CONNECTIONS

## Configuration Files

### application.yml
```yaml
spring:
  datasource:
    url: ${MYSQL_URL:jdbc:mysql://localhost:3306/pharmacyhub}
    username: ${MYSQL_USER:root}
    password: ${MYSQL_PASSWORD:password}
  jpa:
    hibernate:
      ddl-auto: validate
  flyway:
    enabled: true
    locations: classpath:db/migration
    baseline-on-migrate: true

jwt:
  secret: ${JWT_SECRET:your-secret-key}
  expiration: ${JWT_EXPIRATION:18000}
```

## Services

### PermissionService
- Manages permission assignments
- Checks user permissions
- Handles permission inheritance

### GroupService
- Manages group creation and updates
- Handles role assignments to groups
- Manages user group memberships

### AuditService
- Logs security events
- Tracks user actions
- Provides audit trail capabilities

## Usage Examples

### Controller Level Security
```java
@RestController
@RequestMapping("/api/v1/pharmacists")
public class PharmacistController {
    
    @PreAuthorize("hasRole('ADMIN') or hasPermission(null, 'VIEW_PHARMACIST')")
    @GetMapping("/{id}")
    public ResponseEntity<PharmacistDTO> getPharmacist(@PathVariable Long id) {
        return ResponseEntity.ok(pharmacistService.findUser(id));
    }
}
```

### Service Level Security
```java
@Service
public class PharmacistService {
    
    @PreAuthorize("hasRole('ADMIN') or hasPermission(null, 'CREATE_PHARMACIST')")
    public PharmacistDTO saveUser(PharmacistDTO dto) {
        // Implementation
    }
}
```

## Security Flow

1. **Authentication**:
   - User submits credentials
   - JWT token generated with roles and permissions
   - Token includes user details and authorities

2. **Authorization**:
   - JWT token validated on each request
   - Permissions checked at method/endpoint level
   - Custom permission evaluator handles complex checks

3. **Audit Logging**:
   - Security events logged to database
   - User actions tracked with timestamps
   - IP and user agent information recorded

## Maintenance

### Adding New Permissions
1. Add to PermissionEnum
2. Create migration script if needed
3. Update role assignments in PermissionSeeder
4. Add security annotations where needed

### Managing Roles
1. Use admin interface to assign permissions
2. Update role hierarchy if needed
3. Manage group assignments

## Future Enhancements

1. **Cache Layer**:
   - Add caching for frequently accessed permissions
   - Cache user authorities to reduce database calls

2. **API Extensions**:
   - Bulk permission management
   - Role hierarchy visualization
   - Advanced audit log filtering

3. **Security Hardening**:
   - Rate limiting
   - IP-based restrictions
   - Enhanced password policies
</file>

<file path="RBAC-TEST-FIXES.md">
# Role-Based Access Control (RBAC) System Fixes

This document outlines the changes made to fix test failures in the RBAC system.

## 1. Role Framework Fixes

### Issues:
- Role nullability failures
- Inconsistent role entity types
- Role repository method mismatches
- Missing role initialization logic

### Solutions:
- Updated the `Role` entity to properly handle null values
- Enhanced the `getName()` method to handle null RoleEnum
- Fixed the `getPermissions()` and `getChildRoles()` methods to return empty sets instead of null
- Improved `RolesRepository` to work with RoleEnum properly
- Created a standardized test role repository
- Updated `TestDataBuilder` to ensure proper role creation with all required fields
- Enhanced `RoleEnum` to better handle string conversions

## 2. Authentication Layer Fixes

### Issues:
- Authentication failures (401)
- Missing security context in tests
- Improper test security configuration

### Solutions:
- Updated `TestSecurityConfig` to better support authentication
- Created a test security utility class for managing security context
- Fixed `RBACServiceIntegrationTest` to use proper security context
- Added proper test security context factory for `WithMockUserPrincipal` annotation

## 3. RBAC System Fixes

### Issues:
- Permission mapping problems
- Missing role hierarchies
- Improper validation logic

### Solutions:
- Enhanced `RoleInitializer` to create proper defaults
- Improved `RoleHierarchyInitializer` to establish correct role relationships
- Enhanced `RBACValidationService` to better validate operations
- Added validation for role hierarchy management
- Added circular dependency detection

## 4. Type Management Fixes

### Issues:
- Incompatible security principal types
- User entity conversion problems
- Missing equals and hashCode implementations

### Solutions:
- Updated `ResourceType` enum with all needed types
- Improved `Permission` class with better null handling and equals/hashCode
- Enhanced `Group` class with proper null handling and equals/hashCode
- Fixed `TestSecurityUtils` to create consistent security contexts

## Conclusion

These changes should resolve the test failures by addressing their root causes:

1. Role nullability is now properly handled at all levels
2. Authentication flows in tests are now consistent
3. The RBAC system has proper validation and initialization
4. Type safety is ensured across all relevant classes

All changes were made with backward compatibility in mind, ensuring existing functionality continues to work while fixing the test issues.
</file>

<file path="README.md">
# PharmacyHub-Springboot
</file>

<file path="src/main/java/com/pharmacyhub/config/CorsConfig.java">
package com.pharmacyhub.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.web.filter.CorsFilter;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("*")
                .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS")
                .allowedHeaders("*")
                .maxAge(3600);
    }

    @Bean
    public CorsFilter corsFilter() {
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        CorsConfiguration config = new CorsConfiguration();
        
        // Allow all origins
        config.addAllowedOrigin("*");
        
        // Allow all headers
        config.addAllowedHeader("*");
        
        // Allow all methods (GET, POST, etc.)
        config.addAllowedMethod("*");
        
        // Allow cookies
        config.setAllowCredentials(false);
        
        // Cache preflight requests for 1 hour (3600 seconds)
        config.setMaxAge(3600L);
        
        source.registerCorsConfiguration("/**", config);
        return new CorsFilter(source);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/config/ExamMapperConfig.java">
package com.pharmacyhub.config;

import com.pharmacyhub.domain.entity.Exam;
import com.pharmacyhub.domain.entity.Option;
import com.pharmacyhub.domain.entity.Question;
import com.pharmacyhub.dto.request.ExamRequestDTO;
import com.pharmacyhub.dto.response.ExamResponseDTO;
import com.pharmacyhub.utils.EntityMapper;
import org.springframework.stereotype.Component;
import org.modelmapper.Converter;
import org.modelmapper.PropertyMap;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Configuration;

import jakarta.annotation.PostConstruct;
import java.util.ArrayList;

/**
 * Configuration for entity-DTO mapping for Exam-related entities
 * Enhances the standard ModelMapper with custom mappings for complex scenarios
 */
@Configuration
public class ExamMapperConfig {

    private final EntityMapper entityMapper;

    @Autowired
    public ExamMapperConfig(EntityMapper entityMapper) {
        this.entityMapper = entityMapper;
    }

    @PostConstruct
    public void configure() {
        configureExamToResponseMapping();
        configureRequestToExamMapping();
    }

    /**
     * Configure mapping from Exam entity to ExamResponseDTO
     */
    private void configureExamToResponseMapping() {
        entityMapper.getModelMapper().addMappings(new PropertyMap<Exam, ExamResponseDTO>() {
            @Override
            protected void configure() {
                map().setId(source.getId());
                map().setTitle(source.getTitle());
                map().setDescription(source.getDescription());
                map().setDuration(source.getDuration());
                map().setTotalMarks(source.getTotalMarks());
                map().setPassingMarks(source.getPassingMarks());
                map().setStatus(source.getStatus());
            }
        });

        entityMapper.getModelMapper().addMappings(new PropertyMap<Question, ExamResponseDTO.QuestionDTO>() {
            @Override
            protected void configure() {
                map().setId(source.getId());
                map().setQuestionNumber(source.getQuestionNumber());
                map().setQuestionText(source.getQuestionText());
                map().setCorrectAnswer(source.getCorrectAnswer());
                map().setExplanation(source.getExplanation());
                map().setMarks(source.getMarks());
            }
        });

        entityMapper.getModelMapper().addMappings(new PropertyMap<Option, ExamResponseDTO.OptionDTO>() {
            @Override
            protected void configure() {
                map().setId(source.getId());
                map().setOptionKey(source.getLabel());
                map().setOptionText(source.getText());
                map().setIsCorrect(source.getIsCorrect());
            }
        });
    }

    /**
     * Configure mapping from ExamRequestDTO to Exam entity
     */
    private void configureRequestToExamMapping() {
        // Create a converter that handles the complex relationship between questions and exams
        Converter<ExamRequestDTO, Exam> examConverter = context -> {
            ExamRequestDTO source = context.getSource();
            Exam destination = context.getDestination();
            
            destination.setId(source.getId());
            destination.setTitle(source.getTitle());
            destination.setDescription(source.getDescription());
            destination.setDuration(source.getDuration());
            destination.setTotalMarks(source.getTotalMarks());
            destination.setPassingMarks(source.getPassingMarks());
            destination.setStatus(source.getStatus());
            
            if (destination.getQuestions() == null) {
                destination.setQuestions(new ArrayList<>());
            } else {
                destination.getQuestions().clear();
            }
            
            // Map questions
            if (source.getQuestions() != null) {
                for (ExamRequestDTO.QuestionDTO questionDTO : source.getQuestions()) {
                    Question question = new Question();
                    question.setId(questionDTO.getId());
                    question.setQuestionNumber(questionDTO.getQuestionNumber());
                    question.setQuestionText(questionDTO.getQuestionText());
                    question.setCorrectAnswer(questionDTO.getCorrectAnswer());
                    question.setExplanation(questionDTO.getExplanation());
                    question.setMarks(questionDTO.getMarks());
                    
                    // Set bidirectional relationship
                    question.setExam(destination);
                    
                    // Map options
                    if (questionDTO.getOptions() != null) {
                        for (ExamRequestDTO.OptionDTO optionDTO : questionDTO.getOptions()) {
                            Option option = new Option();
                            option.setId(optionDTO.getId());
                            option.setLabel(optionDTO.getOptionKey());
                            option.setText(optionDTO.getOptionText());
                            option.setIsCorrect(optionDTO.getIsCorrect());
                            
                            // Set bidirectional relationship
                            option.setQuestion(question);
                            question.addOption(option);
                        }
                    }
                    
                    destination.addQuestion(question);
                }
            }
            
            return destination;
        };
        
        entityMapper.getModelMapper().createTypeMap(ExamRequestDTO.class, Exam.class)
                .setConverter(examConverter);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/config/GlobalExceptionHandler.java">
package com.pharmacyhub.config;

import com.pharmacyhub.constants.ErrorConstants;
import com.pharmacyhub.dto.response.ApiErrorResponse;
import com.pharmacyhub.exception.BadRequestException;
import com.pharmacyhub.exception.BaseException;
import com.pharmacyhub.exception.ConflictException;
import com.pharmacyhub.exception.ForbiddenException;
import com.pharmacyhub.exception.ResourceNotFoundException;
import com.pharmacyhub.exception.UnauthorizedException;
import com.pharmacyhub.utils.LogUtils;
import jakarta.persistence.EntityNotFoundException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.ConstraintViolationException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.dao.DataIntegrityViolationException;
import org.springframework.dao.OptimisticLockingFailureException;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.http.converter.HttpMessageNotReadableException;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.security.authentication.AccountExpiredException;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.LockedException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.validation.FieldError;
import org.springframework.web.HttpMediaTypeNotSupportedException;
import org.springframework.web.HttpRequestMethodNotSupportedException;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.MissingServletRequestParameterException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.ServletWebRequest;
import org.springframework.web.context.request.WebRequest;
import org.springframework.web.method.annotation.MethodArgumentTypeMismatchException;
import org.springframework.web.multipart.MaxUploadSizeExceededException;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.web.servlet.NoHandlerFoundException;

import java.util.HashMap;
import java.util.Map;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Global exception handler for the application
 * Provides consistent error responses across all controllers
 */
@RestControllerAdvice
@Slf4j
public class GlobalExceptionHandler {
    
    /**
     * Extract the request path from the web request
     */
    private String getRequestPath(WebRequest request) {
        if (request instanceof ServletWebRequest) {
            return ((ServletWebRequest) request).getRequest().getRequestURI();
        }
        return null;
    }
    
    /**
     * Handle application-specific base exceptions
     */
    @ExceptionHandler(BaseException.class)
    public ResponseEntity<ApiErrorResponse> handleBaseException(
            BaseException ex, HttpServletRequest request) {
        
        LogUtils.logException(log, request, ex);
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(ex.getStatus().value())
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(ex.getStatus()).body(errorResponse);
    }
    
    /**
     * Handle resource not found exception
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ApiErrorResponse> handleResourceNotFoundException(
            ResourceNotFoundException ex, HttpServletRequest request) {
        
        LogUtils.logException(log, request, ex);
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.NOT_FOUND.value())
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }
    
    /**
     * Handle bad request exception
     */
    @ExceptionHandler(BadRequestException.class)
    public ResponseEntity<ApiErrorResponse> handleBadRequestException(
            BadRequestException ex, HttpServletRequest request) {
        
        LogUtils.logException(log, request, ex);
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * Handle unauthorized exception
     */
    @ExceptionHandler(UnauthorizedException.class)
    public ResponseEntity<ApiErrorResponse> handleUnauthorizedException(
            UnauthorizedException ex, HttpServletRequest request) {
        
        LogUtils.logException(log, request, ex);
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
    }
    
    /**
     * Handle forbidden exception
     */
    @ExceptionHandler(ForbiddenException.class)
    public ResponseEntity<ApiErrorResponse> handleForbiddenException(
            ForbiddenException ex, HttpServletRequest request) {
        
        // Log detailed information about the 403 error
        LogUtils.logAccessDenied(log, request, ex.getMessage());
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.FORBIDDEN.value())
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
    }
    
    /**
     * Handle conflict exception
     */
    @ExceptionHandler(ConflictException.class)
    public ResponseEntity<ApiErrorResponse> handleConflictException(
            ConflictException ex, HttpServletRequest request) {
        
        LogUtils.logException(log, request, ex);
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.CONFLICT.value())
                .errorCode(ex.getErrorCode())
                .message(ex.getMessage())
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
    }
    
    /**
     * Handle validation exceptions from @Valid annotations
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ApiErrorResponse> handleValidationExceptions(
            MethodArgumentNotValidException ex, HttpServletRequest request) {
        
        Map<String, String> validationErrors = ex.getBindingResult()
                .getFieldErrors()
                .stream()
                .collect(Collectors.toMap(
                        FieldError::getField,
                        error -> Objects.requireNonNullElse(error.getDefaultMessage(), "Invalid value")
                ));
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .errorCode(ErrorConstants.CODE_VALIDATION)
                .message(ErrorConstants.VALIDATION_ERROR)
                .path(request.getRequestURI())
                .build();
        
        errorResponse.addDetail("validationErrors", validationErrors);
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * Handle constraint violation exceptions from Bean Validation
     */
    @ExceptionHandler(ConstraintViolationException.class)
    public ResponseEntity<ApiErrorResponse> handleConstraintViolation(
            ConstraintViolationException ex, HttpServletRequest request) {
        
        Map<String, String> validationErrors = ex.getConstraintViolations()
                .stream()
                .collect(Collectors.toMap(
                        violation -> violation.getPropertyPath().toString(),
                        violation -> violation.getMessage()
                ));
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .errorCode(ErrorConstants.CODE_VALIDATION)
                .message(ErrorConstants.VALIDATION_ERROR)
                .path(request.getRequestURI())
                .build();
        
        errorResponse.addDetail("validationErrors", validationErrors);
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * Handle missing request parameters
     */
    @ExceptionHandler(MissingServletRequestParameterException.class)
    public ResponseEntity<ApiErrorResponse> handleMissingParams(
            MissingServletRequestParameterException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .errorCode(ErrorConstants.CODE_VALIDATION)
                .message("Missing required parameter: " + ex.getParameterName())
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * Handle request body parsing errors
     */
    @ExceptionHandler(HttpMessageNotReadableException.class)
    public ResponseEntity<ApiErrorResponse> handleMessageNotReadable(
            HttpMessageNotReadableException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .errorCode(ErrorConstants.CODE_VALIDATION)
                .message("Malformed JSON request")
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * Handle entity not found exceptions
     */
    @ExceptionHandler(EntityNotFoundException.class)
    public ResponseEntity<ApiErrorResponse> handleEntityNotFound(
            EntityNotFoundException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.NOT_FOUND.value())
                .errorCode(ErrorConstants.CODE_NOT_FOUND)
                .message(Objects.requireNonNullElse(ex.getMessage(), ErrorConstants.RESOURCE_NOT_FOUND))
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }
    
    /**
     * Handle 404 errors for non-existent endpoints
     */
    @ExceptionHandler(NoHandlerFoundException.class)
    public ResponseEntity<ApiErrorResponse> handleNoHandlerFound(
            NoHandlerFoundException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.NOT_FOUND.value())
                .errorCode(ErrorConstants.CODE_NOT_FOUND)
                .message("No handler found for " + ex.getHttpMethod() + " " + ex.getRequestURL())
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(errorResponse);
    }
    
    /**
     * Handle method not allowed exceptions
     */
    @ExceptionHandler(HttpRequestMethodNotSupportedException.class)
    public ResponseEntity<ApiErrorResponse> handleMethodNotAllowed(
            HttpRequestMethodNotSupportedException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.METHOD_NOT_ALLOWED.value())
                .errorCode(ErrorConstants.CODE_METHOD_NOT_ALLOWED)
                .message(ErrorConstants.METHOD_NOT_ALLOWED)
                .path(request.getRequestURI())
                .build();
        
        errorResponse.addDetail("supportedMethods", ex.getSupportedHttpMethods());
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.METHOD_NOT_ALLOWED).body(errorResponse);
    }
    
    /**
     * Handle media type not supported exceptions
     */
    @ExceptionHandler(HttpMediaTypeNotSupportedException.class)
    public ResponseEntity<ApiErrorResponse> handleMediaTypeNotSupported(
            HttpMediaTypeNotSupportedException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.UNSUPPORTED_MEDIA_TYPE.value())
                .errorCode(ErrorConstants.CODE_UNSUPPORTED_MEDIA)
                .message(ErrorConstants.UNSUPPORTED_MEDIA_TYPE)
                .path(request.getRequestURI())
                .build();
        
        errorResponse.addDetail("supportedMediaTypes", ex.getSupportedMediaTypes().stream()
                .map(MediaType::toString)
                .collect(Collectors.toList()));
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.UNSUPPORTED_MEDIA_TYPE).body(errorResponse);
    }
    
    /**
     * Handle type mismatch exceptions (e.g., wrong parameter types)
     */
    @ExceptionHandler(MethodArgumentTypeMismatchException.class)
    public ResponseEntity<ApiErrorResponse> handleTypeMismatch(
            MethodArgumentTypeMismatchException ex, HttpServletRequest request) {
        
        String message = String.format(
                "Parameter '%s' should be of type %s",
                ex.getName(),
                ex.getRequiredType() != null ? ex.getRequiredType().getSimpleName() : "unknown"
        );
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.BAD_REQUEST.value())
                .errorCode(ErrorConstants.CODE_VALIDATION)
                .message(message)
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(errorResponse);
    }
    
    /**
     * Handle data integrity violations (e.g., unique constraint violations)
     */
    @ExceptionHandler(DataIntegrityViolationException.class)
    public ResponseEntity<ApiErrorResponse> handleDataIntegrityViolation(
            DataIntegrityViolationException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.CONFLICT.value())
                .errorCode(ErrorConstants.CODE_DUPLICATE)
                .message(ErrorConstants.DUPLICATE_RESOURCE)
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
    }
    
    /**
     * Handle optimistic locking failures
     */
    @ExceptionHandler(OptimisticLockingFailureException.class)
    public ResponseEntity<ApiErrorResponse> handleOptimisticLocking(
            OptimisticLockingFailureException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.CONFLICT.value())
                .errorCode(ErrorConstants.CODE_VALIDATION)
                .message("The resource was modified by another user. Please refresh and try again.")
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.CONFLICT).body(errorResponse);
    }
    
    /**
     * Handle file size limit exceptions
     */
    @ExceptionHandler(MaxUploadSizeExceededException.class)
    public ResponseEntity<ApiErrorResponse> handleMaxSizeException(
            MaxUploadSizeExceededException ex, HttpServletRequest request) {
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.PAYLOAD_TOO_LARGE.value())
                .errorCode(ErrorConstants.CODE_VALIDATION)
                .message("File size exceeds the maximum allowed limit")
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.PAYLOAD_TOO_LARGE).body(errorResponse);
    }
    
    /**
     * Handle access denied exceptions (403 errors)
     * This is where we handle all FORBIDDEN status errors
     */
    @ExceptionHandler(AccessDeniedException.class)
    public ResponseEntity<ApiErrorResponse> handleAccessDenied(
            AccessDeniedException ex, HttpServletRequest request) {
        
        // Log detailed information about the 403 error
        LogUtils.logAccessDenied(log, request, ex.getMessage());
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.FORBIDDEN.value())
                .errorCode(ErrorConstants.CODE_ACCESS_DENIED)
                .message(ErrorConstants.ACCESS_DENIED)
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(errorResponse);
    }
    
    /**
     * Handle authentication exceptions (401 errors)
     */
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ApiErrorResponse> handleAuthenticationException(
            AuthenticationException ex, HttpServletRequest request) {
        
        String errorCode = ErrorConstants.CODE_AUTHENTICATION;
        String message = ErrorConstants.AUTHENTICATION_FAILED;
        
        // Handle specific authentication exceptions
        if (ex instanceof BadCredentialsException || ex instanceof UsernameNotFoundException) {
            message = "Invalid username or password";
        } else if (ex instanceof DisabledException) {
            errorCode = ErrorConstants.CODE_ACCOUNT_DISABLED;
            message = ErrorConstants.ACCOUNT_DISABLED;
        } else if (ex instanceof LockedException) {
            errorCode = ErrorConstants.CODE_ACCOUNT_LOCKED;
            message = ErrorConstants.ACCOUNT_LOCKED;
        } else if (ex instanceof AccountExpiredException) {
            errorCode = ErrorConstants.CODE_ACCOUNT_EXPIRED;
            message = ErrorConstants.ACCOUNT_EXPIRED;
        }
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .errorCode(errorCode)
                .message(message)
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(errorResponse);
    }
    
    /**
     * Handle response status exceptions
     */
    @ExceptionHandler(ResponseStatusException.class)
    public ResponseEntity<ApiErrorResponse> handleResponseStatusException(
            ResponseStatusException ex, HttpServletRequest request) {
        
        HttpStatus status = HttpStatus.valueOf(ex.getStatusCode().value());
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(status.value())
                .errorCode("ERR_" + status.name())
                .message(ex.getReason() != null ? ex.getReason() : status.getReasonPhrase())
                .path(request.getRequestURI())
                .build();
        
        LogUtils.logException(log, request, ex);
        return ResponseEntity.status(status).body(errorResponse);
    }
    
    /**
     * Handle all other exceptions
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ApiErrorResponse> handleAllExceptions(
            Exception ex, HttpServletRequest request) {
        
        // Log the full exception details for server-side debugging
        LogUtils.logException(log, request, ex);
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())
                .errorCode(ErrorConstants.CODE_INTERNAL_ERROR)
                .message(ErrorConstants.INTERNAL_SERVER_ERROR)
                .path(request.getRequestURI())
                .build();
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(errorResponse);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/config/RequestLoggingFilter.java">
package com.pharmacyhub.config;

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.MDC;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.util.UUID;

/**
 * Filter to log all incoming HTTP requests and outgoing responses
 * Adds request-specific information to the logging context for better traceability
 */
@Component
@Order(Ordered.HIGHEST_PRECEDENCE)
@Slf4j
public class RequestLoggingFilter implements Filter {
    
    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        
        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        
        // Generate a unique request ID for tracing
        String requestId = UUID.randomUUID().toString();
        
        // Add context information to MDC for logging
        MDC.put("requestId", requestId);
        MDC.put("method", httpRequest.getMethod());
        MDC.put("path", httpRequest.getRequestURI());
        MDC.put("ip", httpRequest.getRemoteAddr());
        MDC.put("userAgent", httpRequest.getHeader("User-Agent"));
        
        // Add the request ID to the response header for client-side tracing
        httpResponse.setHeader("X-Request-ID", requestId);
        
        try {
            // Log the incoming request
            log.info("Request: {} {}", httpRequest.getMethod(), httpRequest.getRequestURI());
            
            // Process the request
            long startTime = System.currentTimeMillis();
            chain.doFilter(request, response);
            long duration = System.currentTimeMillis() - startTime;
            
            // Log the response
            log.info("Response: {} {} - Status: {} - Duration: {}ms",
                    httpRequest.getMethod(),
                    httpRequest.getRequestURI(),
                    httpResponse.getStatus(),
                    duration);
            
            // Log detailed information for error responses
            if (httpResponse.getStatus() >= 400) {
                log.warn("Error response: {} {} - Status: {}",
                        httpRequest.getMethod(),
                        httpRequest.getRequestURI(),
                        httpResponse.getStatus());
            }
        } finally {
            // Clear MDC to prevent memory leaks
            MDC.clear();
        }
    }
    
    @Override
    public void init(FilterConfig filterConfig) throws ServletException {
        log.info("Initializing request logging filter");
    }
    
    @Override
    public void destroy() {
        log.info("Destroying request logging filter");
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/constants/APIConstants.java">
package com.pharmacyhub.constants;

public interface APIConstants
{
  String BASE_MAPPING = "/api";
  String API_VERSION_V1 = "/v1";

  String PHARMACIST ="/pharmacist";
  String PROPRIETOR ="/proprietor";
  String PHARMACY_MANAGER ="/pharmacymanager";
  String SALESMAN ="/salesman";
}
</file>

<file path="src/main/java/com/pharmacyhub/constants/ErrorConstants.java">
package com.pharmacyhub.constants;

/**
 * Constants for error messages and codes used across the application
 */
public final class ErrorConstants {
    
    private ErrorConstants() {
        // Private constructor to prevent instantiation
    }
    
    // HTTP Status Codes
    public static final int STATUS_BAD_REQUEST = 400;
    public static final int STATUS_UNAUTHORIZED = 401;
    public static final int STATUS_FORBIDDEN = 403;
    public static final int STATUS_NOT_FOUND = 404;
    public static final int STATUS_CONFLICT = 409;
    public static final int STATUS_INTERNAL_SERVER_ERROR = 500;
    
    // Error Messages
    public static final String INTERNAL_SERVER_ERROR = "An unexpected error occurred. Please try again later.";
    public static final String VALIDATION_ERROR = "Validation failed. Please check your input.";
    public static final String RESOURCE_NOT_FOUND = "The requested resource was not found.";
    public static final String ACCESS_DENIED = "You don't have permission to access this resource.";
    public static final String AUTHENTICATION_FAILED = "Authentication failed. Please check your credentials.";
    public static final String ACCOUNT_DISABLED = "Your account is disabled. Please contact support.";
    public static final String ACCOUNT_LOCKED = "Your account is locked. Please contact support.";
    public static final String ACCOUNT_EXPIRED = "Your account has expired. Please contact support.";
    public static final String INVALID_TOKEN = "Invalid or expired token.";
    public static final String METHOD_NOT_ALLOWED = "The requested method is not allowed.";
    public static final String UNSUPPORTED_MEDIA_TYPE = "Unsupported media type.";
    public static final String DUPLICATE_RESOURCE = "Resource already exists.";
    
    // Error Codes
    public static final String CODE_INTERNAL_ERROR = "ERR_INTERNAL";
    public static final String CODE_VALIDATION = "ERR_VALIDATION";
    public static final String CODE_NOT_FOUND = "ERR_NOT_FOUND";
    public static final String CODE_ACCESS_DENIED = "ERR_ACCESS_DENIED";
    public static final String CODE_AUTHENTICATION = "ERR_AUTHENTICATION";
    public static final String CODE_ACCOUNT_DISABLED = "ERR_ACCOUNT_DISABLED";
    public static final String CODE_ACCOUNT_LOCKED = "ERR_ACCOUNT_LOCKED";
    public static final String CODE_ACCOUNT_EXPIRED = "ERR_ACCOUNT_EXPIRED";
    public static final String CODE_INVALID_TOKEN = "ERR_INVALID_TOKEN";
    public static final String CODE_METHOD_NOT_ALLOWED = "ERR_METHOD_NOT_ALLOWED";
    public static final String CODE_UNSUPPORTED_MEDIA = "ERR_UNSUPPORTED_MEDIA";
    public static final String CODE_DUPLICATE = "ERR_DUPLICATE_RESOURCE";
}
</file>

<file path="src/main/java/com/pharmacyhub/constants/RoleEnum.java">
package com.pharmacyhub.constants;

public enum RoleEnum {
    USER("USER"),
    ADMIN("ADMIN"),
    SUPER_ADMIN("SUPER_ADMIN"),
    PHARMACIST("PHARMACIST"),
    PHARMACY_MANAGER("PHARMACY_MANAGER"),
    PROPRIETOR("PROPRIETOR"),
    SALESMAN("SALESMAN"),
    INVENTORY_MANAGER("INVENTORY_MANAGER"),
    INSTRUCTOR("INSTRUCTOR"),
    STUDENT("STUDENT"),
    EXAM_CREATOR("EXAM_CREATOR");
    
    private final String value;
    
    RoleEnum(String value) {
        this.value = value;
    }
    
    @Override
    public String toString() {
        return value;
    }
    
    public static RoleEnum fromString(String text) {
        for (RoleEnum role : RoleEnum.values()) {
            if (role.value.equalsIgnoreCase(text)) {
                return role;
            }
        }
        throw new IllegalArgumentException("No enum constant " + text);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/constants/StateEnum.java">
package com.pharmacyhub.constants;

public enum StateEnum
{
  READY_TO_CONNECT,
  DONE,
  DEAL_CANCEL,
  CLIENT_DISCONNECT
}
</file>

<file path="src/main/java/com/pharmacyhub/constants/UserEnum.java">
package com.pharmacyhub.constants;

public enum UserEnum
{
  PHARMACIST("p"),
  PROPRIETOR("pr"),
  PHARMACY_MANAGER("pm"),
  SALESMAN("s");

  private String userEnum;

  UserEnum(String userEnum) {
    this.userEnum = userEnum;
  }

  public String getUserEnum() {
    return userEnum;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/AuthController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.controller.base.BaseController;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.UserDTO;
import com.pharmacyhub.dto.request.LoginRequestDTO;
import com.pharmacyhub.dto.request.UserCreateRequestDTO;
import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.dto.response.ApiError;
import com.pharmacyhub.dto.response.AuthResponseDTO;
import com.pharmacyhub.dto.response.TokensDTO;
import com.pharmacyhub.dto.response.UserResponseDTO;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.service.AuthenticationService;
import com.pharmacyhub.service.UserService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/auth")
@Tag(name = "Authentication", description = "API endpoints for authentication and user management")
public class AuthController extends BaseController
{
    @Autowired
    private AuthenticationService authenticationService;
    @Autowired
    private UserService userService;
    
    @Value("${pharmacyhub.security.jwt.token-validity-in-seconds:18000}")
    private long tokenValidityInSeconds;

    private static final Logger logger = LoggerFactory.getLogger(AuthController.class);

    @PostMapping("/signup")
    @Operation(summary = "Register a new user")
    public ResponseEntity<ApiResponse<String>> signup(@Valid @RequestBody UserCreateRequestDTO request) {
        // Convert request to entity
        UserDTO userDTO = mapToEntity(request, UserDTO.class);
        PHUserDTO createdUser = userService.saveUser(userDTO);

        if (createdUser != null) {
            return successResponse("User registered successfully. Please check your email for verification.");
        }
        
        return errorResponse(HttpStatus.CONFLICT, "User with this email already exists");
    }

    @GetMapping("/verify")
    @Operation(summary = "Verify user email with token")
    public ResponseEntity<ApiResponse<String>> verifyEmail(@RequestParam String token) {
        boolean isVerified = userService.verifyUser(token);
        
        if (isVerified) {
            ApiResponse<String> response = ApiResponse.<String>builder()
                    .status(HttpStatus.FOUND.value())
                    .data("Email verification successful")
                    .build();
            
            return ResponseEntity.status(HttpStatus.FOUND)
                    .header(HttpHeaders.LOCATION, "https://pharmacyhub.pk/verification-successful")
                    .body(response);
        } else {
            ApiResponse<String> response = ApiResponse.<String>builder()
                    .status(HttpStatus.FOUND.value())
                    .error(new ApiError(HttpStatus.BAD_REQUEST.value(), "Email verification failed"))
                    .build();
            
            return ResponseEntity.status(HttpStatus.FOUND)
                    .header(HttpHeaders.LOCATION, "https://pharmacyhub.pk/verification-failed")
                    .body(response);
        }
    }


    @GetMapping("/test")
    @Operation(summary = "Test endpoint to get all users")
    public ResponseEntity<ApiResponse<List<User>>> test() {
        List<User> users = userService.findAll();
        return successResponse(users);
    }

    @PostMapping("/login")
    @Operation(summary = "Authenticate user and generate JWT token")
    public ResponseEntity<ApiResponse<AuthResponseDTO>> login(@Valid @RequestBody LoginRequestDTO request) {
        // Authenticate the user
        User authenticatedUser = authenticationService.authenticateUser(request.getEmailAddress(), request.getPassword());

        // Generate JWT token
        String token = authenticationService.generateToken(authenticatedUser);

        // Get user roles
        Set<Role> userRoles = authenticatedUser.getRoles();
        List<String> roleNames = userRoles.stream()
                                          .map(Role::getName)
                                          .collect(Collectors.toList());

        // Get user permissions
        Set<String> permissionNames = new HashSet<>();
        for (Role userRole : userRoles) {
            if (userRole.getPermissions() != null) {
                userRole.getPermissions().stream()
                        .map(Permission::getName)
                        .forEach(permissionNames::add);
            }
        }

        // Create user response DTO
        UserResponseDTO userResponse = UserResponseDTO.builder()
                .id(authenticatedUser.getId().toString())
                .email(authenticatedUser.getEmailAddress())
                .firstName(authenticatedUser.getFirstName())
                .lastName(authenticatedUser.getLastName())
                .active(authenticatedUser.isEnabled())
                .createdAt(LocalDateTime.now().toString())
                .updatedAt(LocalDateTime.now().toString())
                .roles(roleNames)
                .build();

        // Create tokens DTO
        TokensDTO tokens = TokensDTO.builder()
                .accessToken(token)
                .tokenType("Bearer")
                .expiresIn(tokenValidityInSeconds) // Use the configured token validity
                .build();

        // Create response DTO
        AuthResponseDTO response = AuthResponseDTO.builder()
                .user(userResponse)
                .tokens(tokens)
                .build();

        logger.info("Login successful for user: {}", authenticatedUser.getUsername());
        return successResponse(response);
    }


}
</file>

<file path="src/main/java/com/pharmacyhub/controller/base/BaseController.java">
package com.pharmacyhub.controller.base;

import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.utils.EntityMapper;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.util.Collection;
import java.util.List;
import java.util.Map;

/**
 * Base controller providing common functionality for all controllers
 */
public abstract class BaseController {
    
    @Autowired
    protected EntityMapper entityMapper;
    
    /**
     * Create a success response with OK status
     */
    protected <T> ResponseEntity<ApiResponse<T>> successResponse(T data) {
        return ResponseEntity.ok(ApiResponse.success(data));
    }
    
    /**
     * Create a success response with a custom status
     */
    protected <T> ResponseEntity<ApiResponse<T>> successResponse(T data, HttpStatus status) {
        return new ResponseEntity<>(ApiResponse.success(data, status.value()), status);
    }
    
    /**
     * Create a success response with metadata
     */
    protected <T> ResponseEntity<ApiResponse<T>> successResponse(T data, Map<String, Object> metadata) {
        return ResponseEntity.ok(ApiResponse.success(data, HttpStatus.OK.value(), metadata));
    }
    
    /**
     * Create a created response (201)
     */
    protected <T> ResponseEntity<ApiResponse<T>> createdResponse(T data) {
        return new ResponseEntity<>(
                ApiResponse.success(data, HttpStatus.CREATED.value()),
                HttpStatus.CREATED
        );
    }
    
    /**
     * Create a no content response (204)
     */
    protected <T> ResponseEntity<ApiResponse<T>> noContentResponse() {
        return new ResponseEntity<>(
                ApiResponse.success(null, HttpStatus.NO_CONTENT.value()),
                HttpStatus.NO_CONTENT
        );
    }
    
    /**
     * Create an error response
     */
    protected <T> ResponseEntity<ApiResponse<T>> errorResponse(HttpStatus status, String message) {
        return new ResponseEntity<>(ApiResponse.error(status.value(), message), status);
    }
    
    /**
     * Map an entity to a DTO
     */
    protected <D, T> D mapToDTO(T entity, Class<D> dtoClass) {
        return entityMapper.map(entity, dtoClass);
    }
    
    /**
     * Map a collection of entities to a list of DTOs
     */
    protected <D, T> List<D> mapToDTO(Collection<T> entities, Class<D> dtoClass) {
        return entityMapper.mapList(entities, dtoClass);
    }
    
    /**
     * Map a DTO to an entity
     */
    protected <D, T> T mapToEntity(D dto, Class<T> entityClass) {
        return entityMapper.mapToEntity(dto, entityClass);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/EntryController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.entity.Entry;
import com.pharmacyhub.service.EntryService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

@RestController
@RequestMapping("/api/admin/entries")
public class EntryController {

    @Autowired
    private EntryService entryService;

    @GetMapping
    public ResponseEntity<List<Entry>> getAllEntries() {
        List<Entry> entries = entryService.getAllEntries();
        return ResponseEntity.ok(entries);
    }

    @GetMapping("/{id}")
    public ResponseEntity<Entry> getEntryById(@PathVariable Long id) {
        return entryService.getEntryById(id)
                .map(ResponseEntity::ok)
                .orElse(ResponseEntity.notFound().build());
    }

    @PostMapping
    public ResponseEntity<Entry> createEntry(@RequestBody Entry entry) {
        Entry savedEntry = entryService.saveEntry(entry);
        return ResponseEntity.ok(savedEntry);
    }

    @PutMapping("/{id}")
    public ResponseEntity<Entry> updateEntry(@PathVariable Long id, @RequestBody Entry entryDetails) {
        try {
            Entry updatedEntry = entryService.updateEntry(id, entryDetails);
            return ResponseEntity.ok(updatedEntry);
        } catch (RuntimeException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @DeleteMapping("/{id}")
    public ResponseEntity<?> deleteEntry(@PathVariable Long id) {
        return entryService.getEntryById(id)
                .map(entry -> {
                    entryService.deleteEntry(id);
                    return ResponseEntity.ok().build();
                })
                .orElse(ResponseEntity.notFound().build());
    }

    // Additional endpoints can be added here as needed

    @GetMapping("/search")
    public ResponseEntity<List<Entry>> searchEntries(@RequestParam String query) {
        List<Entry> entries = entryService.searchEntries(query);
        return ResponseEntity.ok(entries);
    }

    @GetMapping("/count")
    public ResponseEntity<Long> getEntryCount() {
        long count = entryService.getEntryCount();
        return ResponseEntity.ok(count);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/ErrorDemoController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.exception.BadRequestException;
import com.pharmacyhub.exception.ForbiddenException;
import com.pharmacyhub.exception.ResourceNotFoundException;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.constraints.Min;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * Demo controller for testing exception handling
 * Contains endpoints that trigger different types of exceptions
 */
@RestController
@RequestMapping("/api/test")
@Tag(name = "Error Handler Test", description = "Endpoints for testing error handling")
@Validated
@Slf4j
public class ErrorDemoController {
    
    @GetMapping("/success")
    @Operation(summary = "Test successful response")
    public ResponseEntity<ApiResponse<String>> testSuccess() {
        log.info("Processing successful request");
        return ResponseEntity.ok(ApiResponse.of("Request processed successfully"));
    }
    
    @GetMapping("/bad-request")
    @Operation(summary = "Test 400 Bad Request")
    public ResponseEntity<ApiResponse<String>> testBadRequest() {
        log.info("Testing bad request exception");
        throw new BadRequestException("This is a demonstration of a Bad Request exception");
    }
    
    @GetMapping("/not-found/{id}")
    @Operation(summary = "Test 404 Not Found")
    public ResponseEntity<ApiResponse<String>> testNotFound(@PathVariable @Min(1) Long id) {
        log.info("Testing resource not found exception for id: {}", id);
        throw new ResourceNotFoundException("Resource", "id", id);
    }
    
    @GetMapping("/forbidden")
    @Operation(summary = "Test 403 Forbidden")
    public ResponseEntity<ApiResponse<String>> testForbidden() {
        log.info("Testing forbidden exception");
        throw new ForbiddenException("This is a demonstration of a Forbidden exception");
    }
    
    @GetMapping("/admin-only")
    @PreAuthorize("hasRole('ADMIN')")
    @Operation(summary = "Test endpoint with Spring Security @PreAuthorize")
    public ResponseEntity<ApiResponse<String>> adminOnlyEndpoint() {
        log.info("Accessing admin-only endpoint");
        return ResponseEntity.ok(ApiResponse.of("You have ADMIN access"));
    }
    
    @GetMapping("/error")
    @Operation(summary = "Test 500 Internal Server Error")
    public ResponseEntity<ApiResponse<String>> testServerError() {
        log.info("Testing server error");
        throw new RuntimeException("This is a demonstration of an internal server error");
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/ExamAttemptController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.dto.ExamResultDTO;
import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.dto.response.ExamAttemptResponseDTO;
import com.pharmacyhub.dto.request.AnswerSubmissionDTO;
import com.pharmacyhub.dto.response.FlaggedQuestionResponseDTO;
import com.pharmacyhub.service.ExamAttemptService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;

@RestController
@RequestMapping("/api/v1/exams")
@CrossOrigin(origins = "*", maxAge = 3600)
@Tag(name = "Exam Attempts", description = "API endpoints for exam attempts")
public class ExamAttemptController {

    private static final Logger logger = LoggerFactory.getLogger(ExamAttemptController.class);
    private final ExamAttemptService examAttemptService;

    public ExamAttemptController(ExamAttemptService examAttemptService) {
        this.examAttemptService = examAttemptService;
    }

    @PostMapping("/{examId}/start")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Start a new exam attempt")
    public ResponseEntity<ApiResponse<ExamAttemptResponseDTO>> startExam(
            @PathVariable Long examId,
            Authentication auth) {
        
        String userId = auth.getName();
        logger.info("User {} attempting to start exam {}", userId, examId);
        
        ExamAttemptResponseDTO attempt = examAttemptService.startExam(examId, userId);
        
        return ResponseEntity
                .status(HttpStatus.CREATED)
                .body(ApiResponse.<ExamAttemptResponseDTO>success(attempt, 201));
    }

    @GetMapping("/attempts/user")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get current user's exam attempts")
    public ResponseEntity<ApiResponse<List<ExamAttemptResponseDTO>>> getCurrentUserAttempts(Authentication auth) {
        String userId = auth.getName();
        logger.info("Fetching exam attempts for user: {}", userId);
        
        List<ExamAttemptResponseDTO> attempts = examAttemptService.getAttemptsByUserId(userId);
        
        return ResponseEntity.ok(ApiResponse.<List<ExamAttemptResponseDTO>>success(attempts));
    }

    @GetMapping("/{examId}/attempts")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get user's attempts for a specific exam")
    public ResponseEntity<ApiResponse<List<ExamAttemptResponseDTO>>> getExamAttempts(
            @PathVariable Long examId,
            Authentication auth) {
        
        String userId = auth.getName();
        logger.info("Fetching attempts for exam {} by user {}", examId, userId);
        
        List<ExamAttemptResponseDTO> attempts = examAttemptService.getAttemptsByExamAndUserId(examId, userId);
        
        return ResponseEntity.ok(ApiResponse.<List<ExamAttemptResponseDTO>>success(attempts));
    }

    @GetMapping("/attempts/{attemptId}")
    @PreAuthorize("isAuthenticated() and @examAccessEvaluator.canAccessAttempt(authentication, #attemptId)")
    @Operation(summary = "Get a specific exam attempt")
    public ResponseEntity<ApiResponse<ExamAttemptResponseDTO>> getAttempt(@PathVariable Long attemptId) {
        logger.info("Fetching exam attempt with ID: {}", attemptId);
        
        ExamAttemptResponseDTO attempt = examAttemptService.getAttemptById(attemptId);
        
        return ResponseEntity.ok(ApiResponse.<ExamAttemptResponseDTO>success(attempt));
    }

    @PostMapping("/attempts/{attemptId}/answer/{questionId}")
    @PreAuthorize("isAuthenticated() and @examAccessEvaluator.canAccessAttempt(authentication, #attemptId)")
    @Operation(summary = "Submit an answer for a question")
    public ResponseEntity<ApiResponse<Void>> submitAnswer(
            @PathVariable Long attemptId,
            @PathVariable Long questionId,
            @RequestBody @Valid AnswerSubmissionDTO answerDTO) {
        
        logger.info("Submitting answer for question {} in attempt {}", questionId, attemptId);
        
        examAttemptService.saveAnswer(attemptId, questionId, answerDTO.getSelectedOptionId(), answerDTO.getTimeSpent());
        
        return ResponseEntity.ok(ApiResponse.<Void>success(null));
    }

    @PostMapping("/attempts/{attemptId}/submit")
    @PreAuthorize("isAuthenticated() and @examAccessEvaluator.canAccessAttempt(authentication, #attemptId)")
    @Operation(summary = "Submit an exam attempt")
    public ResponseEntity<ApiResponse<ExamResultDTO>> submitExam(
            @PathVariable Long attemptId,
            @RequestBody(required = false) List<AnswerSubmissionDTO> finalAnswers,
            Authentication auth) {
        
        String userId = auth.getName();
        logger.info("User {} submitting exam attempt {}", userId, attemptId);
        
        try {
            // Process any final answers if provided
            if (finalAnswers != null && !finalAnswers.isEmpty()) {
                for (AnswerSubmissionDTO answer : finalAnswers) {
                    examAttemptService.saveAnswer(
                        attemptId, 
                        answer.getQuestionId(), 
                        answer.getSelectedOptionId(), 
                        answer.getTimeSpent()
                    );
                }
            }
            
            // Submit the exam and get results
            ExamResultDTO result = examAttemptService.submitExamAttempt(attemptId);
            
            return ResponseEntity.ok(ApiResponse.<ExamResultDTO>success(result));
        } catch (Exception e) {
            logger.error("Error submitting exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage(), e);
        }
    }

    @GetMapping("/attempts/{attemptId}/result")
    @PreAuthorize("isAuthenticated() and @examAccessEvaluator.canAccessAttempt(authentication, #attemptId)")
    @Operation(summary = "Get the result for a completed exam")
    public ResponseEntity<ApiResponse<ExamResultDTO>> getExamResult(@PathVariable Long attemptId) {
        logger.info("Fetching result for exam attempt: {}", attemptId);
        
        try {
            ExamResultDTO result = examAttemptService.getExamResult(attemptId);
            return ResponseEntity.ok(ApiResponse.<ExamResultDTO>success(result));
        } catch (Exception e) {
            logger.error("Error fetching exam result: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage(), e);
        }
    }

    @PostMapping("/attempts/{attemptId}/flag/{questionId}")
    @PreAuthorize("isAuthenticated() and @examAccessEvaluator.canAccessAttempt(authentication, #attemptId)")
    @Operation(summary = "Flag a question for review")
    public ResponseEntity<ApiResponse<Void>> flagQuestion(
            @PathVariable Long attemptId,
            @PathVariable Long questionId) {
        
        logger.info("Flagging question {} in attempt {}", questionId, attemptId);
        
        examAttemptService.flagQuestion(attemptId, questionId);
        
        return ResponseEntity.ok(ApiResponse.<Void>success(null));
    }

    @DeleteMapping("/attempts/{attemptId}/flag/{questionId}")
    @PreAuthorize("isAuthenticated() and @examAccessEvaluator.canAccessAttempt(authentication, #attemptId)")
    @Operation(summary = "Unflag a previously flagged question")
    public ResponseEntity<ApiResponse<Void>> unflagQuestion(
            @PathVariable Long attemptId,
            @PathVariable Long questionId) {
        
        logger.info("Unflagging question {} in attempt {}", questionId, attemptId);
        
        examAttemptService.unflagQuestion(attemptId, questionId);
        
        return ResponseEntity.ok(ApiResponse.<Void>success(null));
    }

    @GetMapping("/attempts/{attemptId}/flags")
    @PreAuthorize("isAuthenticated() and @examAccessEvaluator.canAccessAttempt(authentication, #attemptId)")
    @Operation(summary = "Get all flagged questions for an attempt")
    public ResponseEntity<ApiResponse<List<FlaggedQuestionResponseDTO>>> getFlaggedQuestions(
            @PathVariable Long attemptId) {
        
        logger.info("Fetching flagged questions for attempt {}", attemptId);
        
        List<FlaggedQuestionResponseDTO> flaggedQuestions = examAttemptService.getFlaggedQuestions(attemptId);
        
        return ResponseEntity.ok(ApiResponse.<List<FlaggedQuestionResponseDTO>>success(flaggedQuestions));
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/ExamController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.domain.entity.Exam;
import com.pharmacyhub.domain.entity.Question;
import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.dto.request.ExamRequestDTO;
import com.pharmacyhub.dto.request.JsonExamUploadRequestDTO;
import com.pharmacyhub.dto.response.ExamResponseDTO;
import com.pharmacyhub.dto.response.QuestionResponseDTO;
import com.pharmacyhub.security.annotation.RequiresPermission;
import com.pharmacyhub.security.constants.ExamPermissionConstants;
import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.service.ExamService;
import com.pharmacyhub.service.JsonExamUploadService;
import com.pharmacyhub.service.QuestionService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.persistence.EntityNotFoundException;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/exams")
@CrossOrigin(origins = "*", maxAge = 3600)
@Tag(name = "Exams", description = "API endpoints for exam management")
public class ExamController {

    private static final Logger logger = LoggerFactory.getLogger(ExamController.class);

    private final ExamService examService;
    private final QuestionService questionService;
    private final JsonExamUploadService jsonExamUploadService;

    public ExamController(ExamService examService, QuestionService questionService, JsonExamUploadService jsonExamUploadService) {
        this.examService = examService;
        this.questionService = questionService;
        this.jsonExamUploadService = jsonExamUploadService;
    }

    @GetMapping
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.READ, permissionName = ExamPermissionConstants.VIEW_EXAMS)
    @Operation(summary = "Get all exams - Admin/Instructor only")
    public ResponseEntity<ApiResponse<List<ExamResponseDTO>>> getAllExams() {
        logger.info("Fetching all exams");
        List<Exam> exams = examService.findAllActive();
        List<ExamResponseDTO> examResponseDTOs = exams.stream()
                .map(this::mapToExamResponseDTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(examResponseDTOs));
    }

    @GetMapping("/published")
    @Operation(summary = "Get all published exams - Public access")
    public ResponseEntity<ApiResponse<List<ExamResponseDTO>>> getAllPublishedExams() {
        logger.info("Fetching all published exams");
        try {
            List<Exam> publishedExams = examService.findAllPublished();
            List<ExamResponseDTO> examResponseDTOs = publishedExams.stream()
                    .map(this::mapToExamResponseDTO)
                    .collect(Collectors.toList());
            logger.info("Successfully fetched {} published exams", examResponseDTOs.size());
            return ResponseEntity.ok(ApiResponse.success(examResponseDTOs));
        } catch (Exception e) {
            logger.error("Error fetching published exams: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching published exams", e);
        }
    }
    
    @GetMapping("/papers/model")
    @Operation(summary = "Get model papers")
    public ResponseEntity<ApiResponse<List<ExamResponseDTO>>> getModelPapers() {
        logger.info("Fetching model papers");
        
        // Get all published exams with "MODEL" tag
        List<Exam> exams = examService.findAllPublished().stream()
                .filter(exam -> exam.getTags() != null && 
                      exam.getTags().stream().anyMatch(tag -> tag.equalsIgnoreCase("MODEL")))
                .collect(Collectors.toList());
        
        List<ExamResponseDTO> examDTOs = exams.stream()
                .map(this::mapToExamResponseDTO)
                .collect(Collectors.toList());
                
        return ResponseEntity.ok(ApiResponse.success(examDTOs));
    }

    @GetMapping("/papers/past")
    @Operation(summary = "Get past papers")
    public ResponseEntity<ApiResponse<List<ExamResponseDTO>>> getPastPapers() {
        logger.info("Fetching past papers");
        
        // Get all published exams with "PAST" tag
        List<Exam> exams = examService.findAllPublished().stream()
                .filter(exam -> exam.getTags() != null && 
                      exam.getTags().stream().anyMatch(tag -> tag.equalsIgnoreCase("PAST")))
                .collect(Collectors.toList());
        
        List<ExamResponseDTO> examDTOs = exams.stream()
                .map(this::mapToExamResponseDTO)
                .collect(Collectors.toList());
                
        return ResponseEntity.ok(ApiResponse.success(examDTOs));
    }
    
    @GetMapping("/papers/subject")
    @Operation(summary = "Get subject papers")
    public ResponseEntity<ApiResponse<List<ExamResponseDTO>>> getSubjectPapers() {
        logger.info("Fetching subject papers");
        
        // Get all published exams with "SUBJECT" tag
        List<Exam> exams = examService.findAllPublished().stream()
                .filter(exam -> exam.getTags() != null && 
                      exam.getTags().stream().anyMatch(tag -> tag.equalsIgnoreCase("SUBJECT")))
                .collect(Collectors.toList());
        
        List<ExamResponseDTO> examDTOs = exams.stream()
                .map(this::mapToExamResponseDTO)
                .collect(Collectors.toList());
                
        return ResponseEntity.ok(ApiResponse.success(examDTOs));
    }
    
    @GetMapping("/papers/practice")
    @Operation(summary = "Get practice papers")
    public ResponseEntity<ApiResponse<List<ExamResponseDTO>>> getPracticePapers() {
        logger.info("Fetching practice papers");
        
        // Get all published exams with "PRACTICE" tag
        List<Exam> exams = examService.findAllPublished().stream()
                .filter(exam -> exam.getTags() != null && 
                      exam.getTags().stream().anyMatch(tag -> tag.equalsIgnoreCase("PRACTICE")))
                .collect(Collectors.toList());
        
        List<ExamResponseDTO> examDTOs = exams.stream()
                .map(this::mapToExamResponseDTO)
                .collect(Collectors.toList());
                
        return ResponseEntity.ok(ApiResponse.success(examDTOs));
    }

    @GetMapping("/stats")
    @Operation(summary = "Get exam statistics")
    public ResponseEntity<ApiResponse<Map<String, Object>>> getExamStats() {
        logger.info("Fetching exam statistics");
        Map<String, Object> stats = examService.getExamStats();
        return ResponseEntity.ok(ApiResponse.success(stats));
    }

    @GetMapping("/{id}")
    @Operation(summary = "Get exam by ID")
    public ResponseEntity<ApiResponse<ExamResponseDTO>> getExamById(@PathVariable Long id) {
        logger.info("Fetching exam with ID: {}", id);
        try {
            Exam exam = examService.findById(id)
                .orElseThrow(() -> new EntityNotFoundException("Exam not found with ID: " + id));
            ExamResponseDTO examResponseDTO = mapToExamResponseDTO(exam);
            return ResponseEntity.ok(ApiResponse.success(examResponseDTO));
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        }
    }

    @GetMapping("/{examId}/questions")
    @Operation(summary = "Get questions for a specific exam")
    public ResponseEntity<ApiResponse<List<QuestionResponseDTO>>> getExamQuestions(@PathVariable Long examId) {
        logger.info("Fetching questions for exam with ID: {}", examId);
        try {
            List<Question> questions = questionService.getQuestionsByExamId(examId);
            List<QuestionResponseDTO> questionDTOs = questions.stream()
                    .map(this::mapToQuestionResponseDTO)
                    .collect(Collectors.toList());
            
            return ResponseEntity.ok(ApiResponse.success(questionDTOs));
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (Exception e) {
            logger.error("Error fetching questions for exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error fetching exam questions", e);
        }
    }
    
    @PutMapping("/{examId}/questions/{questionId}")
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.UPDATE, permissionName = ExamPermissionConstants.MANAGE_QUESTIONS)
    @Operation(summary = "Update a specific question in an exam")
    public ResponseEntity<ApiResponse<QuestionResponseDTO>> updateQuestion(
            @PathVariable Long examId,
            @PathVariable Long questionId,
            @Valid @RequestBody Question questionData) {
        logger.info("Updating question {} for exam {}", questionId, examId);
        try {
            // Ensure the question belongs to the exam
            Question existingQuestion = questionService.getQuestionById(questionId)
                .orElseThrow(() -> new EntityNotFoundException("Question not found with id: " + questionId));
            if (!existingQuestion.getExam().getId().equals(examId)) {
                throw new ResponseStatusException(HttpStatus.BAD_REQUEST, "Question doesn't belong to the specified exam");
            }
            
            // Update the question
            Question updatedQuestion = questionService.updateQuestion(questionId, questionData);
            QuestionResponseDTO responseDTO = mapToQuestionResponseDTO(updatedQuestion);
            
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (Exception e) {
            logger.error("Error updating question: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage(), e);
        }
    }

    @PostMapping
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.CREATE, permissionName = ExamPermissionConstants.CREATE_EXAM)
    @Operation(summary = "Create a new exam")
    public ResponseEntity<ApiResponse<ExamResponseDTO>> createExam(@Valid @RequestBody ExamRequestDTO requestDTO) {
        logger.info("Creating new exam");
        try {
            Exam exam = mapToExamEntity(requestDTO);
            Exam createdExam = examService.createExam(exam);
            ExamResponseDTO responseDTO = mapToExamResponseDTO(createdExam);
            return ResponseEntity.status(HttpStatus.CREATED)
                    .body(ApiResponse.success(responseDTO, 201));
        } catch (Exception e) {
            logger.error("Error creating exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage(), e);
        }
    }

    @PostMapping("/upload-json")
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.CREATE, permissionName = ExamPermissionConstants.CREATE_EXAM)
    @Operation(summary = "Upload and create an exam from JSON data")
    public ResponseEntity<ApiResponse<ExamResponseDTO>> uploadJsonExam(
            @Valid @RequestBody JsonExamUploadRequestDTO requestDTO) {
        logger.info("Uploading JSON exam: {}", requestDTO.getTitle());
        try {
            Exam createdExam = jsonExamUploadService.processJsonAndCreateExam(requestDTO);
            ExamResponseDTO responseDTO = mapToExamResponseDTO(createdExam);
            return ResponseEntity.status(HttpStatus.CREATED)
                    .body(ApiResponse.success(responseDTO, 201));
        } catch (Exception e) {
            logger.error("Error uploading JSON exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage(), e);
        }
    }

    @PutMapping("/{id}")
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.UPDATE, permissionName = ExamPermissionConstants.EDIT_EXAM)
    @Operation(summary = "Update an existing exam")
    public ResponseEntity<ApiResponse<ExamResponseDTO>> updateExam(
            @PathVariable Long id, 
            @Valid @RequestBody ExamRequestDTO requestDTO) {
        logger.info("Updating exam with ID: {}", id);
        try {
            Exam exam = mapToExamEntity(requestDTO);
            Exam updatedExam = examService.updateExam(id, exam);
            ExamResponseDTO responseDTO = mapToExamResponseDTO(updatedExam);
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (Exception e) {
            logger.error("Error updating exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage(), e);
        }
    }

    @DeleteMapping("/{id}")
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.DELETE, permissionName = ExamPermissionConstants.DELETE_EXAM)
    @Operation(summary = "Delete an exam (Admin only)")
    public ResponseEntity<ApiResponse<Void>> deleteExam(@PathVariable Long id) {
        logger.info("Deleting exam with ID: {}", id);
        try {
            examService.deleteExam(id);
            return ResponseEntity.ok(ApiResponse.success(null));
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (Exception e) {
            logger.error("Error deleting exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error deleting exam", e);
        }
    }

    @GetMapping("/status/{status}")
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.READ, permissionName = ExamPermissionConstants.VIEW_EXAMS)
    @Operation(summary = "Get exams by status")
    public ResponseEntity<ApiResponse<List<ExamResponseDTO>>> getExamsByStatus(@PathVariable Exam.ExamStatus status) {
        logger.info("Fetching exams with status: {}", status);
        List<Exam> exams = examService.findByStatus(status);
        List<ExamResponseDTO> examResponseDTOs = exams.stream()
                .map(this::mapToExamResponseDTO)
                .collect(Collectors.toList());
        return ResponseEntity.ok(ApiResponse.success(examResponseDTOs));
    }

    @PostMapping("/{id}/publish")
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.UPDATE, permissionName = ExamPermissionConstants.PUBLISH_EXAM)
    @Operation(summary = "Publish an exam")
    public ResponseEntity<ApiResponse<ExamResponseDTO>> publishExam(@PathVariable Long id) {
        logger.info("Publishing exam with ID: {}", id);
        try {
            Exam publishedExam = examService.publishExam(id);
            ExamResponseDTO responseDTO = mapToExamResponseDTO(publishedExam);
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (IllegalStateException e) {
            throw new ResponseStatusException(HttpStatus.BAD_REQUEST, e.getMessage());
        } catch (Exception e) {
            logger.error("Error publishing exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error publishing exam", e);
        }
    }

    @PostMapping("/{id}/archive")
    @RequiresPermission(resource = ResourceType.PHARMACY, operation = OperationType.UPDATE, permissionName = ExamPermissionConstants.UNPUBLISH_EXAM)
    @Operation(summary = "Archive an exam")
    public ResponseEntity<ApiResponse<ExamResponseDTO>> archiveExam(@PathVariable Long id) {
        logger.info("Archiving exam with ID: {}", id);
        try {
            Exam archivedExam = examService.archiveExam(id);
            ExamResponseDTO responseDTO = mapToExamResponseDTO(archivedExam);
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (EntityNotFoundException e) {
            throw new ResponseStatusException(HttpStatus.NOT_FOUND, e.getMessage());
        } catch (Exception e) {
            logger.error("Error archiving exam: {}", e.getMessage(), e);
            throw new ResponseStatusException(HttpStatus.INTERNAL_SERVER_ERROR, "Error archiving exam", e);
        }
    }

    // Helper methods for mapping between DTO and entity
    private ExamResponseDTO mapToExamResponseDTO(Exam exam) {
        ExamResponseDTO dto = new ExamResponseDTO();
        dto.setId(exam.getId());
        dto.setTitle(exam.getTitle());
        dto.setDescription(exam.getDescription());
        dto.setDuration(exam.getDuration());
        dto.setTotalMarks(exam.getTotalMarks());
        dto.setPassingMarks(exam.getPassingMarks());
        dto.setStatus(exam.getStatus());
        dto.setTags(exam.getTags());
        
        // Map questions if present (but don't include them for list operations)
        if (exam.getQuestions() != null && !exam.getQuestions().isEmpty()) {
            List<ExamResponseDTO.QuestionDTO> questionDTOs = exam.getQuestions().stream()
                    .map(this::mapToQuestionDTO)
                    .collect(Collectors.toList());
            dto.setQuestions(questionDTOs);
        }
        
        return dto;
    }
    
    private ExamResponseDTO.QuestionDTO mapToQuestionDTO(Question question) {
        ExamResponseDTO.QuestionDTO dto = new ExamResponseDTO.QuestionDTO();
        dto.setId(question.getId());
        dto.setQuestionNumber(question.getQuestionNumber());
        dto.setQuestionText(question.getQuestionText());
        dto.setCorrectAnswer(question.getCorrectAnswer());
        dto.setExplanation(question.getExplanation());
        dto.setMarks(question.getMarks());
        dto.setTopic(question.getTopic());
        dto.setDifficulty(question.getDifficulty());
        
        // Map options
        if (question.getOptions() != null) {
            List<ExamResponseDTO.OptionDTO> optionDTOs = question.getOptions().stream()
                    .map(option -> {
                        ExamResponseDTO.OptionDTO optionDTO = new ExamResponseDTO.OptionDTO();
                        optionDTO.setId(option.getId());
                        optionDTO.setOptionKey(option.getLabel());
                        optionDTO.setOptionText(option.getText());
                        optionDTO.setIsCorrect(option.getIsCorrect());
                        return optionDTO;
                    })
                    .collect(Collectors.toList());
            dto.setOptions(optionDTOs);
        }
        
        return dto;
    }
    
    private QuestionResponseDTO mapToQuestionResponseDTO(Question question) {
        QuestionResponseDTO dto = new QuestionResponseDTO();
        dto.setId(question.getId());
        dto.setQuestionNumber(question.getQuestionNumber());
        dto.setText(question.getQuestionText());
        // Don't include the correct answer in the response for security
        dto.setExplanation(question.getExplanation());
        dto.setPoints(question.getMarks());
        dto.setTopic(question.getTopic());
        dto.setDifficulty(question.getDifficulty());
        
        // Map options without revealing which is correct
        if (question.getOptions() != null) {
            List<QuestionResponseDTO.OptionDTO> optionDTOs = question.getOptions().stream()
                    .map(option -> {
                        QuestionResponseDTO.OptionDTO optionDTO = new QuestionResponseDTO.OptionDTO();
                        optionDTO.setId(option.getId());
                        optionDTO.setLabel(option.getLabel());
                        optionDTO.setText(option.getText());
                        // Don't include isCorrect flag for security
                        return optionDTO;
                    })
                    .collect(Collectors.toList());
            dto.setOptions(optionDTOs);
        }
        
        return dto;
    }
    
    private Exam mapToExamEntity(ExamRequestDTO dto) {
        Exam exam = new Exam();
        exam.setTitle(dto.getTitle());
        exam.setDescription(dto.getDescription());
        exam.setDuration(dto.getDuration());
        exam.setTotalMarks(dto.getTotalMarks());
        exam.setPassingMarks(dto.getPassingMarks());
        exam.setStatus(dto.getStatus() != null ? dto.getStatus() : Exam.ExamStatus.DRAFT);
        exam.setTags(dto.getTags());
        
        // Questions will be added/updated separately
        return exam;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/FeatureAccessController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.security.domain.Feature;
import com.pharmacyhub.security.dto.FeatureAccessDTO;
import com.pharmacyhub.security.service.FeatureService;
import com.pharmacyhub.security.service.RBACService;
import com.pharmacyhub.utils.SecurityUtils;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Controller for feature access-related endpoints
 * Provides centralized access control for frontend components
 */
@RestController
@RequestMapping("/api/feature-access")
@RequiredArgsConstructor
public class FeatureAccessController {
    private final FeatureService featureService;
    private final RBACService rbacService;
    private final SecurityUtils securityUtils;
    
    /**
     * Check if the current user has access to a specific feature
     * Returns detailed access information including allowed operations
     */
    @GetMapping("/check/{featureCode}")
    public ResponseEntity<FeatureAccessDTO> checkFeatureAccess(@PathVariable String featureCode) {
        Long userId = securityUtils.getCurrentUserId();
        Feature feature = featureService.getFeatureByCode(featureCode);
        
        boolean hasAccess = rbacService.userHasFeatureAccess(userId, featureCode);
        
        Set<String> allowedOperations = new HashSet<>();
        if (hasAccess && feature != null) {
            // Check each operation
            for (String operation : feature.getOperations()) {
                if (rbacService.userHasFeatureOperation(userId, featureCode, operation)) {
                    allowedOperations.add(operation);
                }
            }
        }
        
        FeatureAccessDTO accessDTO = FeatureAccessDTO.builder()
                .featureCode(featureCode)
                .name(feature != null ? feature.getName() : featureCode)
                .description(feature != null ? feature.getDescription() : "")
                .hasAccess(hasAccess)
                .allowedOperations(allowedOperations)
                .build();
        
        return ResponseEntity.ok(accessDTO);
    }
    
    /**
     * Check if the current user can perform a specific operation on a feature
     * Returns true if access is granted, false otherwise
     */
    @GetMapping("/check/{featureCode}/{operation}")
    public ResponseEntity<Boolean> checkOperationAccess(
            @PathVariable String featureCode, 
            @PathVariable String operation) {
        Long userId = securityUtils.getCurrentUserId();
        boolean hasAccess = rbacService.userHasFeatureOperation(userId, featureCode, operation);
        return ResponseEntity.ok(hasAccess);
    }
    
    /**
     * Get all features the current user has access to
     * Returns a list of features with access details
     */
    @GetMapping("/user-features")
    public ResponseEntity<List<FeatureAccessDTO>> getUserFeatures() {
        Long userId = securityUtils.getCurrentUserId();
        List<Feature> features = featureService.getAllFeatures();
        
        List<FeatureAccessDTO> accessDTOs = features.stream()
                .map(feature -> {
                    boolean hasAccess = rbacService.userHasFeatureAccess(userId, feature.getCode());
                    
                    Set<String> allowedOperations = new HashSet<>();
                    if (hasAccess) {
                        // Check each operation
                        for (String operation : feature.getOperations()) {
                            if (rbacService.userHasFeatureOperation(userId, feature.getCode(), operation)) {
                                allowedOperations.add(operation);
                            }
                        }
                    }
                    
                    return FeatureAccessDTO.builder()
                            .featureCode(feature.getCode())
                            .name(feature.getName())
                            .description(feature.getDescription())
                            .hasAccess(hasAccess)
                            .allowedOperations(allowedOperations)
                            .build();
                })
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(accessDTOs);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/ForwardingController.java">
package com.pharmacyhub.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ForwardingController
{
  @RequestMapping(value = "/{path:[^\\.]*}")
  public String forward()
  {
    return "forward:/";
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/HealthCheckController.java">
package com.pharmacyhub.controller;

import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;
import java.util.HashMap;
import java.util.Map;

@RestController
public class HealthCheckController {

    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> healthCheck() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("timestamp", System.currentTimeMillis());
        response.put("message", "PharmacyHub API is running");
        
        return ResponseEntity.ok(response);
    }
    
    @GetMapping("/api/health")
    public ResponseEntity<Map<String, Object>> apiHealthCheck() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("timestamp", System.currentTimeMillis());
        response.put("message", "PharmacyHub API is running");
        
        return ResponseEntity.ok(response);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/OtpController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.dto.UserDTO;
import com.pharmacyhub.service.OtpService;
import com.pharmacyhub.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequestMapping("/otp")
public class OtpController
{
  @Autowired
  private OtpService otpService;
  @Autowired
  private UserService userService;

  @PostMapping("/send")
  public ResponseEntity<?> sendOtp(@RequestBody UserDTO userDTO)
  {
    otpService.generateOtp(userDTO);
    return ResponseEntity.ok().build();
  }

  @PostMapping("/validate")
  public ResponseEntity<?> validateOtp(@RequestBody UserDTO userDTO)
  {
    boolean isValid = otpService.validateOtp(userDTO);
    if (isValid)
    {
      return ResponseEntity.ok().body("OTP is valid");
    }
    else
    {
      return ResponseEntity.badRequest().body("Invalid OTP");
    }
  }

  @PostMapping("/reset-user-password")
  public ResponseEntity resetUserPassword(@RequestBody UserDTO userDTO)
  {
    boolean passwordChanged = userService.forgotPassword(userDTO);

    if (passwordChanged)
    {
      return new ResponseEntity<>(HttpStatus.OK);
    }
    return new ResponseEntity<>(HttpStatus.BAD_REQUEST);
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/PermissionApiController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.security.constants.ExamPermissionConstants;
import com.pharmacyhub.service.PermissionApiService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.Arrays;
import java.util.List;
import java.util.Map;

/**
 * Controller for checking permissions for the frontend
 * Provides endpoints for the frontend application to check user permissions efficiently
 */
@RestController
@RequestMapping(APIConstants.BASE_MAPPING + "/permissions-api")
@CrossOrigin(origins = "*", maxAge = 3600)
@Tag(name = "Permissions API", description = "API for checking user permissions and accessing permission information")
public class PermissionApiController {
    private static final Logger logger = LoggerFactory.getLogger(PermissionApiController.class);
    
    private final PermissionApiService permissionApiService;
    
    public PermissionApiController(PermissionApiService permissionApiService) {
        this.permissionApiService = permissionApiService;
    }
    
    /**
     * Check a single permission
     */
    @GetMapping("/check")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Check if the user has a specific permission")
    public ResponseEntity<ApiResponse<Boolean>> checkPermission(@RequestParam String permission) {
        logger.debug("Checking permission: {}", permission);
        boolean hasPermission = permissionApiService.hasPermission(permission);
        return ResponseEntity.ok(ApiResponse.success(hasPermission));
    }
    
    /**
     * Check multiple permissions at once
     */
    @PostMapping("/check-batch")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Check multiple permissions at once")
    public ResponseEntity<ApiResponse<Map<String, Boolean>>> checkPermissions(@RequestBody List<String> permissions) {
        logger.debug("Checking {} permissions", permissions.size());
        Map<String, Boolean> result = permissionApiService.checkMultiplePermissions(
                permissions.toArray(new String[0]));
        return ResponseEntity.ok(ApiResponse.success(result));
    }
    
    /**
     * Get all exam permissions for the current user
     */
    @GetMapping("/exams")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Get all exam-related permissions for the current user")
    public ResponseEntity<ApiResponse<Map<String, Boolean>>> getExamPermissions() {
        logger.debug("Getting exam permissions");
        Map<String, Boolean> result = permissionApiService.checkExamPermissions();
        return ResponseEntity.ok(ApiResponse.success(result));
    }
    
    /**
     * Check if the user has admin privileges for exams
     */
    @GetMapping("/exams/admin")
    @PreAuthorize("isAuthenticated()")
    @Operation(summary = "Check if the user has admin privileges for exams")
    public ResponseEntity<ApiResponse<Boolean>> hasExamAdminPrivileges() {
        boolean hasAdminPrivileges = permissionApiService.hasExamAdminPrivileges();
        return ResponseEntity.ok(ApiResponse.success(hasAdminPrivileges));
    }
    
    /**
     * Get available exam permissions for documentation
     */
    @GetMapping("/exams/available")
    @Operation(summary = "Get a list of all available exam permissions")
    public ResponseEntity<ApiResponse<List<String>>> getAvailableExamPermissions() {
        // This is just to document the available permissions, 
        // so the frontend knows what to check
        List<String> examPermissions = Arrays.asList(
                ExamPermissionConstants.VIEW_EXAMS,
                ExamPermissionConstants.TAKE_EXAM,
                ExamPermissionConstants.CREATE_EXAM,
                ExamPermissionConstants.EDIT_EXAM,
                ExamPermissionConstants.DELETE_EXAM,
                ExamPermissionConstants.DUPLICATE_EXAM,
                ExamPermissionConstants.MANAGE_QUESTIONS,
                ExamPermissionConstants.PUBLISH_EXAM,
                ExamPermissionConstants.UNPUBLISH_EXAM,
                ExamPermissionConstants.ASSIGN_EXAM,
                ExamPermissionConstants.GRADE_EXAM,
                ExamPermissionConstants.VIEW_RESULTS,
                ExamPermissionConstants.EXPORT_RESULTS,
                ExamPermissionConstants.VIEW_ANALYTICS
        );
        
        return ResponseEntity.ok(ApiResponse.success(examPermissions));
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/PharmacistController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.PharmacistDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.service.PharmacistService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import com.pharmacyhub.security.annotation.RequiresPermission;
import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.ResourceType;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;


@RestController
@RequestMapping(APIConstants.BASE_MAPPING + APIConstants.PHARMACIST)
public class PharmacistController
{
  final private int connectCount = 3;

  @Autowired private PharmacistService pharmacistService;

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.CREATE)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/add-info",
          method = RequestMethod.POST
  )
  public ResponseEntity<PHUserDTO> addUserInfo(@RequestBody PharmacistDTO pharmacistDTO)
  {
    return new ResponseEntity<PHUserDTO>(pharmacistService.saveUser(pharmacistDTO), HttpStatus.OK);
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.READ)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all",
          method = RequestMethod.GET
  )
  public ResponseEntity<List<UserDisplayDTO>> getAllPharmacist()
  {
    return new ResponseEntity<>(pharmacistService.findAllUsers(), HttpStatus.OK);
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.MANAGE)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/connect",
          method = RequestMethod.POST
  )
  public ResponseEntity connectPharmacist(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    ResponseEntity responseEntity= isEligibleToConnect();
    if(responseEntity.getStatusCode() ==HttpStatus.OK)
    {
      pharmacistService.connectWith(phUserConnectionDTO);
      return new ResponseEntity<>(HttpStatus.OK);
    }
    return responseEntity;
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.READ)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-user-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity<List<UserDisplayDTO>> getAllUserConnections()
  {
    List<UserDisplayDTO> users = pharmacistService.getAllUserConnections();
    return new ResponseEntity<>(users, HttpStatus.OK);
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.MANAGE)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/disconnect",
          method = RequestMethod.PUT
  )
  public ResponseEntity disconnectPharmacist(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    pharmacistService.disconnectWith(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.READ)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/user-eligible-to-connect",
          method = RequestMethod.GET
  )
  public ResponseEntity isEligibleToConnect()
  {
    List<UserDisplayDTO> users = pharmacistService.getAllUserConnections();
    if (users.size() < connectCount)
    {
      return new ResponseEntity<>(HttpStatus.OK);
    }
    return new ResponseEntity<>(HttpStatus.CONFLICT);
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.VIEW_ALL)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity getAllConnections()
  {
    return new ResponseEntity<>(pharmacistService.getAllConnections(), HttpStatus.OK);
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.MANAGE)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-connection-state",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateStatus(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    pharmacistService.updateState(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @RequiresPermission(resource = ResourceType.PHARMACIST, operation = OperationType.MANAGE)
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-connection-notes",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateNotes(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    pharmacistService.updateNotes(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

}
</file>

<file path="src/main/java/com/pharmacyhub/controller/PharmacyManagerController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.PharmacyManagerDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.service.PharmacyManagerService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping(APIConstants.BASE_MAPPING + APIConstants.PHARMACY_MANAGER)
public class PharmacyManagerController
{
  final private int connectCount = 3;

  @Autowired
  private PharmacyManagerService pharmacyManagerService;


  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/add-info",
          method = RequestMethod.POST
  )
  public ResponseEntity<PHUserDTO> addUserInfo(@RequestBody PharmacyManagerDTO pharmacyManagerDTO)
  {
    return new ResponseEntity<PHUserDTO>(pharmacyManagerService.saveUser(pharmacyManagerDTO), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all",
          method = RequestMethod.GET
  )
  public ResponseEntity<List<UserDisplayDTO>> getAllPharmacyManagers()
  {
    return new ResponseEntity<>(pharmacyManagerService.findAllUsers(), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/connect",
          method = RequestMethod.POST
  )
  public ResponseEntity connectPharmacyManager(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    pharmacyManagerService.connectWith(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-user-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity getPharmacyManagerConnections()
  {
    List<UserDisplayDTO> users = pharmacyManagerService.getAllUserConnections();
    return new ResponseEntity<>(users, HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/disconnect",
          method = RequestMethod.PUT
  )
  public ResponseEntity disconnectPharmacyManager(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    pharmacyManagerService.disconnectWith(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/user-eligible-to-connect",
          method = RequestMethod.GET
  )
  public ResponseEntity pharmacyManagerConnectCount()
  {
    List<UserDisplayDTO> users = pharmacyManagerService.getAllUserConnections();
    if (users.size() < connectCount)
    {
      return new ResponseEntity<>(HttpStatus.OK);
    }
    return new ResponseEntity<>(HttpStatus.CONFLICT);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity getAllConnections()
  {
    return new ResponseEntity<>(pharmacyManagerService.getAllConnections(), HttpStatus.OK);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-state",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateStatus(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    pharmacyManagerService.updateState(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-connection-notes",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateNotes(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    pharmacyManagerService.updateNotes(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

}
</file>

<file path="src/main/java/com/pharmacyhub/controller/ProprietorController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.ProprietorDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.service.ProprietorService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping(APIConstants.BASE_MAPPING + APIConstants.PROPRIETOR)
public class ProprietorController
{
  final private int connectCount = 3;

  @Autowired private ProprietorService proprietorService;


  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/add-info",
          method = RequestMethod.POST
  )
  public ResponseEntity<PHUserDTO> addUserInfo(@RequestBody ProprietorDTO proprietorDTO)
  {
    return new ResponseEntity<PHUserDTO>(proprietorService.saveUser(proprietorDTO), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all",
          method = RequestMethod.GET
  )
  public ResponseEntity<List<UserDisplayDTO>> getAllProprietors()
  {
    return new ResponseEntity<>(proprietorService.findAllUsers(), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/connect",
          method = RequestMethod.POST
  )
  public ResponseEntity connectProprietor(@RequestBody PHUserConnectionDTO PHUserConnectionDTO)
  {
    proprietorService.connectWith(PHUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-user-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity getProprietorUserConnections()
  {
    List<UserDisplayDTO> users = proprietorService.getAllUserConnections();
    return new ResponseEntity<>(users, HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/disconnect",
          method = RequestMethod.PUT
  )
  public ResponseEntity disconnectProprietor(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    proprietorService.disconnectWith(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/user-eligible-to-connect",
          method = RequestMethod.GET
  )
  public ResponseEntity proprietorConnectCount()
  {
    List<UserDisplayDTO> users = proprietorService.getAllUserConnections();
    if (users.size() < connectCount)
    {
      return new ResponseEntity<>(HttpStatus.OK);
    }
    return new ResponseEntity<>(HttpStatus.CONFLICT);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity getAllConnections()
  {
    return new ResponseEntity<>(proprietorService.getAllConnections(), HttpStatus.OK);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-connection-state",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateStatus(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    proprietorService.updateState(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-connection-notes",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateNotes(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    proprietorService.updateNotes(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

}
</file>

<file path="src/main/java/com/pharmacyhub/controller/QuestionController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.controller.base.BaseController;
import com.pharmacyhub.domain.entity.Question;
import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.dto.response.QuestionResponseDTO;
import com.pharmacyhub.service.ExamService;
import com.pharmacyhub.service.QuestionService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.persistence.EntityNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.server.ResponseStatusException;

import java.util.List;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/questions")
@CrossOrigin(origins = "*", maxAge = 3600)
@Tag(name = "Questions", description = "API endpoints for question management")
public class QuestionController extends BaseController {

    private static final Logger logger = LoggerFactory.getLogger(QuestionController.class);

    private final QuestionService questionService;
    private final ExamService examService;

    public QuestionController(QuestionService questionService, ExamService examService) {
        this.questionService = questionService;
        this.examService = examService;
    }

    @GetMapping("/exam/{examId}")
    @PreAuthorize("hasAnyRole('ADMIN', 'INSTRUCTOR') or @examAccessEvaluator.canAccessExam(authentication, #examId)")
    @Operation(summary = "Get questions for an exam")
    public ResponseEntity<ApiResponse<List<QuestionResponseDTO>>> getQuestionsByExamId(@PathVariable Long examId) {
        try {
            logger.info("Fetching questions for exam ID: {}", examId);
            List<Question> questions = questionService.findByExamId(examId);
            List<QuestionResponseDTO> responseDTO = questions.stream()
                .map(this::mapToQuestionResponseDTO)
                .collect(Collectors.toList());
            logger.info("Successfully fetched {} questions for exam ID: {}", questions.size(), examId);
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (EntityNotFoundException e) {
            logger.error("Error fetching questions for exam ID {}: {}", examId, e.getMessage());
            throw new ResponseStatusException(org.springframework.http.HttpStatus.NOT_FOUND, e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Unexpected error fetching questions for exam ID {}: {}", examId, e.getMessage(), e);
            throw new ResponseStatusException(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR, "Failed to fetch questions", e);
        }
    }

    @GetMapping("/{id}")
    @PreAuthorize("hasAnyRole('ADMIN', 'INSTRUCTOR') or @questionAccessEvaluator.canAccessQuestion(authentication, #id)")
    @Operation(summary = "Get question by ID")
    public ResponseEntity<ApiResponse<QuestionResponseDTO>> getQuestionById(@PathVariable Long id) {
        try {
            logger.info("Fetching question with ID: {}", id);
            Question question = questionService.findById(id)
                    .orElseThrow(() -> new EntityNotFoundException("Question not found with ID: " + id));
            QuestionResponseDTO responseDTO = mapToQuestionResponseDTO(question);
            logger.info("Successfully fetched question with ID: {}", id);
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (EntityNotFoundException e) {
            logger.error("Error fetching question with ID {}: {}", id, e.getMessage());
            throw new ResponseStatusException(org.springframework.http.HttpStatus.NOT_FOUND, e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Unexpected error fetching question with ID {}: {}", id, e.getMessage(), e);
            throw new ResponseStatusException(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR, "Failed to fetch question", e);
        }
    }

    @GetMapping("/topic/{topic}")
    @PreAuthorize("hasAnyRole('ADMIN', 'INSTRUCTOR', 'USER')")
    @Operation(summary = "Get questions by topic")
    public ResponseEntity<ApiResponse<List<QuestionResponseDTO>>> getQuestionsByTopic(@PathVariable String topic) {
        try {
            logger.info("Fetching questions for topic: {}", topic);
            List<Question> questions = questionService.findByTopic(topic);
            List<QuestionResponseDTO> responseDTO = questions.stream()
                .map(this::mapToQuestionResponseDTO)
                .collect(Collectors.toList());
            logger.info("Successfully fetched {} questions for topic: {}", questions.size(), topic);
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (Exception e) {
            logger.error("Error fetching questions for topic {}: {}", topic, e.getMessage(), e);
            throw new ResponseStatusException(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR, "Failed to fetch questions by topic", e);
        }
    }

    @GetMapping("/difficulty/{level}")
    @PreAuthorize("hasAnyRole('ADMIN', 'INSTRUCTOR', 'USER')")
    @Operation(summary = "Get questions by difficulty level")
    public ResponseEntity<ApiResponse<List<QuestionResponseDTO>>> getQuestionsByDifficulty(@PathVariable String level) {
        try {
            logger.info("Fetching questions with difficulty level: {}", level);
            List<Question> questions = questionService.findByDifficulty(level);
            List<QuestionResponseDTO> responseDTO = questions.stream()
                .map(this::mapToQuestionResponseDTO)
                .collect(Collectors.toList());
            logger.info("Successfully fetched {} questions with difficulty level: {}", questions.size(), level);
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (IllegalArgumentException e) {
            logger.error("Invalid difficulty level {}: {}", level, e.getMessage());
            throw new ResponseStatusException(org.springframework.http.HttpStatus.BAD_REQUEST, e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Error fetching questions with difficulty level {}: {}", level, e.getMessage(), e);
            throw new ResponseStatusException(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR, "Failed to fetch questions by difficulty", e);
        }
    }

    @GetMapping("/random")
    @PreAuthorize("hasAnyRole('ADMIN', 'INSTRUCTOR', 'USER')")
    @Operation(summary = "Get random questions")
    public ResponseEntity<ApiResponse<List<QuestionResponseDTO>>> getRandomQuestions(
            @RequestParam(defaultValue = "10") int count,
            @RequestParam(required = false) String topic,
            @RequestParam(required = false) String difficulty) {
        try {
            logger.info("Fetching {} random questions with topic: {}, difficulty: {}", count, topic, difficulty);
            List<Question> questions = questionService.findRandom(count, topic, difficulty);
            List<QuestionResponseDTO> responseDTO = questions.stream()
                .map(this::mapToQuestionResponseDTO)
                .collect(Collectors.toList());
            logger.info("Successfully fetched {} random questions", questions.size());
            return ResponseEntity.ok(ApiResponse.success(responseDTO));
        } catch (IllegalArgumentException e) {
            logger.error("Invalid parameters for random questions: {}", e.getMessage());
            throw new ResponseStatusException(org.springframework.http.HttpStatus.BAD_REQUEST, e.getMessage(), e);
        } catch (Exception e) {
            logger.error("Error fetching random questions: {}", e.getMessage(), e);
            throw new ResponseStatusException(org.springframework.http.HttpStatus.INTERNAL_SERVER_ERROR, "Failed to fetch random questions", e);
        }
    }
    
    private QuestionResponseDTO mapToQuestionResponseDTO(Question question) {
        QuestionResponseDTO dto = new QuestionResponseDTO();
        dto.setId(question.getId());
        dto.setQuestionNumber(question.getQuestionNumber());
        dto.setText(question.getQuestionText());
        // Don't include the correct answer in the response for security
        dto.setExplanation(question.getExplanation());
        dto.setPoints(question.getMarks());
        
        // Map options without revealing which is correct
        if (question.getOptions() != null) {
            List<QuestionResponseDTO.OptionDTO> optionDTOs = question.getOptions().stream()
                    .map(option -> {
                        QuestionResponseDTO.OptionDTO optionDTO = new QuestionResponseDTO.OptionDTO();
                        optionDTO.setId(option.getId());
                        optionDTO.setLabel(option.getLabel());
                        optionDTO.setText(option.getText());
                        // Don't include isCorrect flag for security
                        return optionDTO;
                    })
                    .collect(Collectors.toList());
            dto.setOptions(optionDTOs);
        }
        
        return dto;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/RBACController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.security.annotation.RequiresPermission;
import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.security.dto.GroupDTO;
import com.pharmacyhub.security.dto.PermissionDTO;
import com.pharmacyhub.security.dto.RoleDTO;
import com.pharmacyhub.security.service.RBACService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/rbac")
@RequiredArgsConstructor
public class RBACController {
    private final RBACService rbacService;

    @PostMapping("/roles")
    @RequiresPermission(resource = ResourceType.ROLE, operation = OperationType.CREATE)
    public ResponseEntity<?> createRole(@RequestBody RoleDTO roleDTO) {
        return ResponseEntity.ok(rbacService.createRole(roleDTO));
    }

    @PostMapping("/permissions")
    @RequiresPermission(resource = ResourceType.PERMISSION, operation = OperationType.CREATE)
    public ResponseEntity<PermissionDTO> createPermission(@RequestBody PermissionDTO permissionDTO) {
        return ResponseEntity.ok(rbacService.createPermission(permissionDTO));
    }

    @PostMapping("/groups")
    @RequiresPermission(resource = ResourceType.GROUP, operation = OperationType.CREATE)
    public ResponseEntity<?> createGroup(@RequestBody GroupDTO groupDTO) {
        return ResponseEntity.ok(rbacService.createGroup(groupDTO));
    }

    @PostMapping("/users/{userId}/roles/{roleId}")
    @RequiresPermission(resource = ResourceType.ROLE, operation = OperationType.MANAGE)
    public ResponseEntity<?> assignRoleToUser(@PathVariable Long userId, @PathVariable Long roleId) {
        rbacService.assignRoleToUser(userId, roleId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/users/{userId}/groups/{groupId}")
    @RequiresPermission(resource = ResourceType.GROUP, operation = OperationType.MANAGE)
    public ResponseEntity<?> assignGroupToUser(@PathVariable Long userId, @PathVariable Long groupId) {
        rbacService.assignGroupToUser(userId, groupId);
        return ResponseEntity.ok().build();
    }

    @PostMapping("/users/{userId}/permissions")
    @RequiresPermission(resource = ResourceType.PERMISSION, operation = OperationType.MANAGE)
    public ResponseEntity<Void> addPermissionOverride(
            @PathVariable Long userId,
            @RequestParam String permission,
            @RequestParam boolean grant) {
        rbacService.addPermissionOverride(userId, permission, grant);
        return ResponseEntity.ok().build();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/controller/SalesmanController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.SalesmanDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.service.SalesmanService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping(APIConstants.BASE_MAPPING + APIConstants.SALESMAN)
public class SalesmanController
{
  final private int connectCount = 3;

  @Autowired private SalesmanService salesmanService;

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/add-info",
          method = RequestMethod.POST
  )
  public ResponseEntity<PHUserDTO> addUserInfo(@RequestBody SalesmanDTO salesmanDTO)
  {
    return new ResponseEntity<PHUserDTO>(salesmanService.saveUser(salesmanDTO), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all",
          method = RequestMethod.GET
  )
  public ResponseEntity<List<UserDisplayDTO>> getAllSalesman()
  {
    return new ResponseEntity<List<UserDisplayDTO>>(salesmanService.findAllUsers(), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/connect",
          method = RequestMethod.POST
  )
  public ResponseEntity connectSalesman(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    salesmanService.connectWith(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-user-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity<List<UserDisplayDTO>> getUserSalesmanConnections()
  {
    List<UserDisplayDTO> users = salesmanService.getAllUserConnections();
    return new ResponseEntity<List<UserDisplayDTO>>(users, HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/disconnect",
          method = RequestMethod.PUT
  )
  public ResponseEntity disconnectSalesman(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    salesmanService.disconnectWith(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/user-eligible-to-connect",
          method = RequestMethod.GET
  )
  public ResponseEntity isUserEligibleToConnectSalesman()
  {
    List<UserDisplayDTO> users = salesmanService.getAllUserConnections();
    if (users.size() < connectCount)
    {
      return new ResponseEntity<>(HttpStatus.OK);
    }
    return new ResponseEntity<>(HttpStatus.CONFLICT);
  }


  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all-connections",
          method = RequestMethod.GET
  )
  public ResponseEntity getAllConnections()
  {
    return new ResponseEntity<>(salesmanService.getAllConnections(), HttpStatus.OK);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-connection-state",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateStatus(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    salesmanService.updateState(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-connection-notes",
          method = RequestMethod.PUT
  )
  public ResponseEntity updateNotes(@RequestBody PHUserConnectionDTO phUserConnectionDTO)
  {
    salesmanService.updateNotes(phUserConnectionDTO);
    return new ResponseEntity<>(HttpStatus.OK);
  }

}
</file>

<file path="src/main/java/com/pharmacyhub/controller/UserController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.ChangePasswordDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.UserDTO;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@RequestMapping(APIConstants.BASE_MAPPING)
public class UserController
{
  @Autowired
  private UserService userService;

  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/add-user",
          method = RequestMethod.POST
  )
  public ResponseEntity<PHUserDTO> addUser(@RequestBody UserDTO user)
  {
    PHUserDTO userCreated = userService.saveUser(user);
    if (userCreated != null) {
        return ResponseEntity.ok(userCreated);
    }
    return ResponseEntity.status(HttpStatus.CONFLICT).body(null);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-user",
          method = RequestMethod.GET
  )
  public ResponseEntity<PHUserDTO> findUserById()
  {
    PHUserDTO user = userService.getUserCompleteInformation();

    if (user != null)
    {
      return new ResponseEntity<PHUserDTO>(user, HttpStatus.OK);
    }
    return new ResponseEntity<PHUserDTO>(user, HttpStatus.NOT_FOUND);
  }

  @PreAuthorize("hasAnyRole('ADMIN', 'SUPER_ADMIN')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/get-all-users",
          method = RequestMethod.GET
  )
  public ResponseEntity<List<User>> getAllUsers()
  {
    return new ResponseEntity<List<User>>(userService.findAll(), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/change-user-password",
          method = RequestMethod.PUT
  )
  public ResponseEntity<PHUserDTO> changeUserPassword(@RequestBody ChangePasswordDTO changePasswordDTO)
  {
    PHUserDTO updatedUser = userService.changeUserPassword(changePasswordDTO);
    if (updatedUser != null) {
      return ResponseEntity.ok(updatedUser);
    }
    return ResponseEntity.notFound().build();
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/update-user-info",
          method = RequestMethod.PUT
  )
  public ResponseEntity<PHUserDTO> updateUserInfo(@RequestBody UserDTO phUserDTO)
  {
    PHUserDTO updatedUser = userService.editUserInformation(phUserDTO);
    if (updatedUser != null) {
      return ResponseEntity.ok(updatedUser);
    }
    return ResponseEntity.notFound().build();
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/user-data",
          method = RequestMethod.GET
  )
  public ResponseEntity<UserType> getUserType(Long userId)
  {
    UserType userType = userService.getUserType(userId);
    if (userType != null) {
        return ResponseEntity.ok(userType);
    }
    return ResponseEntity.notFound().build();
  }

  @PreAuthorize("hasPermission(null, 'UPDATE_STATUS')")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/toggle-user-status",
          method = RequestMethod.GET
  )
  public ResponseEntity<Boolean> updateUserStatus()
  {
    return new ResponseEntity<Boolean>(userService.updateUserStatus(), HttpStatus.OK);
  }

  @PreAuthorize("isAuthenticated()")
  @RequestMapping(
          value = APIConstants.API_VERSION_V1 + "/is-user-registered",
          method = RequestMethod.GET
  )
  public ResponseEntity<Boolean> isUserRegistered()
  {
    User user = userService.getLoggedInUser();
    return ResponseEntity.ok(user != null && user.isRegistered());
  }

}
</file>

<file path="src/main/java/com/pharmacyhub/controller/UserProfileController.java">
package com.pharmacyhub.controller;

import com.pharmacyhub.dto.UserProfileDTO;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.service.RBACService;
import com.pharmacyhub.service.UserService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.CrossOrigin;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Set;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/users")
@CrossOrigin(origins = "*", maxAge = 3600)
public class UserProfileController {

    private static final Logger logger = LoggerFactory.getLogger(UserProfileController.class);

    @Autowired
    private UserService userService;
    
    @Autowired
    private RBACService rbacService;
    
    /**
     * Get the complete profile of the currently authenticated user including roles and permissions
     */
    @PreAuthorize("isAuthenticated()")
    @GetMapping("/profile")
    public ResponseEntity<UserProfileDTO> getUserProfile() {
        logger.debug("Received request for user profile");
        
        try {
            User currentUser = userService.getLoggedInUser();
            
            if (currentUser == null) {
                logger.warn("No authenticated user found");
                return ResponseEntity.notFound().build();
            }
            
            logger.debug("Found authenticated user: {}", currentUser.getEmailAddress());
        
            // Get user roles
            Set<Role> roles = rbacService.getUserRoles(currentUser.getId());
            Set<String> roleNames = roles.stream()
                .map(Role::getName)
                .collect(Collectors.toSet());
                
            logger.debug("User roles: {}", roleNames);
                
            // Get user permissions
            Set<Permission> permissions = rbacService.getUserEffectivePermissions(currentUser.getId());
            Set<String> permissionNames = permissions.stream()
                .map(Permission::getName)
                .collect(Collectors.toSet());
                
            logger.debug("User permissions count: {}", permissionNames.size());
        
            // Build the user profile response
            UserProfileDTO profile = UserProfileDTO.builder()
                .id(currentUser.getId())
                .emailAddress(currentUser.getEmailAddress())
                .firstName(currentUser.getFirstName())
                .lastName(currentUser.getLastName())
                .contactNumber(currentUser.getContactNumber())
                .userType(currentUser.getUserType())
                .registered(currentUser.isRegistered())
                .openToConnect(currentUser.isOpenToConnect())
                .verified(currentUser.isVerified())
                .roles(roleNames)
                .permissions(permissionNames)
                .build();
                
            logger.debug("Successfully built user profile response");
            return ResponseEntity.ok(profile);
        } catch (Exception e) {
            logger.error("Error fetching user profile: {}", e.getMessage(), e);
            throw e;
        }
    }
    
    /**
     * Health check endpoint to verify the controller is accessible
     */
    @GetMapping("/profile/health")
    public ResponseEntity<String> healthCheck() {
        return ResponseEntity.ok("User Profile API is operational");
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/entity/Exam.java">
package com.pharmacyhub.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "exams")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Exam {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank(message = "Title is required")
    @Column(nullable = false)
    private String title;

    @Column(columnDefinition = "TEXT")
    private String description;

    @NotNull(message = "Duration is required")
    @PositiveOrZero(message = "Duration must be positive or zero")
    private Integer duration; // in minutes

    @NotNull(message = "Total marks is required")
    @PositiveOrZero(message = "Total marks must be positive or zero")
    @Column(name = "total_marks")
    private Integer totalMarks;

    @NotNull(message = "Passing marks is required")
    @PositiveOrZero(message = "Passing marks must be positive or zero")
    @Column(name = "passing_marks")
    private Integer passingMarks;

    @OneToMany(mappedBy = "exam", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Question> questions = new ArrayList<>();
    
    @ElementCollection
    @CollectionTable(name = "exam_tags", joinColumns = @JoinColumn(name = "exam_id"))
    @Column(name = "tag")
    private List<String> tags = new ArrayList<>();

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ExamStatus status = ExamStatus.DRAFT;

    @Column(nullable = false)
    private boolean deleted = false;

    // Helper method to add question
    public void addQuestion(Question question) {
        questions.add(question);
        question.setExam(this);
    }

    // Helper method to remove question
    public void removeQuestion(Question question) {
        questions.remove(question);
        question.setExam(null);
    }
    
    // Helper method to add tag
    public void addTag(String tag) {
        if (tags == null) {
            tags = new ArrayList<>();
        }
        if (!tags.contains(tag)) {
            tags.add(tag);
        }
    }
    
    // Helper method to remove tag
    public void removeTag(String tag) {
        if (tags != null) {
            tags.remove(tag);
        }
    }

    public enum ExamStatus {
        DRAFT,
        PUBLISHED,
        ARCHIVED
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/entity/ExamAttempt.java">
package com.pharmacyhub.domain.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "exam_attempts")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ExamAttempt {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "exam_id", nullable = false)
    private Exam exam;
    
    @Column(name = "user_id", nullable = false)
    private String userId;
    
    @Column(name = "start_time", nullable = false)
    private LocalDateTime startTime;
    
    @Column(name = "end_time")
    private LocalDateTime endTime;
    
    @Column(name = "score")
    private Double score;
    
    @OneToMany(mappedBy = "attempt", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<UserAnswer> answers = new ArrayList<>();
    
    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private AttemptStatus status = AttemptStatus.IN_PROGRESS;
    
    @Column(nullable = false)
    private boolean deleted = false;
    
    // Helper method to add answer
    public void addAnswer(UserAnswer answer) {
        answers.add(answer);
        answer.setAttempt(this);
    }
    
    // Helper method to remove answer
    public void removeAnswer(UserAnswer answer) {
        answers.remove(answer);
        answer.setAttempt(null);
    }
    
    public enum AttemptStatus {
        IN_PROGRESS,
        COMPLETED,
        ABANDONED
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/entity/ExamResult.java">
package com.pharmacyhub.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Table(name = "exam_results")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ExamResult {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @OneToOne
    @JoinColumn(name = "attempt_id", nullable = false)
    private ExamAttempt attempt;
    
    @NotNull(message = "Score is required")
    private Double score;
    
    @NotNull(message = "Total questions is required")
    @Column(name = "total_questions")
    private Integer totalQuestions;
    
    @NotNull(message = "Correct answers is required")
    @Column(name = "correct_answers")
    private Integer correctAnswers;
    
    @NotNull(message = "Incorrect answers is required")
    @Column(name = "incorrect_answers")
    private Integer incorrectAnswers;
    
    @NotNull(message = "Unanswered questions is required")
    @Column(name = "unanswered")
    private Integer unanswered;
    
    @NotNull(message = "Time spent is required")
    @Column(name = "time_spent")
    private Integer timeSpent; // in seconds
    
    @NotNull(message = "Passing status is required")
    @Column(name = "is_passed")
    private Boolean isPassed;
    
    @Column(name = "completed_at", nullable = false)
    private LocalDateTime completedAt = LocalDateTime.now();
    
    @Column(nullable = false)
    private boolean deleted = false;
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/entity/FlaggedQuestion.java">
package com.pharmacyhub.domain.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "flagged_questions")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class FlaggedQuestion {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "attempt_id", nullable = false)
    private ExamAttempt attempt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "question_id", nullable = false)
    private Question question;
    
    @Column(nullable = false)
    private boolean deleted = false;
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/entity/Option.java">
package com.pharmacyhub.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "options")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Option {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "question_id", nullable = false)
    private Question question;

    @NotBlank(message = "Option text is required")
    @Column(name = "option_text", columnDefinition = "TEXT")
    private String text;

    @NotBlank(message = "Option label is required")
    @Column(name = "option_label", length = 1)
    private String label;

    @Column(name = "is_correct", nullable = false)
    private boolean isCorrect = false;

    @Column(nullable = false)
    private boolean deleted = false;

    // Helper method to get label for front-end
    public String getOptionLabel() {
        return this.label;
    }

    // Helper method to get text for front-end
    public String getOptionText() {
        return this.text;
    }

    // Helper method to set label
    public void setOptionLabel(String label) {
        this.label = label;
    }

    // Helper method to set text
    public void setOptionText(String text) {
        this.text = text;
    }

    // Explicit getter and setter for isCorrect to match expected method names
    public boolean getIsCorrect() {
        return this.isCorrect;
    }

    public void setIsCorrect(boolean isCorrect) {
        this.isCorrect = isCorrect;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/entity/Question.java">
package com.pharmacyhub.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Entity
@Table(name = "questions")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class Question
{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "exam_id", nullable = false)
    private Exam exam;

    @NotNull(message = "Question number is required")
    @Column(name = "question_number")
    private Integer questionNumber;

    @NotBlank(message = "Question text is required")
    @Column(name = "question_text", columnDefinition = "TEXT")
    private String questionText;

    @OneToMany(mappedBy = "question", cascade = CascadeType.ALL, orphanRemoval = true)
    private List<Option> options = new ArrayList<>();

    @NotBlank(message = "Correct answer is required")
    @Column(name = "correct_answer", length = 1)
    private String correctAnswer;

    @Column(columnDefinition = "TEXT")
    private String explanation;

    @PositiveOrZero(message = "Marks must be positive or zero")
    private Integer marks = 1;

    @Enumerated(EnumType.STRING)
    @Column(name = "question_type")
    private QuestionType type = QuestionType.MCQ;
    
    @Column(name = "topic")
    private String topic;
    
    @Column(name = "difficulty")
    private String difficulty;

    @Column(nullable = false)
    private boolean deleted = false;

    // Helper method to add option
    public void addOption(Option option)
    {
        options.add(option);
        option.setQuestion(this);
    }

    // Helper method to remove option
    public void removeOption(Option option)
    {
        options.remove(option);
        option.setQuestion(null);
    }

    public enum QuestionType
    {
        MCQ,
        TRUE_FALSE
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/entity/UserAnswer.java">
package com.pharmacyhub.domain.entity;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Entity
@Table(name = "user_answers")
@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class UserAnswer {
    
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "attempt_id", nullable = false)
    private ExamAttempt attempt;
    
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "question_id", nullable = false)
    private Question question;
    
    @Column(name = "selected_option_id", length = 1)
    private String selectedOptionId;
    
    @NotNull(message = "Time spent is required")
    @PositiveOrZero(message = "Time spent must be positive or zero")
    @Column(name = "time_spent")
    private Integer timeSpent = 0; // in seconds
    
    @Column(nullable = false)
    private boolean deleted = false;
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/repository/ExamAttemptRepository.java">
package com.pharmacyhub.domain.repository;

import com.pharmacyhub.domain.entity.ExamAttempt;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

/**
 * Repository for accessing ExamAttempt entities
 */
@Repository
public interface ExamAttemptRepository extends JpaRepository<ExamAttempt, Long> {
    
    /**
     * Find all non-deleted attempts by user ID
     */
    @Query("SELECT a FROM ExamAttempt a WHERE a.userId = ?1 AND a.deleted = false ORDER BY a.startTime DESC")
    List<ExamAttempt> findByUserId(String userId);
    
    /**
     * Find all non-deleted attempts by exam ID and user ID
     */
    @Query("SELECT a FROM ExamAttempt a WHERE a.exam.id = ?1 AND a.userId = ?2 AND a.deleted = false ORDER BY a.startTime DESC")
    List<ExamAttempt> findByExamIdAndUserId(Long examId, String userId);
    
    /**
     * Find a specific non-deleted attempt by ID
     */
    @Query("SELECT a FROM ExamAttempt a WHERE a.id = ?1 AND a.deleted = false")
    Optional<ExamAttempt> findByIdAndNotDeleted(Long id);
    
    /**
     * Find the most recent in-progress attempt by user ID and exam ID
     */
    @Query("SELECT a FROM ExamAttempt a WHERE a.exam.id = ?1 AND a.userId = ?2 AND a.status = ?3 AND a.deleted = false " +
           "ORDER BY a.startTime DESC")
    Optional<ExamAttempt> findFirstByExamIdAndUserIdAndStatusAndDeletedFalse(
            Long examId, String userId, ExamAttempt.AttemptStatus status);
    
    /**
     * Count all completed attempts for a specific exam
     */
    @Query("SELECT COUNT(a) FROM ExamAttempt a WHERE a.exam.id = ?1 AND a.status = ?2 AND a.deleted = false")
    Long countByExamIdAndStatusAndDeletedFalse(Long examId, ExamAttempt.AttemptStatus status);
    
    /**
     * Calculate completion rate for a specific exam (percentage of completed attempts)
     */
    @Query("SELECT COUNT(a) FROM ExamAttempt a WHERE a.exam.id = ?1 AND a.status = 'COMPLETED' AND a.deleted = false")
    long countCompletedAttemptsByExamId(Long examId);
    
    /**
     * Calculate average score for a specific exam
     */
    @Query("SELECT AVG(r.score) FROM ExamResult r JOIN r.attempt a WHERE a.exam.id = ?1 AND a.deleted = false")
    Double getAverageScoreByExamId(Long examId);
    
    /**
     * Count distinct user IDs with at least one attempt
     */
    @Query("SELECT COUNT(DISTINCT a.userId) FROM ExamAttempt a WHERE a.deleted = false")
    long countDistinctUserIds();
    
    /**
     * Count unique users who have made attempts since a specific date
     */
    @Query("SELECT COUNT(DISTINCT a.userId) FROM ExamAttempt a WHERE a.startTime >= :since AND a.deleted = false")
    long countUniqueUsersSince(@Param("since") LocalDateTime since);
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/repository/ExamRepository.java">
package com.pharmacyhub.domain.repository;

import com.pharmacyhub.domain.entity.Exam;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface ExamRepository extends JpaRepository<Exam, Long> {
    
    /**
     * Find all non-deleted exams
     */
    @Query("SELECT e FROM Exam e WHERE e.deleted = false")
    List<Exam> findByDeletedFalse();
    
    /**
     * Find all published and non-deleted exams
     */
    @Query("SELECT e FROM Exam e WHERE e.deleted = false AND e.status = ?1")
    List<Exam> findByStatusAndDeletedFalse(Exam.ExamStatus status);
    
    /**
     * Find a non-deleted exam by ID
     */
    @Query("SELECT e FROM Exam e WHERE e.deleted = false AND e.id = ?1")
    Optional<Exam> findByIdAndDeletedFalse(Long id);
    
    /**
     * Find a non-deleted exam by ID (aliased method)
     */
    @Query("SELECT e FROM Exam e WHERE e.deleted = false AND e.id = ?1")
    Optional<Exam> findByIdAndNotDeleted(Long id);
    
    /**
     * Find all non-deleted exams by status
     */
    @Query("SELECT e FROM Exam e WHERE e.deleted = false AND e.status = ?1")
    List<Exam> findByStatus(Exam.ExamStatus status);
    
    /**
     * Find a non-deleted exam by ID and status
     */
    @Query("SELECT e FROM Exam e WHERE e.deleted = false AND e.id = ?1 AND e.status = ?2")
    Optional<Exam> findByIdAndStatus(Long id, Exam.ExamStatus status);
    
    /**
     * Check if a non-deleted exam with the given title exists
     */
    @Query("SELECT COUNT(e) > 0 FROM Exam e WHERE e.title = ?1 AND e.deleted = false")
    boolean existsByTitle(String title);
    
    /**
     * Count exams by status
     */
    @Query("SELECT COUNT(e) FROM Exam e WHERE e.status = ?1 AND e.deleted = false")
    long countByStatusAndDeletedFalse(Exam.ExamStatus status);
    
    /**
     * Get average duration of all published exams
     */
    @Query("SELECT AVG(e.duration) FROM Exam e WHERE e.status = 'PUBLISHED' AND e.deleted = false")
    Double getAverageDuration();
    
    /**
     * Find all non-deleted exams that have a specific tag
     */
    @Query("SELECT e FROM Exam e JOIN e.tags t WHERE t = ?1 AND e.deleted = false")
    List<Exam> findByTagsContainingAndDeletedFalse(String tag);
    
    /**
     * Find all non-deleted exams that have all the given tags
     */
    @Query("SELECT e FROM Exam e JOIN e.tags t WHERE t IN ?1 AND e.deleted = false GROUP BY e HAVING COUNT(DISTINCT t) = ?2")
    List<Exam> findByTagsContainingAllAndDeletedFalse(List<String> tags, long tagCount);
    
    /**
     * Get active exams (all non-deleted)
     */
    @Query("SELECT e FROM Exam e WHERE e.deleted = false")
    List<Exam> findAllActive();
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/repository/ExamResultRepository.java">
package com.pharmacyhub.domain.repository;

import com.pharmacyhub.domain.entity.ExamResult;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface ExamResultRepository extends JpaRepository<ExamResult, Long> {
    
    @Query("SELECT r FROM ExamResult r WHERE r.deleted = false AND r.attempt.id = :attemptId")
    Optional<ExamResult> findByAttemptId(Long attemptId);
    
    @Query("SELECT AVG(r.correctAnswers * 1.0 / r.totalQuestions) FROM ExamResult r WHERE r.deleted = false")
    Double getAverageCompletionRate();
    
    /**
     * Get the success rate (percentage of passes) for a specific exam
     */
    @Query("SELECT (COUNT(r) * 1.0 / NULLIF((SELECT COUNT(r2) FROM ExamResult r2 " +
           "JOIN r2.attempt a2 WHERE a2.exam.id = :examId AND r2.deleted = false), 0)) * 100 " +
           "FROM ExamResult r JOIN r.attempt a " +
           "WHERE a.exam.id = :examId AND r.isPassed = true AND r.deleted = false")
    Double getSuccessRateByExamId(Long examId);
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/repository/FlaggedQuestionRepository.java">
package com.pharmacyhub.domain.repository;

import com.pharmacyhub.domain.entity.FlaggedQuestion;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Modifying;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

/**
 * Repository for accessing FlaggedQuestion entities
 */
@Repository
public interface FlaggedQuestionRepository extends JpaRepository<FlaggedQuestion, Long> {
    
    /**
     * Find all flagged questions for a specific attempt
     */
    List<FlaggedQuestion> findByAttemptIdAndDeletedFalse(Long attemptId);
    
    /**
     * Find a specific flagged question by attempt ID and question ID
     */
    Optional<FlaggedQuestion> findByAttemptIdAndQuestionIdAndDeletedFalse(Long attemptId, Long questionId);
    
    /**
     * Check if a question is flagged for a specific attempt
     */
    default boolean existsByAttemptIdAndQuestionId(Long attemptId, Long questionId) {
        return findByAttemptIdAndQuestionIdAndDeletedFalse(attemptId, questionId).isPresent();
    }
    
    /**
     * Get all question IDs flagged for an attempt
     */
    @Query("SELECT f.question.id FROM FlaggedQuestion f WHERE f.attempt.id = ?1 AND f.deleted = false")
    List<Long> findQuestionIdsByAttemptId(Long attemptId);
    
    /**
     * Delete a flagged question by attempt and question IDs
     */
    @Modifying
    @Transactional
    @Query("UPDATE FlaggedQuestion f SET f.deleted = true WHERE f.attempt.id = ?1 AND f.question.id = ?2")
    void deleteByAttemptIdAndQuestionId(Long attemptId, Long questionId);
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/repository/OptionRepository.java">
package com.pharmacyhub.domain.repository;

import com.pharmacyhub.domain.entity.Option;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface OptionRepository extends JpaRepository<Option, Long>
{

    @Query("SELECT o FROM Option o WHERE o.question.id = :questionId AND o.deleted = false ORDER BY o.label")
    List<Option> findByQuestionId(Long questionId);

    @Query("SELECT o FROM Option o WHERE o.deleted = false AND o.id = :id")
    Optional<Option> findByIdAndNotDeleted(Long id);

    @Query("SELECT o FROM Option o WHERE o.question.id = :questionId AND o.isCorrect = true AND o.deleted = false")
    Optional<Option> findCorrectOptionByQuestionId(Long questionId);

    @Query("SELECT COUNT(o) FROM Option o WHERE o.question.id = :questionId AND o.deleted = false")
    Long countByQuestionId(Long questionId);

    @Query("SELECT CASE WHEN COUNT(o) > 0 THEN true ELSE false END FROM Option o " +
            "WHERE o.question.id = :questionId AND o.label = :label AND o.deleted = false")
    boolean existsByQuestionIdAndLabel(Long questionId, String label);
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/repository/QuestionRepository.java">
package com.pharmacyhub.domain.repository;

import com.pharmacyhub.domain.entity.Question;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface QuestionRepository extends JpaRepository<Question, Long> {

    @Query("SELECT q FROM Question q WHERE q.exam.id = :examId AND q.deleted = false ORDER BY q.questionNumber")
    List<Question> findByExamId(Long examId);
    
    /**
     * Find all questions for an exam that are not deleted
     */
    @Query("SELECT q FROM Question q WHERE q.exam.id = :examId AND q.deleted = false ORDER BY q.questionNumber")
    List<Question> findByExamIdAndDeletedFalse(Long examId);

    @Query("SELECT q FROM Question q WHERE q.deleted = false AND q.id = :id")
    Optional<Question> findByIdAndNotDeleted(Long id);
    
    /**
     * Find question by ID and not deleted
     */
    @Query("SELECT q FROM Question q WHERE q.deleted = false AND q.id = :id")
    Optional<Question> findById(Long id);

    @Query("SELECT COALESCE(MAX(q.questionNumber), 0) FROM Question q WHERE q.exam.id = :examId")
    Integer findMaxQuestionNumberByExamId(Long examId);

    @Query("SELECT COUNT(q) FROM Question q WHERE q.exam.id = :examId AND q.deleted = false")
    Long countByExamId(Long examId);
    
    /**
     * Count questions for an exam that are not deleted
     */
    @Query("SELECT COUNT(q) FROM Question q WHERE q.exam.id = :examId AND q.deleted = false")
    Integer countByExamIdAndDeletedFalse(Long examId);
    
    /**
     * Find questions by topic
     */
    @Query("SELECT q FROM Question q WHERE q.deleted = false AND LOWER(q.topic) = LOWER(:topic) ORDER BY q.id")
    List<Question> findByTopic(@Param("topic") String topic);
    
    /**
     * Find questions by difficulty level
     */
    @Query("SELECT q FROM Question q WHERE q.deleted = false AND LOWER(q.difficulty) = LOWER(:difficulty) ORDER BY q.id")
    List<Question> findByDifficulty(@Param("difficulty") String difficulty);
    
    /**
     * Find random questions with optional filters
     */
    @Query("SELECT q FROM Question q WHERE q.deleted = false " +
           "AND (:topic IS NULL OR LOWER(q.topic) = LOWER(:topic)) " +
           "AND (:difficulty IS NULL OR LOWER(q.difficulty) = LOWER(:difficulty)) " +
           "ORDER BY RAND() LIMIT :count")
    List<Question> findRandom(@Param("count") int count, 
                             @Param("topic") String topic, 
                             @Param("difficulty") String difficulty);
}
</file>

<file path="src/main/java/com/pharmacyhub/domain/repository/UserAnswerRepository.java">
package com.pharmacyhub.domain.repository;

import com.pharmacyhub.domain.entity.UserAnswer;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface UserAnswerRepository extends JpaRepository<UserAnswer, Long> {
    
    @Query("SELECT a FROM UserAnswer a WHERE a.deleted = false AND a.attempt.id = :attemptId")
    List<UserAnswer> findByAttemptId(Long attemptId);
    
    @Query("SELECT a FROM UserAnswer a WHERE a.deleted = false AND a.attempt.id = :attemptId AND a.question.id = :questionId")
    Optional<UserAnswer> findByAttemptIdAndQuestionId(Long attemptId, Long questionId);
    
    @Query("SELECT COUNT(a) FROM UserAnswer a JOIN a.question q " +
           "WHERE a.deleted = false AND a.attempt.id = :attemptId " +
           "AND a.selectedOptionId = q.correctAnswer")
    Long countCorrectAnswersByAttemptId(Long attemptId);
    
    @Query("SELECT COUNT(a) FROM UserAnswer a " +
           "WHERE a.deleted = false AND a.attempt.id = :attemptId " +
           "AND a.selectedOptionId IS NOT NULL")
    Long countAnsweredQuestionsByAttemptId(Long attemptId);
    
    @Query("SELECT SUM(a.timeSpent) FROM UserAnswer a " +
           "WHERE a.deleted = false AND a.attempt.id = :attemptId")
    Integer sumTimeSpentByAttemptId(Long attemptId);
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/BaseDTO.java">
package com.pharmacyhub.dto;

import com.fasterxml.jackson.annotation.JsonInclude;

/**
 * Base interface for all DTOs
 * Provides common behavior and serves as a marker interface
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public interface BaseDTO {
    // Marker interface for all DTOs
    // Common methods can be added here
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/ChangePasswordDTO.java">
package com.pharmacyhub.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ChangePasswordDTO
{
  private Long id;
  private String emailAddress;
  private String currentPassword;
  private String newPassword;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/display/ConnectionDisplayDTO.java">
package com.pharmacyhub.dto.display;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.dto.UserDTO;
import com.pharmacyhub.entity.Pharmacist;
import com.pharmacyhub.entity.PharmacyManager;
import com.pharmacyhub.entity.Proprietor;
import com.pharmacyhub.entity.Salesman;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ConnectionDisplayDTO
{
  private Long id;
  private StateEnum state;
  private String notes;
  private Date createdAt;
  private Date updatedAt;
  private UserDTO user;
  
  private Pharmacist pharmacist;
  private Proprietor proprietor;
  private Salesman salesman;
  private PharmacyManager pharmacyManager;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/display/UserDisplayDTO.java">
package com.pharmacyhub.dto.display;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.dto.PharmacistDTO;
import com.pharmacyhub.dto.PharmacyManagerDTO;
import com.pharmacyhub.dto.ProprietorDTO;
import com.pharmacyhub.dto.SalesmanDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class UserDisplayDTO
{
  private String firstName;
  private String lastName;
  private boolean connected;
  private PharmacistDTO pharmacist;
  private ProprietorDTO proprietor;
  private SalesmanDTO salesman;
  private PharmacyManagerDTO pharmacyManager;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/display/UserResponseDTO.java">
package com.pharmacyhub.dto.display;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.dto.BaseDTO;
import com.pharmacyhub.dto.PharmacistDTO;
import com.pharmacyhub.dto.ProprietorDTO;
import com.pharmacyhub.dto.SalesmanDTO;
import com.pharmacyhub.dto.PharmacyManagerDTO;
import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * User response DTO for displaying user information
 * Contains all user properties that should be exposed to clients
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class UserResponseDTO implements BaseDTO {
    private Long id;
    private String firstName;
    private String lastName;
    private String emailAddress;
    private String contactNumber;
    private UserType userType;
    private boolean active;
    private boolean openToConnect;
    private boolean registered;
    
    // Associated entities - only included when appropriate
    private PharmacistDTO pharmacist;
    private ProprietorDTO proprietor;
    private SalesmanDTO salesman;
    private PharmacyManagerDTO pharmacyManager;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/ExamAttemptDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.dto.UserAnswerDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExamAttemptDTO
{

    private Long id;
    private Long examId;
    private String userId;
    private String startTime;
    private List<UserAnswerDTO> answers;
    private String status;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/ExamDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.domain.entity.Exam;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class ExamDTO {
    private Long id;
    private String title;
    private String description;
    private Integer duration;
    private Integer totalMarks;
    private Integer passingMarks;
    private Exam.ExamStatus status;
    private List<QuestionDTO> questions = new ArrayList<>();
    
    @Getter
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    public static class QuestionDTO {
        private Long id;
        private Integer questionNumber;
        private String questionText;
        private List<OptionDTO> options = new ArrayList<>();
        private String correctAnswer;
        private String explanation;
        private Integer marks;
    }
    
    @Getter
    @Setter
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OptionDTO {
        private Long id;
        private String optionKey;
        private String optionText;
        private Boolean isCorrect;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/ExamResultDTO.java">
package com.pharmacyhub.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.List;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExamResultDTO {
    
    private Long examId;
    private String examTitle;
    private Double score;
    private Integer totalMarks;
    private Integer passingMarks;
    private Boolean isPassed;
    private Integer timeSpent;
    private List<QuestionResultDTO> questionResults;
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    public static class QuestionResultDTO {
        private Long questionId;
        private String questionText;
        private String userAnswerId;
        private String correctAnswerId;
        private Boolean isCorrect;
        private String explanation;
        private Integer points;
        private Integer earnedPoints;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/ExamStatsDTO.java">
package com.pharmacyhub.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExamStatsDTO {
    
    private Integer totalPapers;
    private Integer avgDuration;
    private Integer completionRate;
    private Integer activeUsers;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/FlaggedQuestionDTO.java">
package com.pharmacyhub.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FlaggedQuestionDTO {
    private Long attemptId;
    private Long questionId;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/LoggedInUserDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import java.util.List;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class LoggedInUserDTO {
  private Long id;
  private String emailAddress;
  private String firstName;
  private String lastName;
  private boolean openToConnect;
  private boolean registered;
  private String jwtToken;
  private UserType userType;
  private List<String> roles;
  private List<String> permissions;
  
  // Explicit getters and setters for proper serialization
  public Long getId() {
    return id;
  }
  
  public void setId(Long id) {
    this.id = id;
  }
  
  public String getEmailAddress() {
    return emailAddress;
  }
  
  public void setEmailAddress(String emailAddress) {
    this.emailAddress = emailAddress;
  }
  
  public String getFirstName() {
    return firstName;
  }
  
  public void setFirstName(String firstName) {
    this.firstName = firstName;
  }
  
  public String getLastName() {
    return lastName;
  }
  
  public void setLastName(String lastName) {
    this.lastName = lastName;
  }
  
  public boolean isOpenToConnect() {
    return openToConnect;
  }
  
  public void setOpenToConnect(boolean openToConnect) {
    this.openToConnect = openToConnect;
  }
  
  public boolean isRegistered() {
    return registered;
  }
  
  public void setRegistered(boolean registered) {
    this.registered = registered;
  }
  
  public String getJwtToken() {
    return jwtToken;
  }
  
  public void setJwtToken(String jwtToken) {
    this.jwtToken = jwtToken;
  }
  
  public UserType getUserType() {
    return userType;
  }
  
  public void setUserType(UserType userType) {
    this.userType = userType;
  }
  
  public List<String> getRoles() {
    return roles;
  }
  
  public void setRoles(List<String> roles) {
    this.roles = roles;
  }
  
  public List<String> getPermissions() {
    return permissions;
  }
  
  public void setPermissions(List<String> permissions) {
    this.permissions = permissions;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/OptionDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.domain.entity.Option;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;

@Getter
@Setter
@NoArgsConstructor
@AllArgsConstructor
public class OptionDTO {
    private Long id;
    private String optionText;
    private String optionLabel;

    public static OptionDTO fromEntity(Option option) {
        OptionDTO dto = new OptionDTO();
        dto.setId(option.getId());
        dto.setOptionText(option.getOptionText());
        dto.setOptionLabel(option.getOptionLabel());
        return dto;
    }

    public static Option toEntity(OptionDTO dto) {
        Option option = new Option();
        option.setId(dto.getId());
        option.setOptionText(dto.getOptionText());
        option.setOptionLabel(dto.getOptionLabel());
        return option;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/PharmacistDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class PharmacistDTO implements PHUserDTO
{
  private Long id;
  private String categoryAvailable;
  private String licenseDuration;
  private String experience;
  private String city;
  private String location;
  private String universityName;
  private String batch;
  private String contactNumber;
  private String categoryProvince;
  private boolean openToConnect;
  private boolean registered;
  private String firstName;
  private String lastName;
  private String emailAddress;
  
  @Override
  public UserType getUserType() {
    return UserType.PHARMACIST;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/PharmacyManagerDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class PharmacyManagerDTO implements PHUserDTO
{
  private Long id;
  private String contactNumber;
  private String pharmacyName;
  private String city;
  private String location;
  private String experience;
  private String universityName;
  private String batch;
  private boolean openToConnect;
  private boolean registered;
  private String firstName;
  private String lastName;
  private String emailAddress;
  
  @Override
  public UserType getUserType() {
    return UserType.PHARMACY_MANAGER;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/PHUserConnectionDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.constants.StateEnum;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class PHUserConnectionDTO
{
  private long id;
  private long connectWith;
  private StateEnum state;
  private String notes;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/PHUserDTO.java">
package com.pharmacyhub.dto;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.entity.enums.UserType;
import lombok.Builder;
import lombok.Data;

/**
 * Common interface for all user DTOs.
 */
@JsonInclude(JsonInclude.Include.NON_NULL)
public interface PHUserDTO {
    Long getId();
    String getEmailAddress();
    String getFirstName();
    String getLastName();
    String getContactNumber();
    UserType getUserType();
    boolean isOpenToConnect();
    boolean isRegistered();
    
    /**
     * Builder implementation for creating PHUserDTO instances.
     */
    @Builder
    @Data
    class Impl implements PHUserDTO {
        private Long id;
        private String emailAddress;
        private String firstName;
        private String lastName;
        private String contactNumber;
        private UserType userType;
        private boolean openToConnect;
        private boolean registered;
    }
    
    /**
     * Static builder method.
     */
    static Impl.ImplBuilder builder() {
        return new Impl.ImplBuilder();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/ProprietorDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class ProprietorDTO implements PHUserDTO
{
  private Long id;
  private String categoryRequired;
  private String licenseDuration;
  private String experienced;
  private String pharmacyName;
  private String city;
  private String location;
  private String contactNumber;
  private String categoryProvince;
  private boolean openToConnect;
  private boolean registered;
  private String firstName;
  private String lastName;
  private String emailAddress;
  
  @Override
  public UserType getUserType() {
    return UserType.PROPRIETOR;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/ReportingUserDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;

public class ReportingUserDTO extends UserDTO
{
  private String contactNumber;
  
  @Override
  public UserType getUserType() {
    return super.getUserType();
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/request/AnswerSubmissionDTO.java">
package com.pharmacyhub.dto.request;

import com.pharmacyhub.dto.BaseDTO;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for submitting an answer to a question
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AnswerSubmissionDTO implements BaseDTO {
    
    @NotNull(message = "Question ID is required")
    private Long questionId;
    
    private String selectedOptionId;
    
    @NotNull(message = "Time spent is required")
    @PositiveOrZero(message = "Time spent must be zero or positive")
    private Integer timeSpent; // in seconds
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/request/ExamFilterRequestDTO.java">
package com.pharmacyhub.dto.request;

import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Request DTO for filtering exams
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class ExamFilterRequestDTO implements BaseDTO {
    
    private String type; // MODEL, PAST, SUBJECT, PRACTICE
    private String difficulty; // EASY, MEDIUM, HARD
    private String topic; // Subject or category
    private Boolean isPremium;
    private Integer maxDuration;
    private String searchTerm;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/request/ExamRequestDTO.java">
package com.pharmacyhub.dto.request;

import com.pharmacyhub.domain.entity.Exam;
import com.pharmacyhub.dto.BaseDTO;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * Request DTO for creating or updating an exam
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ExamRequestDTO implements BaseDTO {
    
    private Long id;
    
    @NotBlank(message = "Title is required")
    private String title;
    
    private String description;
    
    @NotNull(message = "Duration in minutes is required")
    @Min(value = 1, message = "Duration must be at least 1 minute")
    private Integer duration;
    
    @NotNull(message = "Total marks is required")
    @Min(value = 1, message = "Total marks must be at least 1")
    private Integer totalMarks;
    
    @NotNull(message = "Passing marks is required")
    @Min(value = 0, message = "Passing marks cannot be negative")
    private Integer passingMarks;
    
    private Exam.ExamStatus status = Exam.ExamStatus.DRAFT;
    
    private List<String> tags = new ArrayList<>();
    
    @Valid
    private List<QuestionDTO> questions = new ArrayList<>();
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class QuestionDTO {
        private Long id;
        
        @NotNull(message = "Question number is required")
        private Integer questionNumber;
        
        @NotBlank(message = "Question text is required")
        private String questionText;
        
        @Valid
        private List<OptionDTO> options = new ArrayList<>();
        
        private String correctAnswer;
        private String explanation;
        
        @NotNull(message = "Marks value is required")
        @Min(value = 1, message = "Marks must be at least 1")
        private Integer marks;
    }
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public static class OptionDTO {
        private Long id;
        
        @NotBlank(message = "Option key is required")
        private String optionKey;
        
        @NotBlank(message = "Option text is required")
        private String optionText;
        
        private Boolean isCorrect = false;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/request/JsonExamUploadRequestDTO.java">
package com.pharmacyhub.dto.request;

import com.pharmacyhub.domain.entity.Exam;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.Data;
import java.util.List;

@Data
public class JsonExamUploadRequestDTO {
    @NotBlank(message = "Title is required")
    private String title;
    
    private String description;
    
    @NotNull(message = "Duration is required")
    @PositiveOrZero(message = "Duration must be positive or zero")
    private Integer duration; // in minutes
    
    @PositiveOrZero(message = "Passing marks must be positive or zero")
    private Integer passingMarks;
    
    private Exam.ExamStatus status = Exam.ExamStatus.DRAFT;
    
    private List<String> tags;
    
    // The JSON content as a string (will be parsed by the service)
    @NotBlank(message = "JSON content is required")
    private String jsonContent;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/request/LoginRequestDTO.java">
package com.pharmacyhub.dto.request;

import com.pharmacyhub.dto.BaseDTO;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Login request DTO
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequestDTO implements BaseDTO {
    
    @NotBlank(message = "Email address is required")
    @Email(message = "Please provide a valid email address")
    private String emailAddress;
    
    @NotBlank(message = "Password is required")
    private String password;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/request/UserCreateRequestDTO.java">
package com.pharmacyhub.dto.request;

import com.pharmacyhub.dto.BaseDTO;
import com.pharmacyhub.entity.enums.UserType;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Request DTO for creating a new user
 * Contains validation rules for user properties
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreateRequestDTO implements BaseDTO {
    
    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;
    
    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;
    
    @NotBlank(message = "Email address is required")
    @Email(message = "Email address must be valid")
    private String emailAddress;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters")
    @Pattern(
        regexp = "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=!])(?=\\S+$).{8,}$",
        message = "Password must contain at least one digit, one lowercase, one uppercase, one special character, and no whitespace"
    )
    private String password;
    
    @Pattern(regexp = "^\\+?[0-9]{10,15}$", message = "Contact number must be valid")
    private String contactNumber;
    
    private UserType userType;
    private boolean openToConnect;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/request/UserUpdateRequestDTO.java">
package com.pharmacyhub.dto.request;

import com.pharmacyhub.dto.BaseDTO;
import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Request DTO for updating user information
 * Contains validation rules for user properties that can be updated
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserUpdateRequestDTO implements BaseDTO {
    
    private Long id;
    
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;
    
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;
    
    @Email(message = "Email address must be valid")
    private String emailAddress;
    
    @Pattern(regexp = "^\\+?[0-9]{10,15}$", message = "Contact number must be valid")
    private String contactNumber;
    
    private boolean openToConnect;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/ApiError.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashMap;
import java.util.Map;

/**
 * Standard error response object
 * Used within ApiResponse to provide consistent error information
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiError {
    private int status;
    private String message;
    private Map<String, Object> details;
    
    public ApiError(int status, String message) {
        this.status = status;
        this.message = message;
    }
    
    /**
     * Add details to the error
     */
    public ApiError addDetail(String key, Object value) {
        if (this.details == null) {
            this.details = new HashMap<>();
        }
        this.details.put(key, value);
        return this;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/ApiErrorResponse.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonFormat;
import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Standard error response structure for all API errors
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiErrorResponse {
    private int status;
    private String errorCode;
    private String message;
    
    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = "yyyy-MM-dd HH:mm:ss")
    private LocalDateTime timestamp;
    
    private String path;
    
    @Builder.Default
    private Map<String, Object> details = new HashMap<>();
    
    /**
     * Add detail to the error response
     */
    public ApiErrorResponse addDetail(String key, Object value) {
        if (this.details == null) {
            this.details = new HashMap<>();
        }
        this.details.put(key, value);
        return this;
    }
    
    /**
     * Create a new error response builder with the current timestamp
     */
    public static ApiErrorResponseBuilder builder() {
        return new ApiErrorResponseBuilder().timestamp(LocalDateTime.now());
    }
    
    /**
     * Create a simple error response with just status and message
     */
    public static ApiErrorResponse of(int status, String errorCode, String message) {
        return ApiErrorResponse.builder()
                .status(status)
                .errorCode(errorCode)
                .message(message)
                .build();
    }
    
    /**
     * Create a simple error response with status, message, and path
     */
    public static ApiErrorResponse of(int status, String errorCode, String message, String path) {
        return ApiErrorResponse.builder()
                .status(status)
                .errorCode(errorCode)
                .message(message)
                .path(path)
                .build();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/ApiResponse.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Standard API response wrapper for all endpoints
 * Provides consistent structure for all API responses
 *
 * @param <T> Type of data being returned
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ApiResponse<T> {
    private T data;
    private boolean success;
    private int status;
    private LocalDateTime timestamp;
    private ApiError error;
    
    @Builder.Default
    private Map<String, Object> metadata = new HashMap<>();
    
    /**
     * Creates a success response with the provided data
     */
    public static <T> ApiResponse<T> success(T data) {
        return ApiResponse.<T>builder()
                .data(data)
                .success(true)
                .status(200)
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * Creates a success response with the provided data and status code
     */
    public static <T> ApiResponse<T> success(T data, int status) {
        return ApiResponse.<T>builder()
                .data(data)
                .success(true)
                .status(status)
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * Creates a success response with the provided data, status code, and metadata
     */
    public static <T> ApiResponse<T> success(T data, int status, Map<String, Object> metadata) {
        return ApiResponse.<T>builder()
                .data(data)
                .success(true)
                .status(status)
                .metadata(metadata)
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * Creates an error response with the provided status and message
     */
    public static <T> ApiResponse<T> error(int status, String message) {
        return ApiResponse.<T>builder()
                .error(new ApiError(status, message))
                .success(false)
                .status(status)
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * Creates an error response with the provided status, message, and additional details
     */
    public static <T> ApiResponse<T> error(int status, String message, Map<String, Object> details) {
        ApiError error = new ApiError(status, message);
        error.setDetails(details);
        
        return ApiResponse.<T>builder()
                .error(error)
                .success(false)
                .status(status)
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * Creates an error response with a pre-constructed ApiError object
     */
    public static <T> ApiResponse<T> error(ApiError error) {
        return ApiResponse.<T>builder()
                .error(error)
                .success(false)
                .status(error.getStatus())
                .timestamp(LocalDateTime.now())
                .build();
    }
    
    /**
     * Add metadata to the response
     */
    public ApiResponse<T> addMetadata(String key, Object value) {
        if (this.metadata == null) {
            this.metadata = new HashMap<>();
        }
        this.metadata.put(key, value);
        return this;
    }
    
    // Maintaining backward compatibility with the "of" methods
    
    /**
     * Creates a success response with the provided data
     */
    public static <T> ApiResponse<T> of(T data) {
        return success(data);
    }
    
    /**
     * Creates a success response with the provided data and status code
     */
    public static <T> ApiResponse<T> of(T data, int status) {
        return success(data, status);
    }
    
    /**
     * Creates a success response with the provided data, status code, and metadata
     */
    public static <T> ApiResponse<T> of(T data, int status, Map<String, Object> metadata) {
        return success(data, status, metadata);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/AuthResponseDTO.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Response DTO for authenticated user information that matches frontend's AuthResponse structure
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class AuthResponseDTO implements BaseDTO {
    private UserResponseDTO user;
    private TokensDTO tokens;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/ExamAttemptResponseDTO.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.domain.entity.ExamAttempt;
import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Response DTO for exam attempt data
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExamAttemptResponseDTO implements BaseDTO {
    
    private Long id;
    private Long examId;
    private String examTitle;
    private String userId;
    private String startTime;
    private String endTime;
    private String status;
    private Integer questionsAnswered;
    private Integer questionsFlagged;
    private Integer timeSpent;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/ExamResponseDTO.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.domain.entity.Exam;
import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * Response DTO for exam data
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class ExamResponseDTO implements BaseDTO {
    
    private Long id;
    private String title;
    private String description;
    private Integer duration;
    private Integer totalMarks;
    private Integer passingMarks;
    private Exam.ExamStatus status;
    private List<String> tags = new ArrayList<>();
    private List<QuestionDTO> questions = new ArrayList<>();
    private Integer attemptCount;
    private Double averageScore;
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class QuestionDTO {
        private Long id;
        private Integer questionNumber;
        private String questionText;
        private List<OptionDTO> options = new ArrayList<>();
        private String correctAnswer;
        private String explanation;
        private Integer marks;
        private String topic;
        private String difficulty;
    }
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class OptionDTO {
        private Long id;
        private String optionKey;
        private String optionText;
        private Boolean isCorrect;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/FlaggedQuestionResponseDTO.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Response DTO for flagged question data
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class FlaggedQuestionResponseDTO implements BaseDTO {
    
    private Long questionId;
    private Long attemptId;
    private String questionText;
    private Integer questionNumber;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/QuestionResponseDTO.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * Response DTO for question data
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class QuestionResponseDTO implements BaseDTO {
    
    private Long id;
    private Integer questionNumber;
    private String text;
    @Builder.Default
    private List<OptionDTO> options = new ArrayList<>();
    private String explanation;
    private Integer points;
    private String topic;
    private String difficulty;
    
    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @JsonInclude(JsonInclude.Include.NON_NULL)
    public static class OptionDTO {
        private Long id;
        private String label;
        private String text;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/TokensDTO.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class TokensDTO implements BaseDTO {
    private String accessToken;
    private String refreshToken;
    private long expiresIn;
    private String tokenType;
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/response/UserResponseDTO.java">
package com.pharmacyhub.dto.response;

import com.fasterxml.jackson.annotation.JsonInclude;
import com.pharmacyhub.dto.BaseDTO;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * User response DTO that matches frontend User interface
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
@JsonInclude(JsonInclude.Include.NON_NULL)
public class UserResponseDTO implements BaseDTO {
    private String id;
    private String email;
    private String firstName;
    private String lastName;
    private boolean active;
    private String createdAt;
    private String updatedAt;
    
    @Builder.Default
    private List<String> roles = new ArrayList<>();
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/SalesmanDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class SalesmanDTO implements PHUserDTO
{
  private Long id;
  private String contactNumber;
  private String area;
  private String city;
  private String experience;
  private String previousPharmacyName;
  private String currentJobStatus;
  private String shiftTime;
  private boolean openToConnect;
  private boolean registered;
  private String firstName;
  private String lastName;
  private String emailAddress;
  
  @Override
  public UserType getUserType() {
    return UserType.SALESMAN;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/UserAnswerDTO.java">
package com.pharmacyhub.dto;

import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.PositiveOrZero;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserAnswerDTO {
    
    @NotNull(message = "Question ID is required")
    private Long questionId;
    
    private String selectedOptionId;
    
    @NotNull(message = "Time spent is required")
    @PositiveOrZero(message = "Time spent must be positive or zero")
    private Integer timeSpent; // in seconds
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/UserDTO.java">
package com.pharmacyhub.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.pharmacyhub.entity.SystemRole;
import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@AllArgsConstructor
@NoArgsConstructor
public class UserDTO implements PHUserDTO
{
  private Long id;
  private boolean openToConnect;
  private boolean registered;
  private UserType userType;
  private String firstName;
  private String lastName;
  private String emailAddress;
  private String password;
  private String contactNumber;
  private String otpCode;
   @JsonIgnore
  private SystemRole role;
  private PharmacistDTO pharmacist;
  private ProprietorDTO proprietor;
  private SalesmanDTO salesman;
  private PharmacyManagerDTO pharmacyManager;
  
  @Override
  public UserType getUserType() {
    return userType;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/dto/UserProfileDTO.java">
package com.pharmacyhub.dto;

import com.pharmacyhub.entity.enums.UserType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserProfileDTO {
    private Long id;
    private String emailAddress;
    private String firstName;
    private String lastName;
    private String contactNumber;
    private UserType userType;
    private boolean registered;
    private boolean openToConnect;
    private boolean verified;
    private Set<String> roles;
    private Set<String> permissions;
}
</file>

<file path="src/main/java/com/pharmacyhub/engine/PHEngine.java">
package com.pharmacyhub.engine;

import com.pharmacyhub.entity.User;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

@Component
public class PHEngine
{
  public User getLoggedInUser()
  {
    UserDetails userDetails = (UserDetails) SecurityContextHolder.getContext().getAuthentication().getPrincipal();

    return (User) userDetails;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/engine/PHMapper.java">
package com.pharmacyhub.engine;

import com.pharmacyhub.dto.*;
import com.pharmacyhub.dto.display.ConnectionDisplayDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.entity.*;
import com.pharmacyhub.entity.connections.PharmacistsConnections;
import com.pharmacyhub.entity.connections.PharmacyManagerConnections;
import com.pharmacyhub.entity.connections.ProprietorsConnections;
import com.pharmacyhub.entity.connections.SalesmenConnections;
import com.pharmacyhub.security.domain.Group;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.dto.GroupDTO;
import com.pharmacyhub.security.dto.PermissionDTO;
import com.pharmacyhub.security.dto.RoleDTO;
import com.pharmacyhub.security.infrastructure.GroupRepository;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import org.modelmapper.ModelMapper;
import org.springframework.stereotype.Component;

import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Component
public class PHMapper
{
    private final ModelMapper modelMapper = new ModelMapper();
    private final RolesRepository rolesRepository;
    private final PermissionRepository permissionRepository;
    private final GroupRepository groupRepository;

    public PHMapper(RolesRepository rolesRepository,
                    PermissionRepository permissionRepository,
                    GroupRepository groupRepository)
    {
        this.rolesRepository = rolesRepository;
        this.permissionRepository = permissionRepository;
        this.groupRepository = groupRepository;
    }

    // Existing mapping methods
    public Proprietor getProprietor(ProprietorDTO proprietorDTO)
    {
        return modelMapper.map(proprietorDTO, Proprietor.class);
    }

    public ProprietorDTO getProprietorDTO(Proprietor proprietor)
    {
        return modelMapper.map(proprietor, ProprietorDTO.class);
    }

    public Pharmacist getPharmacist(PharmacistDTO pharmacistDTO)
    {
        return modelMapper.map(pharmacistDTO, Pharmacist.class);
    }

    public PharmacistDTO getPharmacistDTO(Pharmacist pharmacist)
    {
        return modelMapper.map(pharmacist, PharmacistDTO.class);
    }

    public UserDTO getUserDTO(User user)
    {
        return modelMapper.map(user, UserDTO.class);
    }

    public User getUser(UserDTO userDTO)
    {
        return modelMapper.map(userDTO, User.class);
    }

    public PharmacyManager getPharmacyManager(PharmacyManagerDTO pharmacyManagerDTO)
    {
        return modelMapper.map(pharmacyManagerDTO, PharmacyManager.class);
    }

    public PharmacyManagerDTO getPharmacyManagerDTO(PharmacyManager pharmacyManager)
    {
        return modelMapper.map(pharmacyManager, PharmacyManagerDTO.class);
    }

    public Salesman getSalesman(SalesmanDTO salesmanDTO)
    {
        return modelMapper.map(salesmanDTO, Salesman.class);
    }

    public SalesmanDTO getSalesmanDTO(Salesman salesman)
    {
        return modelMapper.map(salesman, SalesmanDTO.class);
    }

    public UserDisplayDTO getUserDisplayDTO(User user)
    {
        return modelMapper.map(user, UserDisplayDTO.class);
    }

    public ReportingUserDTO getReportingUserDTO(User user)
    {
        return modelMapper.map(user, ReportingUserDTO.class);
    }

    public ConnectionDisplayDTO getConnectionDisplayDTO(ProprietorsConnections connections)
    {
        return modelMapper.map(connections, ConnectionDisplayDTO.class);
    }

    public ConnectionDisplayDTO getConnectionDisplayDTO(SalesmenConnections connections)
    {
        return modelMapper.map(connections, ConnectionDisplayDTO.class);
    }

    public ConnectionDisplayDTO getConnectionDisplayDTO(PharmacistsConnections connections)
    {
        return modelMapper.map(connections, ConnectionDisplayDTO.class);
    }

    public ConnectionDisplayDTO getConnectionDisplayDTO(PharmacyManagerConnections connections)
    {
        return modelMapper.map(connections, ConnectionDisplayDTO.class);
    }

    // Improved RBAC mapping methods with explicit type casting
    public Role getRole(RoleDTO roleDTO)
    {
        if (roleDTO == null) {
            return null;
        }
        
        Role role = modelMapper.map(roleDTO, Role.class);

        if (roleDTO.getPermissionIds() != null && !roleDTO.getPermissionIds().isEmpty())
        {
            Set<Permission> permissions = new HashSet<>();
            for (Long id : roleDTO.getPermissionIds()) {
                Permission permission = permissionRepository.findById(id)
                    .orElseThrow(() -> new RuntimeException("Permission not found with id: " + id));
                permissions.add(permission);
            }
            role.setPermissions(permissions);
        }

        if (roleDTO.getChildRoleIds() != null && !roleDTO.getChildRoleIds().isEmpty())
        {
            Set<Role> childRoles = new HashSet<>();
            for (Long id : roleDTO.getChildRoleIds()) {
                Role childRole = rolesRepository.findById(id)
                    .orElseThrow(() -> new RuntimeException("Role not found with id: " + id));
                childRoles.add(childRole);
            }
            role.setChildRoles(childRoles);
        }

        return role;
    }

    public RoleDTO getRoleDTO(Role role)
    {
        if (role == null) {
            return null;
        }
        
        RoleDTO dto = modelMapper.map(role, RoleDTO.class);
        
        Set<Long> permissionIds = new HashSet<>();
        Set<Long> childRoleIds = new HashSet<>();

        if (role.getPermissions() != null && !role.getPermissions().isEmpty())
        {
            for (Permission permission : role.getPermissions()) {
                permissionIds.add(permission.getId());
            }
            dto.setPermissionIds(permissionIds);
        }

        if (role.getChildRoles() != null && !role.getChildRoles().isEmpty())
        {
            for (Role childRole : role.getChildRoles()) {
                childRoleIds.add(childRole.getId());
            }
            dto.setChildRoleIds(childRoleIds);
        }

        return dto;
    }

    public Permission getPermission(PermissionDTO permissionDTO)
    {
        if (permissionDTO == null) {
            return null;
        }
        return modelMapper.map(permissionDTO, Permission.class);
    }

    public PermissionDTO getPermissionDTO(Permission permission)
    {
        if (permission == null) {
            return null;
        }
        return modelMapper.map(permission, PermissionDTO.class);
    }

    public Group getGroup(GroupDTO groupDTO)
    {
        if (groupDTO == null) {
            return null;
        }
        
        Group group = modelMapper.map(groupDTO, Group.class);

        if (groupDTO.getRoleIds() != null && !groupDTO.getRoleIds().isEmpty())
        {
            Set<Role> roles = new HashSet<>();
            for (Long id : groupDTO.getRoleIds()) {
                Role role = rolesRepository.findById(id)
                    .orElseThrow(() -> new RuntimeException("Role not found with id: " + id));
                roles.add(role);
            }
            group.setRoles(roles);
        }

        return group;
    }

    public GroupDTO getGroupDTO(Group group)
    {
        if (group == null) {
            return null;
        }
        
        GroupDTO dto = modelMapper.map(group, GroupDTO.class);
        
        Set<Long> roleIds = new HashSet<>();

        if (group.getRoles() != null && !group.getRoles().isEmpty())
        {
            for (Object roleObj : group.getRoles()) {
                Role role = (Role) roleObj;
                roleIds.add(role.getId());
            }
            dto.setRoleIds(roleIds);
        }

        return dto;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/engine/SeederEngine.java">
package com.pharmacyhub.engine;

import com.pharmacyhub.seeder.AdminUserSeeder;
import com.pharmacyhub.seeder.PharmacistSeeder;
import com.pharmacyhub.seeder.PharmacyManagerSeeder;
import com.pharmacyhub.seeder.ProprietorSeeder;
import com.pharmacyhub.seeder.RoleSeeder;
import com.pharmacyhub.seeder.SalesmanSeeder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;

@Component
public class SeederEngine implements ApplicationListener<ContextRefreshedEvent>
{
  @Value("${pharmacyhub.seeder.engine}")
  private boolean isEngineEnable;

  @Autowired
  private RoleSeeder roleSeeder;
  @Autowired
  private AdminUserSeeder adminUserSeeder;
  @Autowired
  private PharmacistSeeder pharmacistSeeder;
  @Autowired
  private PharmacyManagerSeeder pharmacyManagerSeeder;
  @Autowired
  private ProprietorSeeder proprietorSeeder;
  @Autowired
  private SalesmanSeeder salesmanSeeder;

  @Override
  public void onApplicationEvent(ContextRefreshedEvent event)
  {
    if (isEngineEnable)
    {
      roleSeeder.loadRoles();
      adminUserSeeder.loadSuperAdmin();
      pharmacistSeeder.loadUsers();
      pharmacyManagerSeeder.loadUsers();
      proprietorSeeder.loadUsers();
      salesmanSeeder.loadUsers();
    }
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/connections/PharmacistsConnections.java">
package com.pharmacyhub.entity.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.Pharmacist;
import com.pharmacyhub.entity.User;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Entity
@Table(name = "pharmacists_connections")
@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PharmacistsConnections
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Enumerated(EnumType.STRING)
  @Builder.Default
  private StateEnum state = StateEnum.READY_TO_CONNECT;

  private String notes;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @ManyToOne
  @JoinColumn(name = "user_id")
  private User user;

  @ManyToOne
  @JoinColumn(name = "pharmacist_id")
  private Pharmacist pharmacist;

  // Explicitly declared getters and setters for important fields
  public StateEnum getState() {
    return state;
  }

  public void setState(StateEnum state) {
    this.state = state;
  }

  public Long getId() {
    return id;
  }

  public String getNotes() {
    return notes;
  }

  public Date getCreatedAt() {
    return createdAt;
  }

  public Date getUpdatedAt() {
    return updatedAt;
  }

  public User getUser() {
    return user;
  }

  public Pharmacist getPharmacist() {
    return pharmacist;
  }

  public void setId(Long id) {
    this.id = id;
  }

  public void setNotes(String notes) {
    this.notes = notes;
  }

  public void setCreatedAt(Date createdAt) {
    this.createdAt = createdAt;
  }

  public void setUpdatedAt(Date updatedAt) {
    this.updatedAt = updatedAt;
  }

  public void setUser(User user) {
    this.user = user;
  }

  public void setPharmacist(Pharmacist pharmacist) {
    this.pharmacist = pharmacist;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/connections/PharmacyManagerConnections.java">
package com.pharmacyhub.entity.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.PharmacyManager;
import com.pharmacyhub.entity.User;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Getter
@Setter
@Builder
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "pharmacy_manager_connections")
public class PharmacyManagerConnections
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Enumerated(EnumType.STRING)
  @Builder.Default
  private StateEnum state = StateEnum.READY_TO_CONNECT;

  private String notes;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @ManyToOne
  @JoinColumn(name = "user_id")
  private User user;

  @ManyToOne
  @JoinColumn(name = "pharmacy_manager_id")
  private PharmacyManager pharmacyManager;
  
  // Explicit getters and setters for relationship fields
  public User getUser() {
    return user;
  }
  
  public void setUser(User user) {
    this.user = user;
  }
  
  public PharmacyManager getPharmacyManager() {
    return pharmacyManager;
  }
  
  public void setPharmacyManager(PharmacyManager pharmacyManager) {
    this.pharmacyManager = pharmacyManager;
  }
  
  public Long getId() {
    return id;
  }
  
  public StateEnum getState() {
    return state;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/connections/ProprietorsConnections.java">
package com.pharmacyhub.entity.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.Proprietor;
import com.pharmacyhub.entity.User;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "proprietors_connections")
public class ProprietorsConnections
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Enumerated(EnumType.STRING)
  @Builder.Default
  private StateEnum state = StateEnum.READY_TO_CONNECT;

  private String notes;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @ManyToOne
  @JoinColumn(name = "user_id")
  private User user;

  @ManyToOne
  @JoinColumn(name = "proprietor_id")
  private Proprietor proprietor;
  
  // Explicit getters and setters for relationship fields
  public User getUser() {
    return user;
  }
  
  public void setUser(User user) {
    this.user = user;
  }
  
  public Proprietor getProprietor() {
    return proprietor;
  }
  
  public void setProprietor(Proprietor proprietor) {
    this.proprietor = proprietor;
  }
  
  public Long getId() {
    return id;
  }
  
  public StateEnum getState() {
    return state;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/connections/SalesmenConnections.java">
package com.pharmacyhub.entity.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.Salesman;
import com.pharmacyhub.entity.User;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.EnumType;
import jakarta.persistence.Enumerated;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.ManyToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Getter
@Setter
@Builder
@NoArgsConstructor
@AllArgsConstructor
@Entity
@Table(name = "salesmen_connections")
public class SalesmenConnections
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Enumerated(EnumType.STRING)
  @Builder.Default
  private StateEnum state = StateEnum.READY_TO_CONNECT;
  
  private String notes;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @ManyToOne
  @JoinColumn(name = "user_id")
  private User user;

  @ManyToOne
  @JoinColumn(name = "salesman_id")
  private Salesman salesman;
  
  // Explicitly adding getters and setters for relationships
  public User getUser() {
    return user;
  }
  
  public void setUser(User user) {
    this.user = user;
  }
  
  public Salesman getSalesman() {
    return salesman;
  }
  
  public void setSalesman(Salesman salesman) {
    this.salesman = salesman;
  }
  
  public Long getId() {
    return id;
  }
  
  public StateEnum getState() {
    return state;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/Entry.java">
package com.pharmacyhub.entity;


import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;

@Entity
@Table(name = "entries")
@Getter
@Setter
@EntityListeners(AuditingEntityListener.class)
public class Entry {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String profession;
    private String pharmacyName;
    private String potential;
    private Integer experience;
    private String contactNumber;
    private String city;
    private String area;
    private String notes;

    @CreatedDate
    @Column(updatable = false)
    private LocalDateTime createdDate;

    @LastModifiedDate
    private LocalDateTime modifiedDate;

}
</file>

<file path="src/main/java/com/pharmacyhub/entity/enums/UserType.java">
package com.pharmacyhub.entity.enums;

public enum UserType {
    PHARMACIST,
    PHARMACY_MANAGER,
    PROPRIETOR,
    SALESMAN,
    ADMIN,
    SUPER_ADMIN,
    USER
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/Otp.java">
package com.pharmacyhub.entity;

import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.ManyToOne;
import lombok.Getter;
import lombok.Setter;

import java.time.LocalDateTime;

@Entity
@Getter
@Setter
public class Otp {
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @ManyToOne
  private User user;

  private String code;
  private LocalDateTime createdAt;
  private LocalDateTime expiresAt;
  
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/Pharmacist.java">
package com.pharmacyhub.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "pharmacist")
public class Pharmacist
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String categoryAvailable;
  private String licenseDuration;
  private String experience;
  private String city;
  private String location;
  private String universityName;
  private String batch;
  private String contactNumber;
  private String categoryProvince;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @OneToOne(cascade = CascadeType.MERGE)
  @JoinColumn(name = "user_id", referencedColumnName = "id")
  private User user;

}
</file>

<file path="src/main/java/com/pharmacyhub/entity/PharmacyManager.java">
package com.pharmacyhub.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "pharmacy_manager")
public class PharmacyManager
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String contactNumber;
  private String area;
  private String city;
  private String experience;
  private String previousPharmacyName;
  private String currentJobStatus;
  private String shiftTime;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @OneToOne(cascade = CascadeType.MERGE)
  @JoinColumn(name = "user_id", referencedColumnName = "id")
  private User user;

}
</file>

<file path="src/main/java/com/pharmacyhub/entity/Proprietor.java">
package com.pharmacyhub.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "proprietor")
public class Proprietor
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String categoryRequired;
  private String licenseDuration;
  private String experienced;
  private String pharmacyName;
  private String city;
  private String location;
  private String contactNumber;
  private String categoryProvince;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @OneToOne(cascade = CascadeType.MERGE)
  @JoinColumn(name = "user_id", referencedColumnName = "id")
  private User user;
  
  // Explicit getters and setters for entity relationships
  public User getUser() {
    return user;
  }
  
  public void setUser(User user) {
    this.user = user;
  }
  
  public Long getId() {
    return id;
  }
  
  public void setId(Long id) {
    this.id = id;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/Salesman.java">
package com.pharmacyhub.entity;

import jakarta.persistence.CascadeType;
import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.GeneratedValue;
import jakarta.persistence.GenerationType;
import jakarta.persistence.Id;
import jakarta.persistence.JoinColumn;
import jakarta.persistence.OneToOne;
import jakarta.persistence.Table;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

import java.util.Date;

@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
@Builder
@Entity
@Table(name = "salesman")
public class Salesman
{
  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;
  private String contactNumber;
  private String area;
  private String city;
  private String experience;
  private String previousPharmacyName;
  private String currentJobStatus;
  private String shiftTime;

  @CreationTimestamp
  @Column(updatable = false, name = "created_at")
  private Date createdAt;

  @UpdateTimestamp
  @Column(name = "updated_at")
  private Date updatedAt;

  @OneToOne(cascade = CascadeType.MERGE)
  @JoinColumn(name = "user_id", referencedColumnName = "id")
  private User user;
  
  // Explicit getters and setters for entity relationships
  public User getUser() {
    return user;
  }
  
  public void setUser(User user) {
    this.user = user;
  }
  
  public Long getId() {
    return id;
  }
  
  public void setId(Long id) {
    this.id = id;
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/SystemRole.java">
package com.pharmacyhub.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.HashSet;
import java.util.Set;

@Getter
@Setter
@Entity
@Table(name = "system_role")
public class SystemRole {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    @ManyToMany
    private Set<User> users = new HashSet<>();
}
</file>

<file path="src/main/java/com/pharmacyhub/entity/User.java">
package com.pharmacyhub.entity;

import com.pharmacyhub.security.domain.Group;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.domain.Permission;
import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;
import com.pharmacyhub.entity.enums.UserType;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;

import java.time.LocalDateTime;
import java.util.Collection;
import java.util.HashSet;
import java.util.Set;
import java.util.stream.Collectors;

@Entity
@Table(name = "users")
@Data
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class User implements UserDetails {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true)
    private String emailAddress;
    
    private String verificationToken;
    private LocalDateTime tokenCreationDate;
    private boolean verified;
    private boolean registered;
    private boolean openToConnect;
    
    @ManyToOne(fetch = FetchType.EAGER)
    @JoinColumn(name = "role_id")
    private SystemRole systemRole;

    private String firstName;
    private String lastName;
    private String contactNumber;
    private String password;

    @Enumerated(EnumType.STRING)
    private UserType userType;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_roles",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    @Builder.Default
    private Set<Role> roles = new HashSet<>();

    public void setRole(Role role) {
        if (role != null) {
            if (this.roles == null) {
                this.roles = new HashSet<>();
            }
            this.roles.add(role);
        }
    }

    public Role getRole() {
        if (roles == null || roles.isEmpty()) {
            return null;
        }
        return roles.stream()
            .min((r1, r2) -> Integer.compare(
                r1 != null ? r1.getPrecedence() : Integer.MAX_VALUE, 
                r2 != null ? r2.getPrecedence() : Integer.MAX_VALUE))
            .orElse(null);
    }
    
    public Set<Role> getRoles() {
        if (roles == null) {
            return new HashSet<>();
        }
        return roles;
    }
    
    public void setRoles(Set<Role> roles) {
        this.roles = roles != null ? roles : new HashSet<>();
    }
    
    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "user_groups",
        joinColumns = @JoinColumn(name = "user_id"),
        inverseJoinColumns = @JoinColumn(name = "group_id")
    )
    @Builder.Default
    private Set<Group> groups = new HashSet<>();
    
    public Set<Group> getGroups() {
        if (groups == null) {
            return new HashSet<>();
        }
        return groups;
    }
    
    public void setGroups(Set<Group> groups) {
        this.groups = groups != null ? groups : new HashSet<>();
    }
    
    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(
        name = "user_permissions_override",
        joinColumns = @JoinColumn(name = "user_id")
    )
    @Builder.Default
    private Set<String> permissionOverrides = new HashSet<>();
    
    public Set<String> getPermissionOverrides() {
        if (permissionOverrides == null) {
            return new HashSet<>();
        }
        return permissionOverrides;
    }
    
    public void setPermissionOverrides(Set<String> permissionOverrides) {
        this.permissionOverrides = permissionOverrides != null ? permissionOverrides : new HashSet<>();
    }
    
    @Column(nullable = false)
    @Builder.Default
    private boolean active = true;
    
    @Column(nullable = false)
    @Builder.Default
    private boolean accountNonLocked = true;
    
    @Column
    private LocalDateTime passwordExpiryDate;
    
    @Version
    private Long version;

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        Set<GrantedAuthority> authorities = new HashSet<>();
        
        // Add role-based authorities - handling null safety
        if (roles != null) {
            for (Role role : roles) {
                if (role != null) {
                    if (role.getName() != null && !role.getName().isEmpty()) {
                        authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()));
                    } else if (role.getRoleEnum() != null) {
                        authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getRoleEnum().toString()));
                    }
                    
                    // Add permission-based authorities
                    if (role.getPermissions() != null) {
                        for (Permission permission : role.getPermissions()) {
                            if (permission != null && permission.getName() != null) {
                                authorities.add(new SimpleGrantedAuthority(permission.getName()));
                            }
                        }
                    }
                }
            }
        }
        
        // Add group-based authorities
        if (groups != null) {
            for (Group group : groups) {
                if (group != null && group.getRoles() != null) {
                    for (Role role : group.getRoles()) {
                        if (role != null) {
                            if (role.getName() != null && !role.getName().isEmpty()) {
                                authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getName()));
                            } else if (role.getRoleEnum() != null) {
                                authorities.add(new SimpleGrantedAuthority("ROLE_" + role.getRoleEnum().toString()));
                            }
                            
                            if (role.getPermissions() != null) {
                                for (Permission permission : role.getPermissions()) {
                                    if (permission != null && permission.getName() != null) {
                                        authorities.add(new SimpleGrantedAuthority(permission.getName()));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        
        // Ensure we have at least one role based on user type
        if (authorities.isEmpty() && userType != null) {
            authorities.add(new SimpleGrantedAuthority("ROLE_" + userType.name()));
        }

        return authorities;
    }

    @Override
    public String getUsername() {
        return emailAddress;
    }

    @Override
    public boolean isAccountNonExpired() {
        return true;
    }

    @Override
    public boolean isAccountNonLocked() {
        return accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        if (passwordExpiryDate == null) {
            return true;
        }
        return LocalDateTime.now().isBefore(passwordExpiryDate);
    }

    @Override
    public boolean isEnabled() {
        return active;
    }

    @Override
    public String getPassword() { 
        return password; 
    }
    
    // Explicitly adding these methods to ensure they're available
    public boolean isOpenToConnect() {
        return openToConnect;
    }
    
    public boolean isRegistered() {
        return registered;
    }
    
    public UserType getUserType() {
        return userType;
    }
    
    public Long getId() {
        return id;
    }
    
    public String getEmailAddress() {
        return emailAddress;
    }
    
    public String getFirstName() {
        return firstName != null ? firstName : "";
    }
    
    public String getLastName() {
        return lastName != null ? lastName : "";
    }
    
    public String getContactNumber() {
        return contactNumber != null ? contactNumber : "";
    }
    
    public boolean isVerified() {
        return verified;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/exception/BadRequestException.java">
package com.pharmacyhub.exception;

import com.pharmacyhub.constants.ErrorConstants;
import org.springframework.http.HttpStatus;

/**
 * Exception thrown for invalid input parameters or request validation failures
 */
public class BadRequestException extends BaseException {
    
    /**
     * Constructs a new exception with the specified message
     */
    public BadRequestException(String message) {
        super(
            ErrorConstants.CODE_VALIDATION,
            message,
            HttpStatus.BAD_REQUEST
        );
    }
    
    /**
     * Constructs a new exception with the specified message and cause
     */
    public BadRequestException(String message, Throwable cause) {
        super(
            ErrorConstants.CODE_VALIDATION,
            message,
            HttpStatus.BAD_REQUEST,
            cause
        );
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/exception/BaseException.java">
package com.pharmacyhub.exception;

import lombok.Getter;
import org.springframework.http.HttpStatus;

/**
 * Base exception class for application-specific exceptions
 * Provides standard fields for error code, error message, and HTTP status
 */
@Getter
public abstract class BaseException extends RuntimeException {
    
    private final String errorCode;
    private final HttpStatus status;
    
    /**
     * Constructs a new exception with the specified error code, message, and status
     */
    public BaseException(String errorCode, String message, HttpStatus status) {
        super(message);
        this.errorCode = errorCode;
        this.status = status;
    }
    
    /**
     * Constructs a new exception with the specified error code, message, status, and cause
     */
    public BaseException(String errorCode, String message, HttpStatus status, Throwable cause) {
        super(message, cause);
        this.errorCode = errorCode;
        this.status = status;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/exception/ConflictException.java">
package com.pharmacyhub.exception;

import com.pharmacyhub.constants.ErrorConstants;
import org.springframework.http.HttpStatus;

/**
 * Exception thrown when there is a conflict with the current state of the resource
 * Typically used for duplicate entries or concurrent modification conflicts
 */
public class ConflictException extends BaseException {
    
    /**
     * Constructs a new exception with the specified message
     */
    public ConflictException(String message) {
        super(
            ErrorConstants.CODE_DUPLICATE,
            message,
            HttpStatus.CONFLICT
        );
    }
    
    /**
     * Constructs a new exception with the specified resource details
     */
    public ConflictException(String resourceName, String fieldName, Object fieldValue) {
        super(
            ErrorConstants.CODE_DUPLICATE,
            String.format("%s already exists with %s: '%s'", resourceName, fieldName, fieldValue),
            HttpStatus.CONFLICT
        );
    }
    
    /**
     * Constructs a new exception with the specified message and cause
     */
    public ConflictException(String message, Throwable cause) {
        super(
            ErrorConstants.CODE_DUPLICATE,
            message,
            HttpStatus.CONFLICT,
            cause
        );
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/exception/ForbiddenException.java">
package com.pharmacyhub.exception;

import com.pharmacyhub.constants.ErrorConstants;
import org.springframework.http.HttpStatus;

/**
 * Exception thrown when a user attempts to access a resource they don't have permission for
 */
public class ForbiddenException extends BaseException {
    
    /**
     * Constructs a new exception with the default message
     */
    public ForbiddenException() {
        super(
            ErrorConstants.CODE_ACCESS_DENIED,
            ErrorConstants.ACCESS_DENIED,
            HttpStatus.FORBIDDEN
        );
    }
    
    /**
     * Constructs a new exception with the specified message
     */
    public ForbiddenException(String message) {
        super(
            ErrorConstants.CODE_ACCESS_DENIED,
            message,
            HttpStatus.FORBIDDEN
        );
    }
    
    /**
     * Constructs a new exception with the specified message and cause
     */
    public ForbiddenException(String message, Throwable cause) {
        super(
            ErrorConstants.CODE_ACCESS_DENIED,
            message,
            HttpStatus.FORBIDDEN,
            cause
        );
    }
    
    /**
     * Constructs a new exception with details about the resource and required permission
     */
    public ForbiddenException(String resourceName, String permission) {
        super(
            ErrorConstants.CODE_ACCESS_DENIED,
            String.format("Access denied: You don't have %s permission for %s", permission, resourceName),
            HttpStatus.FORBIDDEN
        );
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/exception/ResourceNotFoundException.java">
package com.pharmacyhub.exception;

import com.pharmacyhub.constants.ErrorConstants;
import org.springframework.http.HttpStatus;

/**
 * Exception thrown when a requested resource is not found
 */
public class ResourceNotFoundException extends BaseException {
    
    /**
     * Constructs a new exception with the specified resource details
     */
    public ResourceNotFoundException(String resourceName, String fieldName, Object fieldValue) {
        super(
            ErrorConstants.CODE_NOT_FOUND,
            String.format("%s not found with %s: '%s'", resourceName, fieldName, fieldValue),
            HttpStatus.NOT_FOUND
        );
    }
    
    /**
     * Constructs a new exception with a custom message
     */
    public ResourceNotFoundException(String message) {
        super(
            ErrorConstants.CODE_NOT_FOUND,
            message,
            HttpStatus.NOT_FOUND
        );
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/exception/UnauthorizedException.java">
package com.pharmacyhub.exception;

import com.pharmacyhub.constants.ErrorConstants;
import org.springframework.http.HttpStatus;

/**
 * Exception thrown when authentication fails or credentials are invalid
 */
public class UnauthorizedException extends BaseException {
    
    /**
     * Constructs a new exception with the default message
     */
    public UnauthorizedException() {
        super(
            ErrorConstants.CODE_AUTHENTICATION,
            ErrorConstants.AUTHENTICATION_FAILED,
            HttpStatus.UNAUTHORIZED
        );
    }
    
    /**
     * Constructs a new exception with the specified message
     */
    public UnauthorizedException(String message) {
        super(
            ErrorConstants.CODE_AUTHENTICATION,
            message,
            HttpStatus.UNAUTHORIZED
        );
    }
    
    /**
     * Constructs a new exception with the specified message and cause
     */
    public UnauthorizedException(String message, Throwable cause) {
        super(
            ErrorConstants.CODE_AUTHENTICATION,
            message,
            HttpStatus.UNAUTHORIZED,
            cause
        );
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/PharmacyHubApplication.java">
package com.pharmacyhub;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class PharmacyHubApplication
{
  public static void main(String[] args)
  {
    SpringApplication.run(PharmacyHubApplication.class, args);
  }

}
</file>

<file path="src/main/java/com/pharmacyhub/repository/connections/PharmacistsConnectionsRepository.java">
package com.pharmacyhub.repository.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.Pharmacist;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.connections.PharmacistsConnections;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Spring Data SQL repository for the Pharmacist entity.
 */
@Repository
public interface PharmacistsConnectionsRepository extends JpaRepository<PharmacistsConnections, Long>
{
  List<PharmacistsConnections> findByUserAndPharmacistAndState(User user, Pharmacist pharmacist, StateEnum stateEnum);

  List<PharmacistsConnections> findByUserAndState(User user, StateEnum stateEnum);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/connections/PharmacyManagerConnectionsRepository.java">
package com.pharmacyhub.repository.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.PharmacyManager;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.connections.PharmacyManagerConnections;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Spring Data SQL repository for the Pharmacist entity.
 */
@Repository
public interface PharmacyManagerConnectionsRepository extends JpaRepository<PharmacyManagerConnections, Long>
{
  List<PharmacyManagerConnections> findByUserAndPharmacyManagerAndState(User user, PharmacyManager pharmacyManager, StateEnum stateEnum);

  List<PharmacyManagerConnections> findByUserAndState(User user, StateEnum stateEnum);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/connections/ProprietorsConnectionsRepository.java">
package com.pharmacyhub.repository.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.Proprietor;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.connections.ProprietorsConnections;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Spring Data SQL repository for the Proprietor entity.
 */
@Repository
public interface ProprietorsConnectionsRepository extends JpaRepository<ProprietorsConnections, Long>
{
  List<ProprietorsConnections> findByUserAndProprietorAndState(User user, Proprietor pharmacyManager, StateEnum stateEnum);

  List<ProprietorsConnections> findByUserAndState(User user, StateEnum stateEnum);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/connections/SalesmenConnectionsRepository.java">
package com.pharmacyhub.repository.connections;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.entity.Salesman;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.connections.SalesmenConnections;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;

/**
 * Spring Data SQL repository for the Pharmacist entity.
 */
@Repository
public interface SalesmenConnectionsRepository extends JpaRepository<SalesmenConnections, Long>
{
  List<SalesmenConnections> findByUserAndSalesmanAndState(User user, Salesman salesman, StateEnum stateEnum);

  List<SalesmenConnections> findByUserAndState(User user, StateEnum stateEnum);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/EntryRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.entity.Entry;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface EntryRepository extends JpaRepository<Entry, Long> {
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/OtpRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.entity.Otp;
import com.pharmacyhub.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface OtpRepository extends JpaRepository<Otp, Long>
{
  Optional<Otp> findTopByUserAndCodeOrderByCreatedAtDesc(User user, String code);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/PharmacistRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.entity.Pharmacist;
import com.pharmacyhub.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 * Spring Data SQL repository for the Pharmacist entity.
 */
@Repository
public interface PharmacistRepository extends JpaRepository<Pharmacist, Long>
{
    Pharmacist findByUser(User user);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/PharmacyManagerRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.entity.PharmacyManager;
import com.pharmacyhub.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PharmacyManagerRepository extends JpaRepository<PharmacyManager, Long>
{
  PharmacyManager findByUser(User loggedInUser);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/ProprietorRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.entity.Proprietor;
import com.pharmacyhub.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;


@SuppressWarnings("unused")
@Repository
public interface ProprietorRepository extends JpaRepository<Proprietor, Long>
{
  Proprietor findByUser(User loggedInUser);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/RoleRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.constants.RoleEnum;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;
import java.util.Set;

@Repository
public interface RoleRepository extends JpaRepository<Role, Long> {
    Optional<Role> findByName(RoleEnum name);
    
    List<Role> findBySystemTrue();
    
    @Query("SELECT r FROM Role r WHERE r.precedence <= :maxPrecedence")
    List<Role> findByPrecedenceLessThanEqual(Integer maxPrecedence);
    
    @Query("SELECT DISTINCT r FROM Role r LEFT JOIN FETCH r.permissions WHERE r.id IN :roleIds")
    Set<Role> findByIdInWithPermissions(Set<Long> roleIds);
    
    @Query("SELECT DISTINCT r FROM Role r LEFT JOIN FETCH r.childRoles WHERE r.id = :roleId")
    Optional<Role> findByIdWithChildRoles(Long roleId);
    
    boolean existsByNameAndIdNot(RoleEnum name, Long id);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/SalesmanRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.entity.Salesman;
import com.pharmacyhub.entity.User;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface SalesmanRepository extends JpaRepository<Salesman, Long>
{
  Salesman findByUser(User loggedInUser);
}
</file>

<file path="src/main/java/com/pharmacyhub/repository/UserRepository.java">
package com.pharmacyhub.repository;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.security.domain.Group;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;

import java.util.List;
import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long>
{
  Optional<User> findByEmailAddress(String emailAddress);
  Optional<User> findByVerificationToken(String token);
  Optional<User> findById(Long id);
  
  /**
   * Find all users that have the specified role name.
   */
  @Query("SELECT u FROM User u JOIN u.roles r WHERE r.name = :roleName")
  List<User> findByRolesName(@Param("roleName") String roleName);
  
  /**
   * Find all users that belong to the specified group.
   */
  @Query("SELECT u FROM User u JOIN u.groups g WHERE g.name = :groupName")
  List<User> findByGroupsName(@Param("groupName") String groupName);
  
  /**
   * Find users with a specific permission (either directly through roles or through groups).
   */
  @Query("SELECT DISTINCT u FROM User u JOIN u.roles r JOIN r.permissions p WHERE p.name = :permissionName " +
         "UNION " +
         "SELECT DISTINCT u FROM User u JOIN u.groups g JOIN g.roles r JOIN r.permissions p WHERE p.name = :permissionName")
  List<User> findByPermission(@Param("permissionName") String permissionName);
  
  /**
   * Check if a user has any active permission overrides.
   */
  @Query("SELECT CASE WHEN COUNT(u) > 0 THEN true ELSE false END FROM User u WHERE u.id = :userId AND SIZE(u.permissionOverrides) > 0")
  boolean hasPermissionOverrides(@Param("userId") Long userId);
  
  /**
   * Find users by their user type.
   */
  List<User> findByUserType(UserType userType);
  
  /**
   * Find users by their user type with pagination.
   */
  Page<User> findByUserType(UserType userType, Pageable pageable);
  
  /**
   * Find users who belong to a specific group.
   */
  List<User> findByGroupsContaining(Group group);
  
  /**
   * Find users who have a specific role directly assigned (not through groups).
   */
  @Query("SELECT u FROM User u JOIN u.roles r WHERE r.id = :roleId")
  List<User> findByRoleId(@Param("roleId") Long roleId);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/annotation/RequiresPermission.java">
package com.pharmacyhub.security.annotation;

import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.ResourceType;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * Annotation to specify required permissions for accessing methods.
 * Used in conjunction with PermissionAspect for RBAC enforcement.
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface RequiresPermission {
    /**
     * The resource type being accessed
     */
    ResourceType resource();
    
    /**
     * The operation being performed on the resource
     */
    OperationType operation();
    
    /**
     * The permission name (optional)
     * If specified, this exact permission will be checked instead of generating one from resource and operation
     */
    String permissionName() default "";
    
    /**
     * Whether this operation requires approval
     * @return true if approval is required, false otherwise
     */
    boolean requiresApproval() default false;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/aspect/PermissionAspect.java">
package com.pharmacyhub.security.aspect;

import com.pharmacyhub.engine.PHEngine;
import com.pharmacyhub.security.annotation.RequiresPermission;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.service.RBACService;
import lombok.RequiredArgsConstructor;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;
import java.util.Set;

@Aspect
@Component
@RequiredArgsConstructor
public class PermissionAspect extends PHEngine
{
    private final RBACService rbacService;

    @Around("@annotation(com.pharmacyhub.security.annotation.RequiresPermission)")
    public Object checkPermission(ProceedingJoinPoint joinPoint) throws Throwable
    {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        RequiresPermission annotation = method.getAnnotation(RequiresPermission.class);

        // Get current user's permissions
        Set<Permission> userPermissions = rbacService.getUserEffectivePermissions(getLoggedInUser().getId());

        // Check if user has required permission
        boolean hasPermission;
        
        // If a specific permission name is provided, check for that
        if (annotation.permissionName() != null && !annotation.permissionName().isEmpty()) {
            hasPermission = userPermissions.stream()
                                         .anyMatch(permission -> permission.getName().equals(annotation.permissionName()));
        } else {
            // Otherwise check based on resource and operation
            hasPermission = userPermissions.stream()
                                         .anyMatch(permission -> permission.getResourceType() == annotation.resource() &&
                                                 permission.getOperationType() == annotation.operation() &&
                                                 (!annotation.requiresApproval() ||
                                                         permission.isRequiresApproval()));
        }

        if (!hasPermission)
        {
            if (annotation.permissionName() != null && !annotation.permissionName().isEmpty()) {
                throw new AccessDeniedException(
                        "User does not have required permission: " + annotation.permissionName());
            } else {
                throw new AccessDeniedException(
                        "User does not have required permission: " + annotation.resource() + ":" + annotation.operation());
            }
        }

        return joinPoint.proceed();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/config/AccessEvaluatorConfig.java">
package com.pharmacyhub.security.config;

import com.pharmacyhub.domain.repository.ExamAttemptRepository;
import com.pharmacyhub.domain.repository.ExamRepository;
import com.pharmacyhub.security.evaluator.ExamAccessEvaluator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Configuration class to explicitly register security evaluator beans.
 */
@Configuration
public class AccessEvaluatorConfig {

    private static final Logger logger = LoggerFactory.getLogger(AccessEvaluatorConfig.class);

    /**
     * Explicitly register the examAccessEvaluator bean to ensure 
     * it is properly recognized by Spring Security for @PreAuthorize annotations.
     */
    @Bean(name = "examAccessEvaluator")
    public ExamAccessEvaluator examAccessEvaluator(
            ExamAttemptRepository examAttemptRepository,
            ExamRepository examRepository) {
        logger.info("Registering examAccessEvaluator bean");
        return new ExamAccessEvaluator(examAttemptRepository, examRepository);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/config/RBACCacheConfig.java">
package com.pharmacyhub.security.config;

import org.springframework.cache.CacheManager;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.cache.concurrent.ConcurrentMapCache;
import org.springframework.cache.support.SimpleCacheManager;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Arrays;

@Configuration
@EnableCaching
public class RBACCacheConfig {

    @Bean
    public CacheManager rbacCacheManager() {
        SimpleCacheManager cacheManager = new SimpleCacheManager();
        cacheManager.setCaches(Arrays.asList(
            new ConcurrentMapCache("userPermissions"),
            new ConcurrentMapCache("userRoles"),
            new ConcurrentMapCache("roleHierarchy"),
            new ConcurrentMapCache("groupRoles")
        ));
        return cacheManager;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/constants/AuthPermissionConstants.java">
package com.pharmacyhub.security.constants;

/**
 * Constants for authentication and user account-related permissions
 * These constants are shared between frontend and backend to ensure naming consistency
 */
public final class AuthPermissionConstants {
    /**
     * Authentication
     */
    public static final String LOGIN = "auth:login";
    public static final String LOGOUT = "auth:logout";
    public static final String REGISTER = "auth:register";
    
    /**
     * Account Management
     */
    public static final String MANAGE_ACCOUNT = "auth:manage-account";
    public static final String VERIFY_EMAIL = "auth:verify-email";
    public static final String RESET_PASSWORD = "auth:reset-password";
    
    /**
     * Profile
     */
    public static final String VIEW_PROFILE = "auth:view-profile";
    public static final String EDIT_PROFILE = "auth:edit-profile";
    
    /**
     * Sessions
     */
    public static final String MANAGE_SESSIONS = "auth:manage-sessions";
    public static final String VIEW_SESSIONS = "auth:view-sessions";
    
    /**
     * User Management (Admin)
     */
    public static final String MANAGE_USERS = "auth:manage-users";
    public static final String VIEW_USERS = "auth:view-users";
    public static final String EDIT_USERS = "auth:edit-users";
    public static final String DELETE_USERS = "auth:delete-users";
    public static final String IMPERSONATE_USER = "auth:impersonate-user";
    
    // Role-based permission groupings
    public static final String[] BASIC_USER_PERMISSIONS = {
        LOGIN, LOGOUT, VIEW_PROFILE, EDIT_PROFILE,
        MANAGE_ACCOUNT, VERIFY_EMAIL, RESET_PASSWORD,
        VIEW_SESSIONS
    };
    
    public static final String[] ADMIN_PERMISSIONS = {
        MANAGE_USERS, VIEW_USERS, EDIT_USERS, DELETE_USERS,
        MANAGE_SESSIONS, IMPERSONATE_USER
    };
    
    private AuthPermissionConstants() {
        // Private constructor to prevent instantiation
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/constants/ExamPermissionConstants.java">
package com.pharmacyhub.security.constants;

/**
 * Constants for exam-related permissions
 * These constants are shared between frontend and backend to ensure naming consistency
 */
public final class ExamPermissionConstants {
    /**
     * Basic Exam Access
     */
    public static final String VIEW_EXAMS = "exams:view";
    public static final String TAKE_EXAM = "exams:take";
    
    /**
     * Exam Creation & Management
     */
    public static final String CREATE_EXAM = "exams:create";
    public static final String EDIT_EXAM = "exams:edit";
    public static final String DELETE_EXAM = "exams:delete";
    public static final String DUPLICATE_EXAM = "exams:duplicate";
    
    /**
     * Question Management
     */
    public static final String MANAGE_QUESTIONS = "exams:manage-questions";
    
    /**
     * Exam Administration
     */
    public static final String PUBLISH_EXAM = "exams:publish";
    public static final String UNPUBLISH_EXAM = "exams:unpublish";
    public static final String ASSIGN_EXAM = "exams:assign";
    
    /**
     * Results & Grading
     */
    public static final String GRADE_EXAM = "exams:grade";
    public static final String VIEW_RESULTS = "exams:view-results";
    public static final String EXPORT_RESULTS = "exams:export-results";
    
    /**
     * Analytics
     */
    public static final String VIEW_ANALYTICS = "exams:view-analytics";
    
    // Role-based permission groupings
    public static final String[] ADMIN_PERMISSIONS = {
        CREATE_EXAM, EDIT_EXAM, DELETE_EXAM, PUBLISH_EXAM, 
        UNPUBLISH_EXAM, MANAGE_QUESTIONS, ASSIGN_EXAM,
        GRADE_EXAM, VIEW_RESULTS, EXPORT_RESULTS, VIEW_ANALYTICS
    };
    
    public static final String[] INSTRUCTOR_PERMISSIONS = {
        CREATE_EXAM, EDIT_EXAM, PUBLISH_EXAM, UNPUBLISH_EXAM,
        MANAGE_QUESTIONS, ASSIGN_EXAM, GRADE_EXAM, 
        VIEW_RESULTS, VIEW_ANALYTICS
    };
    
    public static final String[] STUDENT_PERMISSIONS = {
        VIEW_EXAMS, TAKE_EXAM, VIEW_RESULTS
    };
    
    private ExamPermissionConstants() {
        // Private constructor to prevent instantiation
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/constants/PermissionConstants.java">
package com.pharmacyhub.security.constants;

/**
 * Constants for permission names
 * Used to ensure consistent naming between frontend and backend
 */
public final class PermissionConstants {
    // User Management
    public static final String MANAGE_USERS = "manage:users";
    public static final String VIEW_USERS = "view:users";
    
    // Pharmacy Management
    public static final String CREATE_PHARMACY = "create:pharmacy";
    public static final String EDIT_PHARMACY = "edit:pharmacy";
    public static final String DELETE_PHARMACY = "delete:pharmacy";
    public static final String VIEW_PHARMACY = "view:pharmacy";
    
    // Pharmacist Management
    public static final String CREATE_PHARMACIST = "create:pharmacist";
    public static final String UPDATE_PHARMACIST = "update:pharmacist";
    public static final String VIEW_PHARMACIST = "view:pharmacist";
    public static final String VIEW_ALL_PHARMACISTS = "view:all:pharmacists";
    public static final String DELETE_PHARMACIST = "delete:pharmacist";
    
    // Connection Management
    public static final String MANAGE_CONNECTIONS = "manage:connections";
    public static final String VIEW_CONNECTIONS = "view:connections";
    public static final String VIEW_ALL_CONNECTIONS = "view:all:connections";
    public static final String APPROVE_CONNECTIONS = "approve:connections";
    public static final String REJECT_CONNECTIONS = "reject:connections";
    
    // Role Management
    public static final String MANAGE_ROLES = "manage:roles";
    
    // Permission Management
    public static final String MANAGE_PERMISSIONS = "manage:permissions";
    
    // Group Management
    public static final String MANAGE_GROUPS = "manage:groups";
    
    // Exam Management
    public static final String MANAGE_EXAMS = "manage:exams";
    public static final String TAKE_EXAMS = "take:exams";
    public static final String GRADE_EXAMS = "grade:exams";
    
    // System Management
    public static final String MANAGE_SYSTEM = "manage:system";
    public static final String MANAGE_SYSTEM_SETTINGS = "manage:system:settings";
    
    // Audit Management
    public static final String VIEW_AUDIT_LOGS = "view:audit:logs";
    public static final String VIEW_OWN_AUDIT_LOGS = "view:own:audit:logs";
    public static final String EXPORT_AUDIT_LOGS = "export:audit:logs";
    
    // Order Management
    public static final String APPROVE_ORDERS = "approve:orders";
    public static final String PLACE_ORDERS = "place:orders";
    
    // Inventory Management
    public static final String MANAGE_INVENTORY = "manage:inventory";
    public static final String VIEW_PRODUCTS = "view:products";
    
    // Reports
    public static final String VIEW_REPORTS = "view:reports";
    
    // Status Updates
    public static final String UPDATE_STATUS = "update:status";
    
    private PermissionConstants() {
        // Private constructor to prevent instantiation
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/constants/RoleConstants.java">
package com.pharmacyhub.security.constants;

/**
 * Constants for role names
 * Used to ensure consistent naming between frontend and backend
 */
public final class RoleConstants {
    public static final String SUPER_ADMIN = "SUPER_ADMIN";
    public static final String ADMIN = "ADMIN";
    public static final String MANAGER = "MANAGER";
    public static final String PHARMACY_MANAGER = "PHARMACY_MANAGER";
    public static final String USER = "USER";
    public static final String PHARMACIST = "PHARMACIST";
    public static final String PROPRIETOR = "PROPRIETOR";
    public static final String SALESMAN = "SALESMAN";
    public static final String INSTRUCTOR = "INSTRUCTOR";
    
    private RoleConstants() {
        // Private constructor to prevent instantiation
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/controller/FeatureController.java">
package com.pharmacyhub.security.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.annotation.RequiresPermission;
import com.pharmacyhub.security.domain.Feature;
import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.security.dto.FeatureDTO;
import com.pharmacyhub.security.service.FeatureService;
import com.pharmacyhub.security.service.RBACService;
import com.pharmacyhub.service.UserService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Controller for feature-based access control operations
 */
@RestController
@RequestMapping(APIConstants.BASE_MAPPING + "/features")
@RequiredArgsConstructor
@Slf4j
public class FeatureController {
    private final RBACService rbacService;
    private final FeatureService featureService;
    private final UserService userService;

    /**
     * Get all features accessible to the current user
     */
    @GetMapping("/accessible")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ApiResponse<List<FeatureDTO>>> getAccessibleFeatures() {
        User currentUser = userService.getLoggedInUser();
        log.debug("Getting accessible features for user ID: {}", currentUser.getId());
        
        Set<Feature> features = rbacService.getUserAccessibleFeatures(currentUser.getId());
        List<FeatureDTO> featureDTOs = features.stream()
                .map(featureService::convertFeatureToDTO)
                .collect(Collectors.toList());
                
        return ResponseEntity.ok(ApiResponse.success(featureDTOs));
    }
    
    /**
     * Check if the current user has access to a specific feature
     */
    @GetMapping("/check-access/{featureCode}")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ApiResponse<Boolean>> checkFeatureAccess(
            @PathVariable String featureCode) {
        User currentUser = userService.getLoggedInUser();
        log.debug("Checking access to feature '{}' for user ID: {}", featureCode, currentUser.getId());
        
        boolean hasAccess = rbacService.userHasFeatureAccess(currentUser.getId(), featureCode);
        return ResponseEntity.ok(ApiResponse.success(hasAccess));
    }
    
    /**
     * Check if the current user has access to multiple features at once
     */
    @PostMapping("/check-bulk-access")
    @PreAuthorize("isAuthenticated()")
    public ResponseEntity<ApiResponse<Map<String, Boolean>>> checkBulkFeatureAccess(
            @RequestBody List<String> featureCodes) {
        User currentUser = userService.getLoggedInUser();
        log.debug("Checking bulk access to features for user ID: {}", currentUser.getId());
        
        Map<String, Boolean> results = new HashMap<>();
        
        for (String featureCode : featureCodes) {
            boolean hasAccess = rbacService.userHasFeatureAccess(currentUser.getId(), featureCode);
            results.put(featureCode, hasAccess);
        }
        
        return ResponseEntity.ok(ApiResponse.success(results));
    }
    
    /**
     * Get all available features in the system (admin only)
     */
    @GetMapping
    @RequiresPermission(resource = ResourceType.FEATURE, operation = OperationType.READ)
    public ResponseEntity<ApiResponse<List<FeatureDTO>>> getAllFeatures() {
        log.debug("Getting all features");
        
        List<Feature> features = featureService.getAllFeatures();
        List<FeatureDTO> featureDTOs = features.stream()
                .map(featureService::convertFeatureToDTO)
                .collect(Collectors.toList());
                
        return ResponseEntity.ok(ApiResponse.success(featureDTOs));
    }
    
    /**
     * Create a new feature (admin only)
     */
    @PostMapping
    @RequiresPermission(resource = ResourceType.FEATURE, operation = OperationType.CREATE)
    public ResponseEntity<ApiResponse<FeatureDTO>> createFeature(@RequestBody FeatureDTO featureDTO) {
        log.debug("Creating new feature: {}", featureDTO.getCode());
        
        Feature feature = featureService.createFeature(featureDTO);
        FeatureDTO createdFeatureDTO = featureService.convertFeatureToDTO(feature);
        
        return ResponseEntity.ok(ApiResponse.success(createdFeatureDTO));
    }
    
    /**
     * Update an existing feature (admin only)
     */
    @PutMapping("/{id}")
    @RequiresPermission(resource = ResourceType.FEATURE, operation = OperationType.UPDATE)
    public ResponseEntity<ApiResponse<FeatureDTO>> updateFeature(
            @PathVariable Long id, @RequestBody FeatureDTO featureDTO) {
        log.debug("Updating feature ID: {}", id);
        
        Feature feature = featureService.updateFeature(id, featureDTO);
        FeatureDTO updatedFeatureDTO = featureService.convertFeatureToDTO(feature);
        
        return ResponseEntity.ok(ApiResponse.success(updatedFeatureDTO));
    }
    
    /**
     * Delete a feature (admin only)
     */
    @DeleteMapping("/{id}")
    @RequiresPermission(resource = ResourceType.FEATURE, operation = OperationType.DELETE)
    public ResponseEntity<ApiResponse<Void>> deleteFeature(@PathVariable Long id) {
        log.debug("Deleting feature ID: {}", id);
        
        featureService.deleteFeature(id);
        return ResponseEntity.ok(ApiResponse.success(null));
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/controller/PermissionController.java">
package com.pharmacyhub.security.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.dto.response.ApiResponse;
import com.pharmacyhub.security.annotation.RequiresPermission;
import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.security.service.PermissionDataLoaderService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * Controller for permission-related operations
 * Provides endpoints for retrieving permission data
 */
@RestController
@RequestMapping(APIConstants.BASE_MAPPING + "/permissions")
@RequiredArgsConstructor
@Slf4j
public class PermissionController {
    private final PermissionDataLoaderService permissionDataLoaderService;

    /**
     * Get all permissions across the system
     * Only accessible to administrators
     */
    @GetMapping
    @RequiresPermission(resource = ResourceType.PERMISSION, operation = OperationType.READ)
    public ResponseEntity<ApiResponse<List<Map<String, Object>>>> getAllPermissions() {
        log.debug("Retrieving all permissions");
        
        List<Permission> permissions = permissionDataLoaderService.getAllPermissions();
        List<Map<String, Object>> result = permissions.stream()
                .map(this::mapPermissionToDto)
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(ApiResponse.success(result));
    }
    
    /**
     * Get all permissions grouped by resource type
     * Only accessible to administrators
     */
    @GetMapping("/structured")
    @RequiresPermission(resource = ResourceType.PERMISSION, operation = OperationType.READ)
    public ResponseEntity<ApiResponse<Map<String, List<Map<String, Object>>>>> getPermissionStructure() {
        log.debug("Retrieving structured permissions");
        
        Map<String, List<Map<String, Object>>> structure = 
                permissionDataLoaderService.getPermissionStructure();
        
        return ResponseEntity.ok(ApiResponse.success(structure));
    }
    
    /**
     * Get all permissions for a specific feature
     * Only accessible to administrators
     */
    @GetMapping("/feature/{feature}")
    @RequiresPermission(resource = ResourceType.PERMISSION, operation = OperationType.READ)
    public ResponseEntity<ApiResponse<List<Map<String, Object>>>> getFeaturePermissions(
            @PathVariable String feature) {
        log.debug("Retrieving permissions for feature: {}", feature);
        
        List<Permission> permissions = permissionDataLoaderService.getFeaturePermissions(feature);
        List<Map<String, Object>> result = permissions.stream()
                .map(this::mapPermissionToDto)
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(ApiResponse.success(result));
    }
    
    /**
     * Get all permissions related to exams
     * This is a convenience endpoint for the exam module
     */
    @GetMapping("/exams")
    @RequiresPermission(resource = ResourceType.PERMISSION, operation = OperationType.READ)
    public ResponseEntity<ApiResponse<List<Map<String, Object>>>> getExamPermissions() {
        log.debug("Retrieving exam permissions");
        
        List<Permission> permissions = permissionDataLoaderService.getExamPermissions();
        List<Map<String, Object>> result = permissions.stream()
                .map(this::mapPermissionToDto)
                .collect(Collectors.toList());
        
        return ResponseEntity.ok(ApiResponse.success(result));
    }
    
    /**
     * Reload and synchronize all permissions
     * This is an administrative function to ensure the system has the latest permissions
     */
    @PostMapping("/sync")
    @RequiresPermission(resource = ResourceType.PERMISSION, operation = OperationType.MANAGE)
    public ResponseEntity<ApiResponse<Void>> synchronizePermissions() {
        log.info("Synchronizing permissions");
        
        try {
            permissionDataLoaderService.synchronizePermissions();
            return ResponseEntity.ok(ApiResponse.success(null));
        } catch (Exception e) {
            log.error("Error synchronizing permissions", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body(ApiResponse.error(500, "Error synchronizing permissions: " + e.getMessage()));
        }
    }
    
    /**
     * Map Permission entity to DTO
     */
    private Map<String, Object> mapPermissionToDto(Permission permission) {
        Map<String, Object> dto = new HashMap<>();
        dto.put("id", permission.getId());
        dto.put("name", permission.getName());
        dto.put("description", permission.getDescription());
        dto.put("resourceType", permission.getResourceType().name());
        dto.put("operationType", permission.getOperationType().name());
        dto.put("requiresApproval", permission.isRequiresApproval());
        return dto;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/controller/RoleHierarchyController.java">
package com.pharmacyhub.security.controller;

import com.pharmacyhub.security.annotation.RequiresPermission;
import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.security.service.RoleHierarchyService;
import lombok.RequiredArgsConstructor;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/rbac/roles/hierarchy")
@RequiredArgsConstructor
public class RoleHierarchyController
{
    private final RoleHierarchyService roleHierarchyService;

    @PostMapping("/{parentRoleId}/children/{childRoleId}")
    @RequiresPermission(resource = ResourceType.ROLE, operation = OperationType.MANAGE)
    public ResponseEntity<?> addChildRole(
            @PathVariable Long parentRoleId,
            @PathVariable Long childRoleId)
    {
        roleHierarchyService.addChildRole(parentRoleId, childRoleId);
        return ResponseEntity.ok().build();
    }

    @DeleteMapping("/{parentRoleId}/children/{childRoleId}")
    @RequiresPermission(resource = ResourceType.ROLE, operation = OperationType.MANAGE)
    public ResponseEntity<?> removeChildRole(
            @PathVariable Long parentRoleId,
            @PathVariable Long childRoleId)
    {
        roleHierarchyService.removeChildRole(parentRoleId, childRoleId);
        return ResponseEntity.ok().build();
    }

    @GetMapping("/{roleId}/children")
    @RequiresPermission(resource = ResourceType.ROLE, operation = OperationType.READ)
    public ResponseEntity<?> getAllChildRoles(@PathVariable Long roleId)
    {
        return ResponseEntity.ok(roleHierarchyService.getAllChildRoles(roleId));
    }

    @GetMapping("/precedence")
    @RequiresPermission(resource = ResourceType.ROLE, operation = OperationType.READ)
    public ResponseEntity<?> getRolesByPrecedence()
    {
        return ResponseEntity.ok(roleHierarchyService.getRolesByPrecedence());
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/controller/SecurityCheckController.java">
package com.pharmacyhub.security.controller;

import com.pharmacyhub.constants.APIConstants;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.dto.AccessCheckRequest;
import com.pharmacyhub.security.service.RBACService;
import com.pharmacyhub.service.UserService;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Controller for security-related checks
 * Provides endpoints for the frontend to validate permissions and roles
 */
@RestController
@RequestMapping(APIConstants.BASE_MAPPING)
public class SecurityCheckController {

    @Autowired
    private RBACService rbacService;
    
    @Autowired
    private UserService userService;
    
    /**
     * Check multiple permissions at once
     * Returns a map of permission names to boolean values indicating if the user has each permission
     */
    @PreAuthorize("isAuthenticated()")
    @RequestMapping(
            value = APIConstants.API_VERSION_V1 + "/security/check-permissions",
            method = RequestMethod.POST
    )
    public ResponseEntity<Map<String, Boolean>> checkPermissions(@RequestBody List<String> permissions) {
        User currentUser = userService.getLoggedInUser();
        Set<Permission> userPermissions = rbacService.getUserEffectivePermissions(currentUser.getId());
        
        Map<String, Boolean> results = new HashMap<>();
        permissions.forEach(permission -> {
            boolean hasPermission = userPermissions.stream()
                .anyMatch(p -> p.getName().equals(permission));
            results.put(permission, hasPermission);
        });
        
        return ResponseEntity.ok(results);
    }
    
    /**
     * Check if the user has access based on roles and permissions
     * Supports checking for multiple roles/permissions with AND/OR logic
     */
    @PreAuthorize("isAuthenticated()")
    @RequestMapping(
            value = APIConstants.API_VERSION_V1 + "/security/check-access",
            method = RequestMethod.POST
    )
    public ResponseEntity<AccessCheckResult> checkAccess(@RequestBody AccessCheckRequest request) {
        User currentUser = userService.getLoggedInUser();
        Set<Permission> userPermissions = rbacService.getUserEffectivePermissions(currentUser.getId());
        Set<Role> userRoles = rbacService.getUserRoles(currentUser.getId());
        
        // Check roles
        boolean hasRole = request.getRoles().isEmpty() || 
            request.getRoles().stream().anyMatch(role -> 
                userRoles.stream().anyMatch(r -> r.getName().equals(role))
            );
            
        // Check permissions
        boolean hasPermission = request.getPermissions().isEmpty() ||
            request.getPermissions().stream().allMatch(permission ->
                userPermissions.stream().anyMatch(p -> p.getName().equals(permission))
            );
        
        boolean hasAccess = request.isRequireAll() 
            ? (hasRole && hasPermission) 
            : (hasRole || hasPermission);
            
        return ResponseEntity.ok(new AccessCheckResult(hasAccess));
    }
    
    /**
     * Get all available permissions in the system (admin only)
     * Useful for permission management in the UI
     */
    @PreAuthorize("hasRole('ADMIN') or hasPermission('PERMISSION', 'MANAGE')")
    @RequestMapping(
            value = APIConstants.API_VERSION_V1 + "/security/available-permissions",
            method = RequestMethod.POST
    )
    public ResponseEntity<List<PermissionInfoDTO>> getAvailablePermissions() {
        List<Permission> allPermissions = rbacService.getAllPermissions();
        
        List<PermissionInfoDTO> permissionDTOs = allPermissions.stream()
            .map(permission -> new PermissionInfoDTO(
                permission.getName(),
                permission.getDescription(),
                permission.getResourceType().name(),
                permission.getOperationType().name(),
                permission.isRequiresApproval()
            ))
            .collect(Collectors.toList());
            
        return ResponseEntity.ok(permissionDTOs);
    }
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    static class AccessCheckResult {
        private boolean hasAccess;
    }
    
    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    static class PermissionInfoDTO {
        private String name;
        private String description;
        private String resourceType;
        private String operationType;
        private boolean requiresApproval;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/CustomUserDetailsService.java">
package com.pharmacyhub.security;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.service.RBACService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.Set;
import java.util.stream.Collectors;

@Service
public class CustomUserDetailsService implements UserDetailsService
{
    @Autowired
    private UserRepository userRepository;

    @Autowired
    private RBACService rbacService;

    @Override
    @Transactional(readOnly = true)
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException
    {
        User user = userRepository.findByEmailAddress(username)
                                  .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // Get effective permissions
        Set<Permission> effectivePermissions = rbacService.getUserEffectivePermissions(user.getId());

        // Add permission-based authorities
        Set<SimpleGrantedAuthority> authorities = effectivePermissions.stream()
                                                                      .map(permission -> new SimpleGrantedAuthority(
                                                                              permission.getName()))
                                                                      .collect(Collectors.toSet());

        // Add role-based authorities
        user.getRoles().forEach(role -> {
            Role typedRole = (Role) role;
            authorities.add(new SimpleGrantedAuthority("ROLE_" + typedRole.getName()));
            typedRole.getPermissions().forEach(permission ->
                authorities.add(new SimpleGrantedAuthority(permission.getName())));
        });

        // Add group-based authorities
        user.getGroups().forEach(group ->
            group.getRoles().forEach(role -> {
                Role typedRole = (Role) role;
                authorities.add(new SimpleGrantedAuthority("ROLE_" + typedRole.getName()));
                typedRole.getPermissions().forEach(permission ->
                    authorities.add(new SimpleGrantedAuthority(permission.getName())));
            }));

        return user;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/AuditLog.java">
package com.pharmacyhub.security.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

@Entity
@Table(name = "audit_logs")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuditLog {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private String username;

    @Column(nullable = false)
    private String action;

    @Column(length = 1000)
    private String details;

    @Column(nullable = false)
    private String outcome;

    @Column(nullable = false)
    private LocalDateTime timestamp;

    @Column(name = "user_id")
    private Long userId;

    @PrePersist
    protected void onCreate() {
        if (timestamp == null) {
            timestamp = LocalDateTime.now();
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/exception/RBACException.java">
package com.pharmacyhub.security.domain.exception;

import lombok.Getter;
import lombok.extern.slf4j.Slf4j;

@Getter
public class RBACException extends RuntimeException {
    private final String errorCode;

    public RBACException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public static RBACException permissionDenied() {
        return new RBACException("Permission denied", "RBAC_001");
    }

    public static RBACException invalidRoleHierarchy() {
        return new RBACException("Invalid role hierarchy detected", "RBAC_002");
    }

    public static RBACException entityNotFound(String entity) {
        return new RBACException(entity + " not found", "RBAC_003");
    }

    public static RBACException invalidOperation(String message) {
        return new RBACException(message, "RBAC_004");
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/Feature.java">
package com.pharmacyhub.security.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

/**
 * Entity representing a system feature that requires access control
 */
@Entity
@Table(name = "features")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Feature {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name;

    @Column
    private String description;

    @OneToMany(mappedBy = "feature", cascade = CascadeType.ALL, fetch = FetchType.EAGER)
    @Builder.Default
    private Set<FeaturePermission> featurePermissions = new HashSet<>();
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Ensure name is never null
    public String getName() {
        return name != null ? name : "";
    }
    
    public String getDescription() {
        return description != null ? description : "";
    }
    
    public Set<FeaturePermission> getFeaturePermissions() {
        if (featurePermissions == null) {
            return new HashSet<>();
        }
        return featurePermissions;
    }
    
    public void setFeaturePermissions(Set<FeaturePermission> featurePermissions) {
        this.featurePermissions = featurePermissions != null ? featurePermissions : new HashSet<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        Feature feature = (Feature) o;
        
        if (id != null && feature.id != null) {
            return id.equals(feature.id);
        }
        
        return name != null && name.equals(feature.name);
    }
    
    @Override
    public int hashCode() {
        if (id != null) {
            return id.hashCode();
        }
        return name != null ? name.hashCode() : 0;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/FeaturePermission.java">
package com.pharmacyhub.security.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.Set;

/**
 * Associates specific permissions with a feature and creates a named access level
 */
@Entity
@Table(name = "feature_permissions")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FeaturePermission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @ManyToOne
    @JoinColumn(name = "feature_id", nullable = false)
    private Feature feature;

    @Column(nullable = false)
    private String accessLevel;  // e.g., "VIEW", "EDIT", "MANAGE"

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "feature_permission_mappings",
        joinColumns = @JoinColumn(name = "feature_permission_id"),
        inverseJoinColumns = @JoinColumn(name = "permission_id")
    )
    @Builder.Default
    private Set<Permission> requiredPermissions = new HashSet<>();
    
    @Column(name = "created_at")
    private LocalDateTime createdAt;

    @Column(name = "updated_at")
    private LocalDateTime updatedAt;
    
    @PrePersist
    protected void onCreate() {
        createdAt = LocalDateTime.now();
        updatedAt = LocalDateTime.now();
    }

    @PreUpdate
    protected void onUpdate() {
        updatedAt = LocalDateTime.now();
    }
    
    // Ensure access level is never null
    public String getAccessLevel() {
        return accessLevel != null ? accessLevel : "";
    }
    
    public Set<Permission> getRequiredPermissions() {
        if (requiredPermissions == null) {
            return new HashSet<>();
        }
        return requiredPermissions;
    }
    
    public void setRequiredPermissions(Set<Permission> requiredPermissions) {
        this.requiredPermissions = requiredPermissions != null ? requiredPermissions : new HashSet<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        FeaturePermission that = (FeaturePermission) o;
        
        if (id != null && that.id != null) {
            return id.equals(that.id);
        }
        
        if (feature == null || that.feature == null || accessLevel == null || that.accessLevel == null) {
            return false;
        }
        
        return feature.equals(that.feature) && accessLevel.equals(that.accessLevel);
    }
    
    @Override
    public int hashCode() {
        if (id != null) {
            return id.hashCode();
        }
        
        int result = feature != null ? feature.hashCode() : 0;
        result = 31 * result + (accessLevel != null ? accessLevel.hashCode() : 0);
        return result;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/Group.java">
package com.pharmacyhub.security.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "groups")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Group {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name;

    @Column
    private String description;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "group_roles",
        joinColumns = @JoinColumn(name = "group_id"),
        inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    @Builder.Default
    private Set<Role> roles = new HashSet<>();

    public String getName() {
        return name != null ? name : "";
    }
    
    public String getDescription() {
        return description != null ? description : "";
    }
    
    public Set<Role> getRoles() {
        if (roles == null) {
            return new HashSet<>();
        }
        return roles;
    }
    
    public void setRoles(Set<Role> roles) {
        this.roles = roles != null ? roles : new HashSet<>();
    }
    
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        Group that = (Group) o;
        
        if (id != null && that.id != null) {
            return id.equals(that.id);
        }
        
        return name != null && name.equals(that.name);
    }
    
    @Override
    public int hashCode() {
        if (id != null) {
            return id.hashCode();
        }
        return name != null ? name.hashCode() : 0;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/OperationType.java">
package com.pharmacyhub.security.domain;

public enum OperationType {
    CREATE,
    READ,
    UPDATE,
    DELETE,
    APPROVE,
    REJECT,
    MANAGE,
    EXPORT,
    IMPORT,
    VIEW_ALL,
    VIEW_OWN
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/Permission.java">
package com.pharmacyhub.security.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Entity
@Table(name = "permissions")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Permission {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String name;

    @Column
    private String description;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private ResourceType resourceType;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private OperationType operationType;

    @Column(nullable = false)
    @Builder.Default
    private boolean requiresApproval = false;
    
    // Ensure name is never null
    public String getName() {
        return name != null ? name : "";
    }
    
    // Ensure resourceType is never null
    public ResourceType getResourceType() {
        return resourceType != null ? resourceType : ResourceType.USER;
    }
    
    // Ensure operationType is never null
    public OperationType getOperationType() {
        return operationType != null ? operationType : OperationType.READ;
    }
    
    public String getDescription() {
        return description != null ? description : "";
    }
    
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public void setDescription(String description) {
        this.description = description;
    }
    
    public void setResourceType(ResourceType resourceType) {
        this.resourceType = resourceType != null ? resourceType : ResourceType.USER;
    }
    
    public void setOperationType(OperationType operationType) {
        this.operationType = operationType != null ? operationType : OperationType.READ;
    }
    
    public boolean isRequiresApproval() {
        return requiresApproval;
    }
    
    public void setRequiresApproval(boolean requiresApproval) {
        this.requiresApproval = requiresApproval;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        Permission that = (Permission) o;
        
        if (id != null && that.id != null) {
            return id.equals(that.id);
        }
        
        if (name == null || that.name == null) {
            return false;
        }
        
        return name.equals(that.name);
    }
    
    @Override
    public int hashCode() {
        if (id != null) {
            return id.hashCode();
        }
        return name != null ? name.hashCode() : 0;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/PermissionEnum.java">
package com.pharmacyhub.security.domain;

public enum PermissionEnum {
    // Pharmacist management
    CREATE_PHARMACIST,
    UPDATE_PHARMACIST,
    VIEW_PHARMACIST,
    VIEW_ALL_PHARMACISTS,
    DELETE_PHARMACIST,

    // Connection management
    MANAGE_CONNECTIONS,
    VIEW_CONNECTIONS,
    VIEW_ALL_CONNECTIONS,
    APPROVE_CONNECTIONS,
    REJECT_CONNECTIONS,

    // Admin operations
    MANAGE_ROLES,
    MANAGE_PERMISSIONS,
    MANAGE_GROUPS,
    VIEW_AUDIT_LOGS,
    MANAGE_SYSTEM_SETTINGS,

    // Audit operations
    VIEW_OWN_AUDIT_LOGS,
    EXPORT_AUDIT_LOGS;

    public String getValue() {
        return this.name();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/ResourceType.java">
package com.pharmacyhub.security.domain;

/**
 * Defines all resources that can be operated on in the system
 */
public enum ResourceType {
    // Users and authentication
    USER,
    
    // Roles and permissions
    ROLE,
    PERMISSION,
    GROUP,
    FEATURE,
    
    // Pharmacy staff
    PHARMACIST,
    PHARMACY_MANAGER,
    PROPRIETOR,
    SALESMAN,
    
    // Pharmacy operations
    PHARMACY,
    INVENTORY,
    MEDICINE,
    PRESCRIPTION,
    ORDER,
    SALES,
    
    // Business operations
    BUSINESS,
    REPORTS,
    ANALYTICS,
    
    // System
    CONNECTION,
    AUDIT_LOG,
    SYSTEM_SETTING,
    
    // Other
    NOTIFICATION,
    MESSAGE,
    DOCUMENT
}
</file>

<file path="src/main/java/com/pharmacyhub/security/domain/Role.java">
package com.pharmacyhub.security.domain;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import com.pharmacyhub.constants.RoleEnum;
import lombok.NoArgsConstructor;

import java.util.HashSet;
import java.util.Set;

@Entity
@Table(name = "roles")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class Role {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(unique = true, nullable = false)
    private RoleEnum name;

    @Column
    private String description;
    
    @Column(nullable = false)
    private int precedence;

    @Column(nullable = false)
    @Builder.Default
    private boolean system = false;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
        name = "role_permissions",
        joinColumns = @JoinColumn(name = "role_id"),
        inverseJoinColumns = @JoinColumn(name = "permission_id")
    )
    @Builder.Default
    private Set<Permission> permissions = new HashSet<>();

    @ManyToMany(fetch = FetchType.LAZY)
    @JoinTable(
        name = "role_hierarchy",
        joinColumns = @JoinColumn(name = "parent_role_id"),
        inverseJoinColumns = @JoinColumn(name = "child_role_id")
    )
    @Builder.Default
    private Set<Role> childRoles = new HashSet<>();

    // Override getName to always return the enum's string value, not null
    public String getName() {
        return name != null ? name.toString() : "";
    }
    
    // Add a method to get the RoleEnum directly
    public RoleEnum getRoleEnum() {
        return name;
    }
    
    // Using proper getters/setters instead of relying on Lombok for critical parts
    public Long getId() {
        return id;
    }
    
    public void setId(Long id) {
        this.id = id;
    }
    
    public int getPrecedence() {
        return precedence;
    }
    
    public void setPrecedence(int precedence) {
        this.precedence = precedence;
    }
    
    public boolean isSystem() {
        return system;
    }
    
    public void setSystem(boolean system) {
        this.system = system;
    }
    
    public Set<Permission> getPermissions() {
        if (permissions == null) {
            return new HashSet<>();
        }
        return permissions;
    }
    
    public void setPermissions(Set<Permission> permissions) {
        this.permissions = permissions != null ? permissions : new HashSet<>();
    }
    
    public Set<Role> getChildRoles() {
        if (childRoles == null) {
            return new HashSet<>();
        }
        return childRoles;
    }
    
    public void setChildRoles(Set<Role> childRoles) {
        this.childRoles = childRoles != null ? childRoles : new HashSet<>();
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        
        Role role = (Role) o;
        
        if (id != null && role.id != null) {
            return id.equals(role.id);
        }
        
        return name != null && name.equals(role.name);
    }
    
    @Override
    public int hashCode() {
        if (id != null) {
            return id.hashCode();
        }
        return name != null ? name.hashCode() : 0;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/AccessCheckRequest.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * Data Transfer Object for access check requests
 * Used to validate if a user has specific roles or permissions
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class AccessCheckRequest {
    private List<String> roles = new ArrayList<>();
    private List<String> permissions = new ArrayList<>();
    private boolean requireAll = true;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/FeatureAccessDTO.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashSet;
import java.util.Set;

/**
 * DTO for feature access information
 * Contains information about a feature and the operations a user can perform
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FeatureAccessDTO {
    private String featureCode;
    private String name;
    private String description;
    private boolean hasAccess;
    
    @Builder.Default
    private Set<String> allowedOperations = new HashSet<>();
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/FeatureAccessRequest.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * Data Transfer Object for feature access check requests
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class FeatureAccessRequest {
    private List<String> features = new ArrayList<>();
    private boolean requireAll = false;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/FeatureAccessResponse.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Response DTO for feature access checks
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FeatureAccessResponse {
    private boolean granted;
    private String message;
    private Long featureId;
    private String featureName;
    private String accessLevel;

    /**
     * Factory method for creating granted responses
     */
    public static FeatureAccessResponse granted(String message) {
        return FeatureAccessResponse.builder()
                .granted(true)
                .message(message)
                .build();
    }

    /**
     * Factory method for creating denied responses
     */
    public static FeatureAccessResponse denied(String message) {
        return FeatureAccessResponse.builder()
                .granted(false)
                .message(message)
                .build();
    }
    
    /**
     * Factory method for creating detailed granted responses
     */
    public static FeatureAccessResponse grantedWithDetails(
            String message, Long featureId, String featureName, String accessLevel) {
        return FeatureAccessResponse.builder()
                .granted(true)
                .message(message)
                .featureId(featureId)
                .featureName(featureName)
                .accessLevel(accessLevel)
                .build();
    }
    
    /**
     * Factory method for creating detailed denied responses
     */
    public static FeatureAccessResponse deniedWithDetails(
            String message, Long featureId, String featureName, String accessLevel) {
        return FeatureAccessResponse.builder()
                .granted(false)
                .message(message)
                .featureId(featureId)
                .featureName(featureName)
                .accessLevel(accessLevel)
                .build();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/FeatureDTO.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * DTO for creating and updating features
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FeatureDTO {
    private Long id;
    private String name;
    private String description;
    
    @Builder.Default
    private List<FeaturePermissionDTO> permissions = new ArrayList<>();
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/FeaturePermissionDTO.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

/**
 * DTO for creating and updating feature permissions
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class FeaturePermissionDTO {
    private Long id;
    private String accessLevel;
    
    @Builder.Default
    private List<Long> permissionIds = new ArrayList<>();
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/GroupDTO.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class GroupDTO {
    private Long id;
    private String name;
    private String description;
    private Set<Long> roleIds;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/PermissionDTO.java">
package com.pharmacyhub.security.dto;

import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.ResourceType;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class PermissionDTO {
    private Long id;
    private String name;
    private String description;
    private ResourceType resourceType;
    private OperationType operationType;
    private boolean requiresApproval;
    private String conditions;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/RoleDTO.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Set;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class RoleDTO {
    private Long id;
    private String name;
    private String description;
    private Set<Long> permissionIds;
    private Set<Long> childRoleIds;
    private Integer precedence;
    private boolean system;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/dto/UserFeatureAccessDTO.java">
package com.pharmacyhub.security.dto;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.HashMap;
import java.util.Map;

/**
 * DTO for user feature access information
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserFeatureAccessDTO {
    private Long id;
    private String featureName;
    private String description;
    
    @Builder.Default
    private Map<String, Boolean> accessLevels = new HashMap<>();
    
    private boolean hasAccess;
    
    /**
     * Factory method to create a user feature access DTO
     */
    public static UserFeatureAccessDTO create(
            Long id, String featureName, String description, 
            Map<String, Boolean> accessLevels, boolean hasAccess) {
        return UserFeatureAccessDTO.builder()
                .id(id)
                .featureName(featureName)
                .description(description)
                .accessLevels(accessLevels != null ? accessLevels : new HashMap<>())
                .hasAccess(hasAccess)
                .build();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/evaluator/ExamAccessEvaluator.java">
package com.pharmacyhub.security.evaluator;

import com.pharmacyhub.domain.entity.ExamAttempt;
import com.pharmacyhub.domain.repository.ExamAttemptRepository;
import com.pharmacyhub.domain.repository.ExamRepository;
import com.pharmacyhub.service.ExamService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
// Removed Component annotation as the bean is explicitly registered in AccessEvaluatorConfig

import java.util.Collection;
import java.util.List;

/**
 * Evaluator for determining if a user can access a specific exam.
 * Used in @PreAuthorize annotations to secure exam access.
 */
// Explicitly registered as a bean in AccessEvaluatorConfig
public class ExamAccessEvaluator {
    
    private static final Logger logger = LoggerFactory.getLogger(ExamAccessEvaluator.class);
    
    private final ExamAttemptRepository examAttemptRepository;
    private final ExamRepository examRepository;
    
    public ExamAccessEvaluator(
            ExamAttemptRepository examAttemptRepository,
            ExamRepository examRepository) {
        this.examAttemptRepository = examAttemptRepository;
        this.examRepository = examRepository;
    }
    
    /**
     * Determines if the authenticated user can access the specified exam.
     * Access is granted if:
     * 1. The user has an ADMIN or INSTRUCTOR role
     * 2. The exam exists (simplified policy to allow all authenticated users to access any exam)
     *
     * @param authentication The current authentication context
     * @param examId The ID of the exam to check access for
     * @return True if the user can access the exam, false otherwise
     */
    public boolean canAccessExam(Authentication authentication, Long examId) {
        if (authentication == null) {
            logger.warn("Authentication is null when checking exam access for examId: {}", examId);
            return false;
        }
        
        // If user has ADMIN or INSTRUCTOR role, they automatically have access
        Collection<? extends GrantedAuthority> authorities = authentication.getAuthorities();
        if (authorities.stream().anyMatch(a -> 
                a.getAuthority().equals("ROLE_ADMIN") || 
                a.getAuthority().equals("ROLE_INSTRUCTOR"))) {
            logger.debug("User has ADMIN or INSTRUCTOR role, granting access to exam: {}", examId);
            return true;
        }
        
        // Get the user ID from the authentication
        String userId = authentication.getName();
        logger.debug("Checking if user {} can access exam {}", userId, examId);
        
        // Check if the exam exists (we're simplifying by allowing access to any exam that exists)
        boolean examExists = examRepository.existsById(examId);
        
        if (!examExists) {
            logger.debug("Exam {} doesn't exist, denying access", examId);
            return false;
        }
        
        // Allow all authenticated users to access any exam that exists
        logger.debug("Exam {} exists, granting access to user {}", examId, userId);
        return true;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/evaluator/PHPermissionEvaluator.java">
package com.pharmacyhub.security.evaluator;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.security.service.AuditService;
import com.pharmacyhub.security.service.RBACService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.access.PermissionEvaluator;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.io.Serializable;
import java.util.Set;

@Component
@Slf4j
public class PHPermissionEvaluator implements PermissionEvaluator {

    private final RBACService rbacService;
    private final AuditService auditService;

    public PHPermissionEvaluator(RBACService rbacService, AuditService auditService) {
        this.rbacService = rbacService;
        this.auditService = auditService;
    }

    @Override
    public boolean hasPermission(Authentication authentication, Object targetDomainObject, Object permission) {
        if ((authentication == null) || !(permission instanceof String)) {
            return false;
        }

        String permissionString = permission.toString();
        
        // If no target is specified, treat it as a generic permission check
        if (targetDomainObject == null) {
            return hasGenericPermission(authentication, permissionString);
        }

        // Get the resource type from the target domain object
        String targetType = targetDomainObject.getClass().getSimpleName().toUpperCase();
        
        // Get the user from the authentication
        if (!(authentication.getPrincipal() instanceof UserDetails)) {
            return false;
        }
        
        User user = (User) authentication.getPrincipal();
        
        // Get the user's effective permissions
        Set<Permission> effectivePermissions = rbacService.getUserEffectivePermissions(user.getId());
        
        // Check if the user has the required permission for the target
        boolean hasPermission = effectivePermissions.stream()
                .anyMatch(p -> matchesPermission(p, targetType, permissionString));
        
        // Log the permission check
        auditService.logSecurityEvent(
            "PERMISSION_CHECK",
            String.format("User %s checked permission %s on %s", 
                user.getUsername(), permissionString, targetType),
            hasPermission ? "GRANTED" : "DENIED"
        );
        
        return hasPermission;
    }

    @Override
    public boolean hasPermission(Authentication authentication, Serializable targetId, String targetType, Object permission) {
        if ((authentication == null) || (targetType == null) || !(permission instanceof String)) {
            return false;
        }
        
        // When using this method, the targetType is a string specifying the type
        String permissionString = permission.toString();
        
        // Get the user from the authentication
        if (!(authentication.getPrincipal() instanceof UserDetails)) {
            return false;
        }
        
        User user = (User) authentication.getPrincipal();
        
        // Get the user's effective permissions
        Set<Permission> effectivePermissions = rbacService.getUserEffectivePermissions(user.getId());
        
        // Check if the user has the required permission for the target type
        boolean hasPermission = effectivePermissions.stream()
                .anyMatch(p -> matchesPermission(p, targetType, permissionString));
        
        // Log the permission check with target ID
        auditService.logSecurityEvent(
            "PERMISSION_CHECK",
            String.format("User %s checked permission %s on %s with ID %s", 
                user.getUsername(), permissionString, targetType, targetId),
            hasPermission ? "GRANTED" : "DENIED"
        );
        
        return hasPermission;
    }
    
    /**
     * Checks if the user has a generic permission that doesn't target a specific resource.
     */
    private boolean hasGenericPermission(Authentication authentication, String permissionString) {
        if (!(authentication.getPrincipal() instanceof UserDetails)) {
            return false;
        }
        
        User user = (User) authentication.getPrincipal();
        Set<Permission> effectivePermissions = rbacService.getUserEffectivePermissions(user.getId());
        
        // For generic permissions, match by name
        boolean hasPermission = effectivePermissions.stream()
                .anyMatch(p -> p.getName().equals(permissionString));
        
        // Log the permission check
        auditService.logSecurityEvent(
            "PERMISSION_CHECK",
            String.format("User %s checked generic permission %s", 
                user.getUsername(), permissionString),
            hasPermission ? "GRANTED" : "DENIED"
        );
        
        return hasPermission;
    }
    
    /**
     * Checks if a permission matches the target type and permission string.
     */
    private boolean matchesPermission(Permission permission, String targetType, String permissionString) {
        // Check for exact match
        if (permission.getName().equals(permissionString)) {
            return true;
        }
        
        // Check for type + operation match
        try {
            ResourceType resourceType = ResourceType.valueOf(targetType);
            return permission.getResourceType() == resourceType && 
                   permission.getOperationType().name().equals(permissionString);
        } catch (IllegalArgumentException e) {
            // If the target type doesn't match a ResourceType, fall back to name matching
            return false;
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/exception/RBACException.java">
package com.pharmacyhub.security.exception;

import lombok.Getter;

@Getter
public class RBACException extends RuntimeException {
    private final String errorCode;

    public RBACException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public static RBACException permissionDenied() {
        return new RBACException("Permission denied", "RBAC_001");
    }

    public static RBACException invalidRoleHierarchy() {
        return new RBACException("Invalid role hierarchy detected", "RBAC_002");
    }

    public static RBACException entityNotFound(String entity) {
        return new RBACException(entity + " not found", "RBAC_003");
    }

    public static RBACException invalidOperation(String message) {
        return new RBACException(message, "RBAC_004");
    }
    
    public static RBACException invalidData(String message) {
        return new RBACException(message, "RBAC_005");
    }
    
    public static RBACException alreadyExists(String message) {
        return new RBACException(message, "RBAC_006");
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/exception/RBACExceptionHandler.java">
package com.pharmacyhub.security.exception;

import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.AccessDeniedException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.ResponseStatus;
import org.springframework.web.bind.annotation.RestControllerAdvice;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@RestControllerAdvice
@Slf4j
public class RBACExceptionHandler {

    @ExceptionHandler(RBACException.class)
    public ResponseEntity<Map<String, Object>> handleRBACException(RBACException ex) {
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.FORBIDDEN.value());
        response.put("error", "RBAC Error");
        response.put("message", ex.getMessage());
        response.put("errorCode", ex.getErrorCode());

        log.error("RBAC Exception: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
    }

    @ExceptionHandler(AccessDeniedException.class)
    @ResponseStatus(HttpStatus.FORBIDDEN)
    public ResponseEntity<Map<String, Object>> handleAccessDeniedException(AccessDeniedException ex) {
        Map<String, Object> response = new HashMap<>();
        response.put("timestamp", LocalDateTime.now());
        response.put("status", HttpStatus.FORBIDDEN.value());
        response.put("error", "Access Denied");
        response.put("message", "You don't have permission to perform this action");
        response.put("errorCode", "RBAC_001");

        log.error("Access Denied Exception: {}", ex.getMessage());
        return ResponseEntity.status(HttpStatus.FORBIDDEN).body(response);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/handler/CustomAccessDeniedHandler.java">
package com.pharmacyhub.security.handler;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.pharmacyhub.constants.ErrorConstants;
import com.pharmacyhub.dto.response.ApiErrorResponse;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Custom handler for 403 Access Denied responses with detailed security diagnostics
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class CustomAccessDeniedHandler implements AccessDeniedHandler {
    
    private final ObjectMapper objectMapper;
    
    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, 
                      org.springframework.security.access.AccessDeniedException ex) throws IOException, ServletException {
        
        response.setStatus(HttpStatus.FORBIDDEN.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        // Get current authentication details
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        String username = authentication != null ? authentication.getName() : "anonymous";
        
        // Log detailed security diagnostics
        log.error(
            "Access denied: {} {} denied for user='{}', ip='{}', userAgent='{}', authorities={}, reason='{}'",
            request.getMethod(),
            request.getRequestURI(),
            username,
            request.getRemoteAddr(),
            request.getHeader("User-Agent"),
            authentication != null ? authentication.getAuthorities() : "none",
            ex.getMessage()
        );
        
        // Additional diagnostic information (not exposed to clients)
        Map<String, Object> diagnostics = new HashMap<>();
        diagnostics.put("timestamp", LocalDateTime.now().toString());
        diagnostics.put("user", username);
        diagnostics.put("authorities", authentication != null ? authentication.getAuthorities().toString() : "none");
        diagnostics.put("requestUri", request.getRequestURI());
        diagnostics.put("method", request.getMethod());
        diagnostics.put("exceptionType", ex.getClass().getName());
        diagnostics.put("exceptionMessage", ex.getMessage());
        
        // Log diagnostics separately for internal troubleshooting
        log.debug("403 Access Denied Diagnostics: {}", diagnostics);
        
        // Prepare client-facing error response
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.FORBIDDEN.value())
                .errorCode(ErrorConstants.CODE_ACCESS_DENIED)
                .message(ErrorConstants.ACCESS_DENIED)
                .path(request.getRequestURI())
                .timestamp(LocalDateTime.now())
                .build();
        
        objectMapper.writeValue(response.getWriter(), errorResponse);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/handler/CustomAuthenticationEntryPoint.java">
package com.pharmacyhub.security.handler;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.pharmacyhub.constants.ErrorConstants;
import com.pharmacyhub.dto.response.ApiErrorResponse;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Custom entry point for handling authentication failures (401 Unauthorized)
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class CustomAuthenticationEntryPoint implements AuthenticationEntryPoint {
    
    private final ObjectMapper objectMapper;
    
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response,
                         AuthenticationException ex) throws IOException, ServletException {
        
        response.setStatus(HttpStatus.UNAUTHORIZED.value());
        response.setContentType(MediaType.APPLICATION_JSON_VALUE);
        
        // Log authentication failure details
        log.warn(
            "Authentication failed: {} {} for ip='{}', userAgent='{}', reason='{}'",
            request.getMethod(),
            request.getRequestURI(),
            request.getRemoteAddr(),
            request.getHeader("User-Agent"),
            ex.getMessage()
        );
        
        // Additional diagnostic information (not exposed to clients)
        Map<String, Object> diagnostics = new HashMap<>();
        diagnostics.put("timestamp", LocalDateTime.now().toString());
        diagnostics.put("requestUri", request.getRequestURI());
        diagnostics.put("method", request.getMethod());
        diagnostics.put("exceptionType", ex.getClass().getName());
        diagnostics.put("exceptionMessage", ex.getMessage());
        
        // Log diagnostics separately for internal troubleshooting
        log.debug("401 Authentication Failure Diagnostics: {}", diagnostics);
        
        // Prepare client-facing error response
        String errorCode = ErrorConstants.CODE_AUTHENTICATION;
        String message = ErrorConstants.AUTHENTICATION_FAILED;
        
        ApiErrorResponse errorResponse = ApiErrorResponse.builder()
                .status(HttpStatus.UNAUTHORIZED.value())
                .errorCode(errorCode)
                .message(message)
                .path(request.getRequestURI())
                .timestamp(LocalDateTime.now())
                .build();
        
        objectMapper.writeValue(response.getWriter(), errorResponse);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/AuditLogRepository.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.AuditLog;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.time.LocalDateTime;
import java.util.List;

@Repository
public interface AuditLogRepository extends JpaRepository<AuditLog, Long> {
    List<AuditLog> findByUserId(Long userId, Pageable pageable);
    List<AuditLog> findAllByOrderByTimestampDesc();
    List<AuditLog> findByActionOrderByTimestampDesc(String action);
    List<AuditLog> findByTimestampBetweenOrderByTimestampDesc(LocalDateTime startDate, LocalDateTime endDate);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/configuration/AuthenticationConfig.java">
package com.pharmacyhub.security.infrastructure.configuration;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;

/**
 * Configuration for authentication-related beans
 */
@Configuration
public class AuthenticationConfig {
    
    /**
     * Exposes the AuthenticationManager as a bean to be injected into services and controllers
     */
    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }
    
    /**
     * Password encoder for securely hashing passwords
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/configuration/SecurityConfig.java">
package com.pharmacyhub.security.infrastructure.configuration;

import com.pharmacyhub.security.JwtAuthenticationFilter;
import com.pharmacyhub.security.handler.CustomAccessDeniedHandler;
import com.pharmacyhub.security.handler.CustomAuthenticationEntryPoint;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

import java.util.Arrays;

/**
 * Security configuration for the application
 */
@Configuration
@EnableWebSecurity
@EnableMethodSecurity
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;
    
    @Autowired
    private CustomAuthenticationEntryPoint authenticationEntryPoint;
    
    @Autowired
    private CustomAccessDeniedHandler accessDeniedHandler;

    /**
     * Configures HTTP security for the application
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .cors(cors -> cors.configurationSource(corsConfigurationSource()))
            .csrf(csrf -> csrf.disable())
            .authorizeHttpRequests(authorize -> authorize
                // Public endpoints
                .requestMatchers("/api/auth/**").permitAll()
                .requestMatchers("/api/health").permitAll()
                .requestMatchers("/health").permitAll()
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/swagger-ui/**", "/v3/api-docs/**").permitAll()
                // Protected endpoints
                .anyRequest().authenticated()
            )
            .sessionManagement(session -> session
                .sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .exceptionHandling(exceptions -> exceptions
                .authenticationEntryPoint(authenticationEntryPoint)
                .accessDeniedHandler(accessDeniedHandler)
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    /**
     * Configures CORS for the application
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000", "http://127.0.0.1:3000", "https://pharmacyhub.pk"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type", "Accept", "Cache-Control", "Pragma"));
        configuration.setExposedHeaders(Arrays.asList("Authorization"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L); // 1 hour cache for preflight requests

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/exception/AuthenticationExceptionHandler.java">
package com.pharmacyhub.security.infrastructure.exception;

import com.pharmacyhub.security.model.ErrorResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.DisabledException;
import org.springframework.security.authentication.LockedException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

/**
 * Global exception handler for authentication-related exceptions
 */
@RestControllerAdvice
public class AuthenticationExceptionHandler {
    
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationExceptionHandler.class);
    
    /**
     * Handle bad credentials exception
     */
    @ExceptionHandler(BadCredentialsException.class)
    public ResponseEntity<ErrorResponse> handleBadCredentialsException(BadCredentialsException ex, WebRequest request) {
        logger.error("Authentication failed: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(new ErrorResponse("Invalid credentials", "The username or password is incorrect"));
    }
    
    /**
     * Handle username not found exception
     */
    @ExceptionHandler(UsernameNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleUsernameNotFoundException(UsernameNotFoundException ex, WebRequest request) {
        logger.error("User not found: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(new ErrorResponse("Invalid credentials", "The username or password is incorrect"));
    }
    
    /**
     * Handle unverified account exception
     */
    @ExceptionHandler(UnverifiedAccountException.class)
    public ResponseEntity<ErrorResponse> handleUnverifiedAccountException(UnverifiedAccountException ex, WebRequest request) {
        logger.error("Unverified account: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse("Account not verified", "Please verify your email before logging in"));
    }
    
    /**
     * Handle disabled account exception
     */
    @ExceptionHandler(DisabledException.class)
    public ResponseEntity<ErrorResponse> handleDisabledException(DisabledException ex, WebRequest request) {
        logger.error("Account disabled: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse("Account disabled", "Your account has been disabled"));
    }
    
    /**
     * Handle locked account exception
     */
    @ExceptionHandler(LockedException.class)
    public ResponseEntity<ErrorResponse> handleLockedException(LockedException ex, WebRequest request) {
        logger.error("Account locked: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.FORBIDDEN)
                .body(new ErrorResponse("Account locked", "Your account has been locked"));
    }
    
    /**
     * Handle general authentication exceptions
     */
    @ExceptionHandler(AuthenticationException.class)
    public ResponseEntity<ErrorResponse> handleAuthenticationException(AuthenticationException ex, WebRequest request) {
        logger.error("Authentication error: {}", ex.getMessage());
        return ResponseEntity
                .status(HttpStatus.UNAUTHORIZED)
                .body(new ErrorResponse("Authentication failed", "An error occurred during authentication"));
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/exception/UnverifiedAccountException.java">
package com.pharmacyhub.security.infrastructure.exception;

import org.springframework.security.core.AuthenticationException;

/**
 * Exception thrown when a user attempts to login with an unverified account
 */
public class UnverifiedAccountException extends AuthenticationException {
    
    public UnverifiedAccountException(String msg) {
        super(msg);
    }
    
    public UnverifiedAccountException(String msg, Throwable cause) {
        super(msg, cause);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/FeaturePermissionRepository.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.Feature;
import com.pharmacyhub.security.domain.FeaturePermission;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface FeaturePermissionRepository extends JpaRepository<FeaturePermission, Long> {
    List<FeaturePermission> findByFeature(Feature feature);
    
    Optional<FeaturePermission> findByFeatureAndAccessLevel(Feature feature, String accessLevel);
    
    boolean existsByFeatureAndAccessLevel(Feature feature, String accessLevel);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/FeatureRepository.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.Feature;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;
import java.util.Optional;

@Repository
public interface FeatureRepository extends JpaRepository<Feature, Long> {
    Optional<Feature> findByName(String name);
    boolean existsByName(String name);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/GroupRepository.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.Group;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.stereotype.Repository;

import java.util.Optional;
import java.util.Set;

@Repository
public interface GroupRepository extends JpaRepository<Group, Long>, GroupRepositoryInterface {
    @Override
    Optional<Group> findByName(String name);

    @Query("SELECT DISTINCT g FROM Group g LEFT JOIN FETCH g.roles WHERE g.id IN :groupIds")
    Set<Group> findByIdInWithRoles(Set<Long> groupIds);

    boolean existsByNameAndIdNot(String name, Long id);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/GroupRepositoryInterface.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.Group;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface GroupRepositoryInterface extends JpaRepository<Group, Long> {
    Optional<Group> findByName(String name);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/PermissionRepository.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.Permission;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.Optional;

@Repository
public interface PermissionRepository extends JpaRepository<Permission, Long>, PermissionRepositoryInterface {
    @Override
    Optional<Permission> findByName(String name);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/PermissionRepositoryInterface.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.Permission;
import java.util.Optional;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

@Repository
public interface PermissionRepositoryInterface extends JpaRepository<Permission, Long> {
    Optional<Permission> findByName(String name);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/RoleRepositoryInterface.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.security.domain.Role;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.Optional;

@Repository
public interface RoleRepositoryInterface extends JpaRepository<Role, Long> {
    Optional<Role> findByName(RoleEnum name);
    
    // Using a better approach to find by name string
    @Query("SELECT r FROM Role r WHERE FUNCTION('UPPER', r.name) = FUNCTION('UPPER', :name)")
    Optional<Role> findByNameIgnoreCase(@Param("name") String name);
    
    // Simple query without CAST which might be causing issues
    @Query("SELECT r FROM Role r")
    List<Role> findAllRoles();

    List<Role> findBySystemTrue();

    List<Role> findByPrecedenceLessThanEqual(Integer maxPrecedence);
    
    @Query("SELECT r FROM Role r LEFT JOIN FETCH r.childRoles WHERE r.id = :roleId")
    Role findByIdWithChildRoles(@Param("roleId") Long roleId);
}
</file>

<file path="src/main/java/com/pharmacyhub/security/infrastructure/RolesRepository.java">
package com.pharmacyhub.security.infrastructure;

import com.pharmacyhub.security.domain.Role;
import org.springframework.stereotype.Repository;

@Repository
public interface RolesRepository extends RoleRepositoryInterface {
    // All methods are inherited from RoleRepositoryInterface
}
</file>

<file path="src/main/java/com/pharmacyhub/security/initializer/ExamRolePermissionInitializer.java">
package com.pharmacyhub.security.initializer;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.security.constants.ExamPermissionConstants;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import com.pharmacyhub.security.service.PermissionDataLoaderService;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Initializes exam-specific roles and permissions
 * Runs after the main role initializer to ensure all base roles are already created
 */
@Slf4j
@Component
@RequiredArgsConstructor
@Order(Ordered.LOWEST_PRECEDENCE - 10) // Ensure this runs after the main role initializer
public class ExamRolePermissionInitializer implements ApplicationListener<ContextRefreshedEvent> {
    private final RolesRepository rolesRepository;
    private final PermissionRepository permissionRepository;
    private final PermissionDataLoaderService permissionDataLoaderService;
    
    private boolean initialized = false;

    @Override
    @Transactional
    public void onApplicationEvent(ContextRefreshedEvent event) {
        // Only initialize once
        if (initialized) {
            return;
        }
        
        try {
            log.info("Initializing exam-specific roles and permissions");
            
            // Ensure permissions are synchronized first
            permissionDataLoaderService.synchronizePermissions();
            
            // Assign exam permissions to roles
            assignExamPermissionsToRoles();
            
            // Create specific exam roles if needed
            createSpecificExamRoles();
            
            initialized = true;
            log.info("Exam role and permission initialization completed successfully");
        } catch (Exception e) {
            log.error("Error initializing exam roles and permissions: ", e);
        }
    }

    /**
     * Assign exam permissions to the appropriate roles
     */
    private void assignExamPermissionsToRoles() {
        log.info("Assigning exam permissions to roles");
        
        // Get all roles
        Optional<Role> adminRole = rolesRepository.findByName(RoleEnum.ADMIN);
        Optional<Role> superAdminRole = rolesRepository.findByName(RoleEnum.SUPER_ADMIN);
        Optional<Role> instructorRole = rolesRepository.findByName(RoleEnum.INSTRUCTOR);
        Optional<Role> studentRole = rolesRepository.findByName(RoleEnum.STUDENT);
        
        // Get existing exam permissions
        List<Permission> examPermissions = permissionDataLoaderService.getExamPermissions();
        Map<String, Permission> permissionMap = examPermissions.stream()
                .collect(Collectors.toMap(Permission::getName, p -> p));
        
        // Assign admin permissions
        if (adminRole.isPresent()) {
            assignPermissionsToRole(adminRole.get(), 
                Arrays.asList(ExamPermissionConstants.ADMIN_PERMISSIONS), 
                permissionMap);
        }
        
        // Super admin gets all permissions
        if (superAdminRole.isPresent()) {
            assignPermissionsToRole(superAdminRole.get(), 
                Arrays.asList(ExamPermissionConstants.ADMIN_PERMISSIONS), 
                permissionMap);
        }
        
        // Instructor permissions
        if (instructorRole.isPresent()) {
            assignPermissionsToRole(instructorRole.get(), 
                Arrays.asList(ExamPermissionConstants.INSTRUCTOR_PERMISSIONS), 
                permissionMap);
        }
        
        // Student permissions
        if (studentRole.isPresent()) {
            assignPermissionsToRole(studentRole.get(), 
                Arrays.asList(ExamPermissionConstants.STUDENT_PERMISSIONS), 
                permissionMap);
        }
    }
    
    /**
     * Assign permissions to a role
     */
    private void assignPermissionsToRole(Role role, List<String> permissionNames, 
                                        Map<String, Permission> permissionMap) {
        log.info("Assigning {} permissions to role: {}", permissionNames.size(), role.getName());
        
        // Get current permissions for the role
        Set<Permission> currentPermissions = role.getPermissions();
        if (currentPermissions == null) {
            currentPermissions = new HashSet<>();
            role.setPermissions(currentPermissions);
        }
        
        // Add each permission
        for (String permName : permissionNames) {
            Permission permission = permissionMap.get(permName);
            if (permission != null) {
                currentPermissions.add(permission);
            } else {
                log.warn("Permission not found: {}", permName);
            }
        }
        
        // Save the updated role
        rolesRepository.save(role);
    }
    
    /**
     * Create specific exam-related roles if they don't exist
     */
    private void createSpecificExamRoles() {
        log.info("Creating specific exam roles");
        
        // First check if some roles need to be created
        
        // Example: Create an EXAM_CREATOR role with specific permissions
        if (!rolesRepository.findByName(RoleEnum.EXAM_CREATOR).isPresent()) {
            log.info("Creating EXAM_CREATOR role");
            
            Role examCreatorRole = Role.builder()
                    .name(RoleEnum.EXAM_CREATOR)
                    .description("Role for creating and managing exams")
                    .precedence(70) // Between INSTRUCTOR and PHARMACIST
                    .system(true)
                    .build();
            
            // Save the role first to get an ID
            examCreatorRole = rolesRepository.save(examCreatorRole);
            
            // Get permissions for this role
            List<Permission> examPermissions = permissionDataLoaderService.getExamPermissions();
            Map<String, Permission> permissionMap = examPermissions.stream()
                    .collect(Collectors.toMap(Permission::getName, p -> p));
            
            // Assign specific permissions
            String[] permissionNames = {
                ExamPermissionConstants.CREATE_EXAM,
                ExamPermissionConstants.EDIT_EXAM,
                ExamPermissionConstants.MANAGE_QUESTIONS,
                ExamPermissionConstants.VIEW_EXAMS
            };
            
            Set<Permission> rolePermissions = new HashSet<>();
            for (String permName : permissionNames) {
                Permission permission = permissionMap.get(permName);
                if (permission != null) {
                    rolePermissions.add(permission);
                }
            }
            
            examCreatorRole.setPermissions(rolePermissions);
            rolesRepository.save(examCreatorRole);
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/initializer/RoleHierarchyInitializer.java">
package com.pharmacyhub.security.initializer;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;

import java.util.HashMap;
import java.util.Map;
import java.util.Optional;

/**
 * Initializes role hierarchy relationships
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class RoleHierarchyInitializer implements ApplicationListener<ContextRefreshedEvent> {
    private final RolesRepository rolesRepository;

    @Override
    @Transactional
    public void onApplicationEvent(ContextRefreshedEvent event) {
        // Wait for the RoleInitializer to complete
        if (rolesRepository.count() == 0) {
            log.info("Skipping role hierarchy initialization - roles not yet initialized");
            return;
        }
        
        if (isHierarchyInitialized()) {
            log.info("Role hierarchy already initialized");
            return;
        }

        log.info("Initializing role hierarchy");
        try {
            setupHierarchy();
            log.info("Role hierarchy initialized successfully");
        } catch (Exception e) {
            log.error("Error initializing role hierarchy: ", e);
        }
    }
    
    private boolean isHierarchyInitialized() {
        // Check if super admin role has child roles
        Optional<Role> superAdminRole = rolesRepository.findByName(RoleEnum.SUPER_ADMIN);
        if (superAdminRole.isPresent()) {
            Role role = rolesRepository.findByIdWithChildRoles(superAdminRole.get().getId());
            return role != null && !role.getChildRoles().isEmpty();
        }
        return false;
    }

    private void setupHierarchy() {
        // Load all roles
        Map<RoleEnum, Role> roleMap = new HashMap<>();
        
        for (RoleEnum roleEnum : RoleEnum.values()) {
            Optional<Role> role = rolesRepository.findByName(roleEnum);
            role.ifPresent(r -> roleMap.put(roleEnum, r));
        }
        
        // Setup hierarchy (higher precedence roles contain lower precedence ones)
        // SUPER_ADMIN > ADMIN > PROPRIETOR > PHARMACY_MANAGER > PHARMACIST/SALESMAN > USER
        
        // SUPER_ADMIN contains ADMIN
        setupChildRole(roleMap, RoleEnum.SUPER_ADMIN, RoleEnum.ADMIN);
        
        // ADMIN contains PROPRIETOR
        setupChildRole(roleMap, RoleEnum.ADMIN, RoleEnum.PROPRIETOR);
        
        // PROPRIETOR contains PHARMACY_MANAGER
        setupChildRole(roleMap, RoleEnum.PROPRIETOR, RoleEnum.PHARMACY_MANAGER);
        
        // PHARMACY_MANAGER contains PHARMACIST and SALESMAN
        setupChildRole(roleMap, RoleEnum.PHARMACY_MANAGER, RoleEnum.PHARMACIST);
        setupChildRole(roleMap, RoleEnum.PHARMACY_MANAGER, RoleEnum.SALESMAN);
        
        // PHARMACIST and SALESMAN contain USER
        setupChildRole(roleMap, RoleEnum.PHARMACIST, RoleEnum.USER);
        setupChildRole(roleMap, RoleEnum.SALESMAN, RoleEnum.USER);
    }
    
    private void setupChildRole(Map<RoleEnum, Role> roleMap, RoleEnum parentEnum, RoleEnum childEnum) {
        if (!roleMap.containsKey(parentEnum) || !roleMap.containsKey(childEnum)) {
            log.warn("Cannot set up hierarchy for {} > {}: one or both roles missing", parentEnum, childEnum);
            return;
        }
        
        Role parentRole = roleMap.get(parentEnum);
        Role childRole = roleMap.get(childEnum);
        
        // Load parent with child roles
        Role parent = rolesRepository.findByIdWithChildRoles(parentRole.getId());
        if (parent == null) {
            log.warn("Parent role {} not found with ID {}", parentEnum, parentRole.getId());
            return;
        }
        
        // Add child role if not already present
        if (parent.getChildRoles().stream().noneMatch(r -> r.getId().equals(childRole.getId()))) {
            parent.getChildRoles().add(childRole);
            rolesRepository.save(parent);
            log.info("Added {} as child of {}", childEnum, parentEnum);
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/initializer/RoleInitializer.java">
package com.pharmacyhub.security.initializer;

import com.pharmacyhub.security.constants.AuthPermissionConstants;
import com.pharmacyhub.security.constants.ExamPermissionConstants;
import com.pharmacyhub.security.domain.*;
import com.pharmacyhub.security.infrastructure.GroupRepository;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import com.pharmacyhub.constants.RoleEnum;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;

import java.util.*;

@Slf4j
@Component("roleInitializer")
@Order(Ordered.HIGHEST_PRECEDENCE)
@RequiredArgsConstructor
public class RoleInitializer implements ApplicationListener<ContextRefreshedEvent> {
    private final RolesRepository rolesRepository;
    private final PermissionRepository permissionRepository;
    private final GroupRepository groupRepository;

    @Override
    @Transactional
    public void onApplicationEvent(ContextRefreshedEvent event) {
        try {
            if (rolesRepository.count() > 0) {
                log.info("Roles already initialized");
                return;
            }

            log.info("Initializing default roles and permissions");
            Map<String, Permission> permissions = initializePermissions();
            Map<RoleEnum, Role> roles = initializeRoles(permissions);
            initializeGroups(roles);
            
            log.info("Role initialization completed successfully");
        } catch (Exception e) {
            log.error("Error initializing roles: ", e);
        }
    }

    private Map<String, Permission> initializePermissions() {
        log.info("Initializing permissions...");
        Map<String, Permission> permissionMap = new HashMap<>();
        
        // Common permissions
        permissionMap.put("VIEW_PROFILE", createPermission("VIEW_PROFILE", 
            "Permission to view user profile", ResourceType.USER, OperationType.READ, false));
        permissionMap.put("UPDATE_PROFILE", createPermission("UPDATE_PROFILE", 
            "Permission to update user profile", ResourceType.USER, OperationType.UPDATE, false));
            
        // Pharmacist permissions
        permissionMap.put("VIEW_PHARMACY_INVENTORY", createPermission("VIEW_PHARMACY_INVENTORY", 
            "View pharmacy inventory", ResourceType.INVENTORY, OperationType.READ, false));
        permissionMap.put("MANAGE_PHARMACY_INVENTORY", createPermission("MANAGE_PHARMACY_INVENTORY", 
            "Manage pharmacy inventory", ResourceType.INVENTORY, OperationType.MANAGE, false));
            
        // Manager permissions
        permissionMap.put("MANAGE_PHARMACY", createPermission("MANAGE_PHARMACY", 
            "Manage pharmacy operations", ResourceType.PHARMACY, OperationType.MANAGE, false));
        permissionMap.put("VIEW_PHARMACY", createPermission("VIEW_PHARMACY", 
            "View pharmacy details", ResourceType.PHARMACY, OperationType.READ, false));
            
        // Proprietor permissions
        permissionMap.put("MANAGE_BUSINESS", createPermission("MANAGE_BUSINESS", 
            "Manage pharmacy business", ResourceType.BUSINESS, OperationType.MANAGE, false));
            
        // Salesman permissions
        permissionMap.put("PROCESS_SALES", createPermission("PROCESS_SALES", 
            "Process sales transactions", ResourceType.SALES, OperationType.CREATE, false));
        permissionMap.put("VIEW_SALES", createPermission("VIEW_SALES", 
            "View sales records", ResourceType.SALES, OperationType.READ, false));
            
        // Admin permissions
        permissionMap.put("MANAGE_USERS", createPermission("MANAGE_USERS", 
            "Manage system users", ResourceType.USER, OperationType.MANAGE, false));
        permissionMap.put("MANAGE_ROLES", createPermission("MANAGE_ROLES", 
            "Manage system roles", ResourceType.ROLE, OperationType.MANAGE, false));
        permissionMap.put("MANAGE_PERMISSIONS", createPermission("MANAGE_PERMISSIONS", 
            "Manage system permissions", ResourceType.PERMISSION, OperationType.MANAGE, false));
        
        // Auth permissions
        for (String permName : AuthPermissionConstants.BASIC_USER_PERMISSIONS) {
            permissionMap.put(permName, createPermission(permName,
                "Permission to " + permName.replace("auth:", "").replace("-", " "),
                ResourceType.USER, getOperationTypeForPermission(permName), false));
        }
        
        for (String permName : AuthPermissionConstants.ADMIN_PERMISSIONS) {
            permissionMap.put(permName, createPermission(permName,
                "Admin permission to " + permName.replace("auth:", "").replace("-", " "),
                ResourceType.USER, getOperationTypeForPermission(permName), false));
        }
        
        // Exam permissions for students
        for (String permName : ExamPermissionConstants.STUDENT_PERMISSIONS) {
            permissionMap.put(permName, createPermission(permName,
                "Student permission to " + permName.replace("exams:", "").replace("-", " "),
                ResourceType.PHARMACY, getOperationTypeForPermission(permName), false));
        }
        
        // Exam permissions for instructors
        for (String permName : ExamPermissionConstants.INSTRUCTOR_PERMISSIONS) {
            if (!permissionMap.containsKey(permName)) {
                permissionMap.put(permName, createPermission(permName,
                    "Instructor permission to " + permName.replace("exams:", "").replace("-", " "),
                    ResourceType.PHARMACY, getOperationTypeForPermission(permName), false));
            }
        }
        
        // Admin exam permissions
        for (String permName : ExamPermissionConstants.ADMIN_PERMISSIONS) {
            if (!permissionMap.containsKey(permName)) {
                permissionMap.put(permName, createPermission(permName,
                    "Admin permission to " + permName.replace("exams:", "").replace("-", " "),
                    ResourceType.PHARMACY, getOperationTypeForPermission(permName), false));
            }
        }
        
        return permissionMap;
    }
    
    /**
     * Helper method to determine operation type from permission name
     */
    private OperationType getOperationTypeForPermission(String permissionName) {
        String lowerName = permissionName.toLowerCase();
        if (lowerName.contains("create") || lowerName.contains("add")) {
            return OperationType.CREATE;
        } else if (lowerName.contains("view") || lowerName.contains("read") || lowerName.contains("login") || lowerName.contains("logout")) {
            return OperationType.READ;
        } else if (lowerName.contains("edit") || lowerName.contains("update") || lowerName.contains("reset") || lowerName.contains("verify")) {
            return OperationType.UPDATE;
        } else if (lowerName.contains("delete") || lowerName.contains("remove")) {
            return OperationType.DELETE;
        } else if (lowerName.contains("approve")) {
            return OperationType.APPROVE;
        } else if (lowerName.contains("reject")) {
            return OperationType.REJECT;
        } else if (lowerName.contains("manage") || lowerName.contains("impersonate")) {
            return OperationType.MANAGE;
        } else if (lowerName.contains("export")) {
            return OperationType.EXPORT;
        } else if (lowerName.contains("import")) {
            return OperationType.IMPORT;
        } else {
            return OperationType.READ; // Default to READ
        }
    }

    private Map<RoleEnum, Role> initializeRoles(Map<String, Permission> permissions) {
        log.info("Initializing roles...");
        Map<RoleEnum, Role> roleMap = new HashMap<>();

        // Create USER role (lowest precedence - 100)
        Set<Permission> userPermissions = new HashSet<>();
        userPermissions.add(permissions.get("VIEW_PROFILE"));
        userPermissions.add(permissions.get("UPDATE_PROFILE"));
        
        // Add auth basic user permissions
        for (String permName : AuthPermissionConstants.BASIC_USER_PERMISSIONS) {
            addPermissionIfExists(userPermissions, permissions, permName);
        }
        
        Role userRole = Role.builder()
                .name(RoleEnum.USER)
                .description("Base user role with minimal permissions")
                .precedence(100)
                .permissions(userPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.USER, rolesRepository.save(userRole));
        
        // Create STUDENT role (precedence - 90)
        Set<Permission> studentPermissions = new HashSet<>(userPermissions);
        // Add student exam permissions
        for (String permName : ExamPermissionConstants.STUDENT_PERMISSIONS) {
            addPermissionIfExists(studentPermissions, permissions, permName);
        }
        
        Role studentRole = Role.builder()
                .name(RoleEnum.STUDENT)
                .description("Student role with exam taking permissions")
                .precedence(90)
                .permissions(studentPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.STUDENT, rolesRepository.save(studentRole));

        // Create PHARMACIST role (precedence - 80)
        Set<Permission> pharmacistPermissions = new HashSet<>(userPermissions);
        pharmacistPermissions.add(permissions.get("VIEW_PHARMACY_INVENTORY"));
        // Add exam permissions like view and take
        addPermissionIfExists(pharmacistPermissions, permissions, ExamPermissionConstants.VIEW_EXAMS);
        addPermissionIfExists(pharmacistPermissions, permissions, ExamPermissionConstants.TAKE_EXAM);
        
        Role pharmacistRole = Role.builder()
                .name(RoleEnum.PHARMACIST)
                .description("Pharmacist role with permissions to view inventory")
                .precedence(80)
                .permissions(pharmacistPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.PHARMACIST, rolesRepository.save(pharmacistRole));
        
        // Create TECHNICIAN role (precedence - 75)
        Set<Permission> technicianPermissions = new HashSet<>(pharmacistPermissions);
        // Additional technician permissions if needed
        

        // Create INSTRUCTOR role (precedence - 70)
        Set<Permission> instructorPermissions = new HashSet<>(userPermissions);
        // Add instructor exam permissions
        for (String permName : ExamPermissionConstants.INSTRUCTOR_PERMISSIONS) {
            addPermissionIfExists(instructorPermissions, permissions, permName);
        }
        
        Role instructorRole = Role.builder()
                .name(RoleEnum.INSTRUCTOR)
                .description("Instructor role with exam management permissions")
                .precedence(70)
                .permissions(instructorPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.INSTRUCTOR, rolesRepository.save(instructorRole));
        
        // Create EXAM_CREATOR role (precedence - 65)
        Set<Permission> examCreatorPermissions = new HashSet<>(userPermissions);
        // Add specific exam creation permissions
        addPermissionIfExists(examCreatorPermissions, permissions, ExamPermissionConstants.CREATE_EXAM);
        addPermissionIfExists(examCreatorPermissions, permissions, ExamPermissionConstants.EDIT_EXAM);
        addPermissionIfExists(examCreatorPermissions, permissions, ExamPermissionConstants.MANAGE_QUESTIONS);
        addPermissionIfExists(examCreatorPermissions, permissions, ExamPermissionConstants.VIEW_EXAMS);
        
        Role examCreatorRole = Role.builder()
                .name(RoleEnum.EXAM_CREATOR)
                .description("Role for creating and managing exams")
                .precedence(65)
                .permissions(examCreatorPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.EXAM_CREATOR, rolesRepository.save(examCreatorRole));

        // Create SALESMAN role (precedence - 85)
        Set<Permission> salesmanPermissions = new HashSet<>(userPermissions);
        salesmanPermissions.add(permissions.get("PROCESS_SALES"));
        salesmanPermissions.add(permissions.get("VIEW_SALES"));
        
        Role salesmanRole = Role.builder()
                .name(RoleEnum.SALESMAN)
                .description("Salesman role for processing sales")
                .precedence(85)
                .permissions(salesmanPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.SALESMAN, rolesRepository.save(salesmanRole));

        // Create PHARMACY_MANAGER role (precedence - 60)
        Set<Permission> managerPermissions = new HashSet<>(pharmacistPermissions);
        managerPermissions.add(permissions.get("MANAGE_PHARMACY_INVENTORY"));
        managerPermissions.add(permissions.get("MANAGE_PHARMACY"));
        
        Role managerRole = Role.builder()
                .name(RoleEnum.PHARMACY_MANAGER)
                .description("Pharmacy manager role for managing pharmacy operations")
                .precedence(60)
                .permissions(managerPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.PHARMACY_MANAGER, rolesRepository.save(managerRole));

        // Create PROPRIETOR role (precedence - 40)
        Set<Permission> proprietorPermissions = new HashSet<>(managerPermissions);
        proprietorPermissions.add(permissions.get("MANAGE_BUSINESS"));
        
        Role proprietorRole = Role.builder()
                .name(RoleEnum.PROPRIETOR)
                .description("Proprietor role for pharmacy business ownership")
                .precedence(40)
                .permissions(proprietorPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.PROPRIETOR, rolesRepository.save(proprietorRole));

        // Create ADMIN role (precedence - 20)
        // Admin gets ALL permissions just like super admin
        Set<Permission> adminPermissions = new HashSet<>(permissions.values());
        
        Role adminRole = Role.builder()
                .name(RoleEnum.ADMIN)
                .description("Administrator role with full system access")
                .precedence(20)
                .permissions(adminPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.ADMIN, rolesRepository.save(adminRole));

        // Create SUPER_ADMIN role (precedence - 10)
        // Super admin gets ALL permissions
        Set<Permission> superAdminPermissions = new HashSet<>(permissions.values());
        
        Role superAdminRole = Role.builder()
                .name(RoleEnum.SUPER_ADMIN)
                .description("Super administrator with highest privileges")
                .precedence(10)
                .permissions(superAdminPermissions)
                .system(true)
                .build();
        roleMap.put(RoleEnum.SUPER_ADMIN, rolesRepository.save(superAdminRole));

        return roleMap;
    }
    
    /**
     * Helper method to add a permission to a set if it exists in the map
     */
    private void addPermissionIfExists(Set<Permission> permissions, Map<String, Permission> permissionMap, String permissionName) {
        Permission permission = permissionMap.get(permissionName);
        if (permission != null) {
            permissions.add(permission);
        } else {
            log.warn("Permission not found: {}", permissionName);
        }
    }

    private void initializeGroups(Map<RoleEnum, Role> roles) {
        log.info("Initializing groups...");
        
        // Create Staff Group (Pharmacists, Salesmen, Technicians)
        Set<Role> staffRoles = new HashSet<>();
        staffRoles.add(roles.get(RoleEnum.PHARMACIST));
        staffRoles.add(roles.get(RoleEnum.SALESMAN));

        Group staffGroup = Group.builder()
                .name("PHARMACY_STAFF")
                .description("Group for pharmacy staff members")
                .roles(staffRoles)
                .build();
        groupRepository.save(staffGroup);
        
        // Create Management Group (Managers, Proprietors)
        Set<Role> managementRoles = new HashSet<>();
        managementRoles.add(roles.get(RoleEnum.PHARMACY_MANAGER));
        managementRoles.add(roles.get(RoleEnum.PROPRIETOR));
        
        Group managementGroup = Group.builder()
                .name("PHARMACY_MANAGEMENT")
                .description("Group for pharmacy management team")
                .roles(managementRoles)
                .build();
        groupRepository.save(managementGroup);
        
        // Create Education Group (Students, Instructors)
        Set<Role> educationRoles = new HashSet<>();
        educationRoles.add(roles.get(RoleEnum.STUDENT));
        educationRoles.add(roles.get(RoleEnum.INSTRUCTOR));
        educationRoles.add(roles.get(RoleEnum.EXAM_CREATOR));
        
        Group educationGroup = Group.builder()
                .name("EDUCATION")
                .description("Group for education-related roles")
                .roles(educationRoles)
                .build();
        groupRepository.save(educationGroup);
        
        // Create Admin Group
        Set<Role> adminRoles = new HashSet<>();
        adminRoles.add(roles.get(RoleEnum.ADMIN));
        
        Group adminGroup = Group.builder()
                .name("Administrators")
                .description("Group for system administrators")
                .roles(adminRoles)
                .build();
        groupRepository.save(adminGroup);
        
        // Create SuperAdmin Group
        Set<Role> superAdminRoles = new HashSet<>();
        superAdminRoles.add(roles.get(RoleEnum.SUPER_ADMIN));
        superAdminRoles.add(roles.get(RoleEnum.ADMIN)); // Super admins also have admin roles
        
        Group superAdminGroup = Group.builder()
                .name("SuperAdmins")
                .description("Group for super administrators")
                .roles(superAdminRoles)
                .build();
        groupRepository.save(superAdminGroup);
        
        // Create Demo User Group
        Set<Role> demoRoles = new HashSet<>();
        demoRoles.add(roles.get(RoleEnum.USER));
        
        Group demoGroup = Group.builder()
                .name("DemoUsers")
                .description("Group for demo users")
                .roles(demoRoles)
                .build();
        groupRepository.save(demoGroup);
    }

    private Permission createPermission(String name, String description, 
                                       ResourceType resourceType, OperationType operationType, 
                                       boolean requiresApproval) {
        log.info("Creating permission: {}", name);
        Permission permission = Permission.builder()
                .name(name)
                .description(description)
                .resourceType(resourceType)
                .operationType(operationType)
                .requiresApproval(requiresApproval)
                .build();
        return permissionRepository.save(permission);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/JwtAuthenticationEntryPoint.java">
package com.pharmacyhub.security;

import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.stereotype.Component;

import java.io.IOException;
import java.io.PrintWriter;

@Component
public class JwtAuthenticationEntryPoint implements AuthenticationEntryPoint
{
  @Override
  public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException
  {
    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
    PrintWriter writer = response.getWriter();
    writer.println("Access Denied !! " + authException.getMessage());
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/JwtAuthenticationFilter.java">
package com.pharmacyhub.security;

import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.MalformedJwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import com.fasterxml.jackson.databind.ObjectMapper;

@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter
{

  private static final Logger logger = LoggerFactory.getLogger(JwtAuthenticationFilter.class);
  private static final ObjectMapper objectMapper = new ObjectMapper();
  @Autowired
  private JwtHelper jwtHelper;


  @Autowired
  private UserDetailsService userDetailsService;

  @Override
  protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    // Skip authentication for authentication endpoints
    if (request.getRequestURI().startsWith("/api/auth/") ||
        request.getRequestURI().equals("/api/health") ||
        request.getRequestURI().equals("/health") ||
        request.getRequestURI().startsWith("/api/public/") ||
        request.getRequestURI().startsWith("/swagger-ui/") ||
        request.getRequestURI().startsWith("/v3/api-docs/")) {
      filterChain.doFilter(request, response);
      return;
    }

    String requestHeader = request.getHeader("Authorization");
    logger.debug("Authorization Header: {}", requestHeader);
    
    // If no Authorization header or not Bearer token, continue with filter chain
    if (requestHeader == null || !requestHeader.startsWith("Bearer ")) {
      logger.debug("No Bearer token found in request");
      filterChain.doFilter(request, response);
      return;
    }
    
    // Extract token
    String token = requestHeader.substring(7);
    String username = null;
    
    try {
      // Get username from token
      username = jwtHelper.getUsernameFromToken(token);
      logger.debug("Token is for user: {}", username);
      
      // If we have valid token and no current authentication
      if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
        try {
          // Load user details
          UserDetails userDetails = userDetailsService.loadUserByUsername(username);
          
          // Validate token
          boolean isTokenValid = jwtHelper.validateToken(token, userDetails);
          
          if (isTokenValid) {
            // Create authentication token
            UsernamePasswordAuthenticationToken authentication = 
                new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());
            
            // Add request details to authentication
            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            
            // Set authentication in security context
            SecurityContextHolder.getContext().setAuthentication(authentication);
            logger.debug("Authentication successful for user: {}", username);
          } else {
            logger.warn("Token validation failed for user: {}", username);
            // Don't return early, let the request continue as unauthenticated
          }
        } catch (UsernameNotFoundException e) {
          logger.error("User not found: {}", username);
          // Don't return early, let the request continue as unauthenticated
        }
      }
    } catch (ExpiredJwtException e) {
      logger.error("JWT token is expired: {}", e.getMessage());
      // Don't return early, let the request continue as unauthenticated
    } catch (MalformedJwtException e) {
      logger.error("Invalid JWT token: {}", e.getMessage());
      // Don't return early, let the request continue as unauthenticated
    } catch (Exception e) {
      logger.error("Error processing JWT token: {}", e.getMessage());
      // Don't return early, let the request continue as unauthenticated
    }
    
    filterChain.doFilter(request, response);
  }
  
  /**
   * Helper method to send error response
   */
  private void sendErrorResponse(HttpServletResponse response, int status, String error, String message) throws IOException {
    response.setStatus(status);
    response.setContentType(MediaType.APPLICATION_JSON_VALUE);
    
    objectMapper.writeValue(response.getOutputStream(), 
        new ErrorResponse(error, message));
  }
  
  /**
   * Simple error response class
   */
  private static class ErrorResponse {
    private final String error;
    private final String message;
    
    public ErrorResponse(String error, String message) {
      this.error = error;
      this.message = message;
    }
    
    public String getError() {
      return error;
    }
    
    public String getMessage() {
      return message;
    }
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/JwtHelper.java">
package com.pharmacyhub.security;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.service.RBACService;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.SignatureAlgorithm;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Component;

import java.util.*;
import java.util.function.Function;
import java.util.stream.Collectors;

@Component
public class JwtHelper
{

  @Autowired
  private UserRepository userRepository;
  
  @Autowired
  private RBACService rbacService;

  @Value("${pharmacyhub.security.jwt.token-validity-in-seconds:18000}")
  private long tokenValidityInSeconds;

  @Value("${pharmacyhub.security.jwt.secret:pharmacyhub_jwt_secret_key_for_token_generation_and_validation_2025}")
  private String secret;

  //retrieve username from jwt token
  public String getUsernameFromToken(String token)
  {
    return getClaimFromToken(token, Claims::getSubject);
  }

  //retrieve expiration date from jwt token
  public Date getExpirationDateFromToken(String token)
  {
    return getClaimFromToken(token, Claims::getExpiration);
  }

  public <T> T getClaimFromToken(String token, Function<Claims, T> claimsResolver)
  {
    final Claims claims = getAllClaimsFromToken(token);
    return claimsResolver.apply(claims);
  }

  //for retrieveing any information from token we will need the secret key
  protected Claims getAllClaimsFromToken(String token)
  {
    return Jwts.parserBuilder()
            .setSigningKey(io.jsonwebtoken.security.Keys.hmacShaKeyFor(secret.getBytes()))
            .build()
            .parseClaimsJws(token)
            .getBody();
  }

  //check if the token has expired
  private Boolean isTokenExpired(String token)
  {
    final Date expiration = getExpirationDateFromToken(token);
    return expiration.before(new Date());
  }

  //generate token for user
  public String generateToken(UserDetails userDetails)
  {
    Map<String, Object> claims = new HashMap<>();
    
    // Add custom claims for roles and permissions
    if (userDetails instanceof User) {
        addRolesAndPermissionsToClaims(claims, (User) userDetails);
    } else {
        // Fallback for non-User implementations
        User user = userRepository.findByEmailAddress(userDetails.getUsername())
            .orElseThrow(() -> new UsernameNotFoundException("User not found: " + userDetails.getUsername()));
        addRolesAndPermissionsToClaims(claims, user);
    }
    
    return doGenerateToken(claims, userDetails.getUsername());
  }
  
  private void addRolesAndPermissionsToClaims(Map<String, Object> claims, User user) {
      // Add user ID
      claims.put("userId", user.getId());
      
      // Add user type
      if (user.getUserType() != null) {
          claims.put("userType", user.getUserType().name());
      }
      
      // Add user profile info
      claims.put("firstName", user.getFirstName());
      claims.put("lastName", user.getLastName());
      claims.put("emailAddress", user.getEmailAddress());
      claims.put("contactNumber", user.getContactNumber());
      claims.put("verified", user.isVerified());
      claims.put("registered", user.isRegistered());
      claims.put("openToConnect", user.isOpenToConnect());
      
      // Get roles and create a list of role names
      Set<Role> userRoles = rbacService.getUserRoles(user.getId());
      List<String> roleNames = userRoles.stream()
          .map(Role::getName)
          .collect(Collectors.toList());
      claims.put("roles", roleNames);
      
      // Get user permissions and create a list of permission names
      Set<Permission> permissions = rbacService.getUserEffectivePermissions(user.getId());
      List<String> permissionNames = permissions.stream()
          .map(Permission::getName)
          .collect(Collectors.toList());
      claims.put("permissions", permissionNames);
      
      // Add Spring Security compatible authorities
      Set<String> authorities = new HashSet<>();
      
      // Add role-based authorities (ROLE_XXX format for Spring Security)
      roleNames.forEach(role -> authorities.add("ROLE_" + role));
      
      // Add permissions directly as authorities
      authorities.addAll(permissionNames);
      
      claims.put("authorities", authorities);
  }

  //while creating the token -
  //1. Define  claims of the token, like Issuer, Expiration, Subject, and the ID
  //2. Sign the JWT using the HS512 algorithm and secret key.
  //3. According to JWS Compact Serialization(https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41#section-3.1)
  //   compaction of the JWT to a URL-safe string
  private String doGenerateToken(Map<String, Object> claims, String subject)
  {
    return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(new Date(System.currentTimeMillis()))
            .setExpiration(new Date(System.currentTimeMillis() + tokenValidityInSeconds * 1000))
            .signWith(io.jsonwebtoken.security.Keys.hmacShaKeyFor(secret.getBytes()), io.jsonwebtoken.SignatureAlgorithm.HS512)
            .compact();
  }

  //validate token
  public Boolean validateToken(String token, UserDetails userDetails) {
    try {
      final String username = getUsernameFromToken(token);
      
      // Validate username and token expiration
      if (!username.equals(userDetails.getUsername()) || isTokenExpired(token)) {
        return false;
      }
      
      // Additional checks for user status when userDetails is our User class
      if (userDetails instanceof User) {
        User user = (User) userDetails;
        
        // Check if user is enabled and account not locked
        if (!user.isEnabled() || !user.isAccountNonLocked()) {
          return false;
        }
        
        // TODO: Check if user is verified (optional, depending on your requirements)
//        if (!user.isVerified()) {
//          return false;
//        }
      }
      
      return true;
    } catch (Exception e) {
      return false;
    }
  }
  
  /**
   * Extract user permissions from token
   */
  @SuppressWarnings("unchecked")
  public List<String> getPermissionsFromToken(String token) {
      final Claims claims = getAllClaimsFromToken(token);
      return claims.get("permissions", List.class);
  }
  
  /**
   * Extract user roles from token
   */
  @SuppressWarnings("unchecked")
  public List<String> getRolesFromToken(String token) {
      final Claims claims = getAllClaimsFromToken(token);
      return claims.get("roles", List.class);
  }
  
  /**
   * Extract user ID from token
   */
  public Long getUserIdFromToken(String token) {
      final Claims claims = getAllClaimsFromToken(token);
      return claims.get("userId", Long.class);
  }
  
  /**
   * Get all authorities from token (roles and permissions)
   */
  @SuppressWarnings("unchecked")
  public List<SimpleGrantedAuthority> getAuthoritiesFromToken(String token) {
      final Claims claims = getAllClaimsFromToken(token);
      List<String> authorities = claims.get("authorities", List.class);
      
      if (authorities == null) {
          return Collections.emptyList();
      }
      
      return authorities.stream()
          .map(SimpleGrantedAuthority::new)
          .collect(Collectors.toList());
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/model/ErrorResponse.java">
package com.pharmacyhub.security.model;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ErrorResponse {
    private String message;
    private String details;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/model/LoginRequest.java">
package com.pharmacyhub.security.model;

import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class LoginRequest
{
    private String emailAddress;
    private String password;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/AuditService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.domain.AuditLog;
import com.pharmacyhub.security.infrastructure.AuditLogRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.List;

@Service
public class AuditService {
    
    @Autowired
    private AuditLogRepository auditLogRepository;

    public void logSecurityEvent(String action, String details, String outcome) {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        String username = auth != null ? auth.getName() : "SYSTEM";
        Long userId = null;

        if (auth != null && auth.getPrincipal() instanceof User) {
            User user = (User) auth.getPrincipal();
            userId = user.getId();
        }

        AuditLog log = AuditLog.builder()
                .username(username)
                .userId(userId)
                .action(action)
                .details(details)
                .outcome(outcome)
                .timestamp(LocalDateTime.now())
                .build();

        auditLogRepository.save(log);
    }

    public List<AuditLog> getUserAuditLogs(Long userId, Pageable pageable) {
        return auditLogRepository.findByUserId(userId, pageable);
    }

    public List<AuditLog> getAllAuditLogs() {
        return auditLogRepository.findAllByOrderByTimestampDesc();
    }

    public List<AuditLog> getAuditLogsByAction(String action) {
        return auditLogRepository.findByActionOrderByTimestampDesc(action);
    }

    public List<AuditLog> getAuditLogsByDateRange(LocalDateTime startDate, LocalDateTime endDate) {
        return auditLogRepository.findByTimestampBetweenOrderByTimestampDesc(startDate, endDate);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/AuthenticationService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.JwtHelper;
import com.pharmacyhub.security.infrastructure.exception.UnverifiedAccountException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Service;

/**
 * Service for handling authentication operations
 */
@Service
public class AuthenticationService {
    
    private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);
    
    @Autowired
    private AuthenticationManager authenticationManager;
    
    @Autowired
    private JwtHelper jwtHelper;
    
    /**
     * Authenticate a user with username and password and verify account status
     * 
     * @param username The username (email)
     * @param password The password
     * @return The authenticated user
     * @throws org.springframework.security.core.AuthenticationException if authentication fails
     * @throws UnverifiedAccountException if the account is not verified
     */
    public User authenticateUser(String username, String password) {
        logger.debug("Attempting to authenticate user: {}", username);
        
        // Create authentication token
        UsernamePasswordAuthenticationToken authToken = 
                new UsernamePasswordAuthenticationToken(username, password);
        
        // Authenticate - this will throw an exception if authentication fails
        Authentication authentication = authenticationManager.authenticate(authToken);
        
        // Get the authenticated user
        User authenticatedUser = (User) authentication.getPrincipal();
        

        // TODO:: Check if user is verified
//        if (!authenticatedUser.isVerified()) {
//            throw new UnverifiedAccountException("User account is not verified: " + username);
//        }
        
        logger.debug("User authenticated successfully: {}", username);
        return authenticatedUser;
    }
    
    /**
     * Generate a JWT token for a user
     * 
     * @param user The authenticated user
     * @return The JWT token
     */
    public String generateToken(User user) {
        logger.debug("Generating JWT token for user: {}", user.getUsername());
        return jwtHelper.generateToken(user);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/FeatureService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.security.domain.Feature;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.dto.FeatureDTO;
import com.pharmacyhub.security.exception.RBACException;
import com.pharmacyhub.security.infrastructure.FeatureRepository;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

@Service
@Transactional
@RequiredArgsConstructor
@Slf4j
public class FeatureService {
    private final FeatureRepository featureRepository;
    private final PermissionRepository permissionRepository;
    private final AuditService auditService;

    /**
     * Get all features
     */
    public List<Feature> getAllFeatures() {
        return featureRepository.findAll();
    }

    /**
     * Get a feature by its code
     */
    public Feature getFeatureByCode(String code) {
        return featureRepository.findByCode(code)
                .orElseThrow(() -> RBACException.entityNotFound("Feature with code " + code));
    }

    /**
     * Create a new feature
     */
    @CacheEvict(value = {"featureAccess", "userFeatures"}, allEntries = true)
    public Feature createFeature(FeatureDTO featureDTO) {
        // Validate feature input
        if (featureDTO.getCode() == null || featureDTO.getCode().trim().isEmpty()) {
            throw RBACException.invalidInput("Feature code is required");
        }
        
        if (featureDTO.getName() == null || featureDTO.getName().trim().isEmpty()) {
            throw RBACException.invalidInput("Feature name is required");
        }
        
        // Check for duplicates
        if (featureRepository.findByCode(featureDTO.getCode()).isPresent()) {
            throw RBACException.duplicateEntity("Feature with code " + featureDTO.getCode() + " already exists");
        }
        
        // Create the feature
        Feature feature = Feature.builder()
                .name(featureDTO.getName())
                .description(featureDTO.getDescription())
                .code(featureDTO.getCode())
                .active(featureDTO.isActive())
                .build();
        
        // Set parent feature if provided
        if (featureDTO.getParentFeatureId() != null) {
            Feature parentFeature = featureRepository.findById(featureDTO.getParentFeatureId())
                    .orElseThrow(() -> RBACException.entityNotFound("Parent Feature"));
            feature.setParentFeature(parentFeature);
        }
        
        // Set permissions if provided
        if (featureDTO.getPermissions() != null && !featureDTO.getPermissions().isEmpty()) {
            Set<Permission> permissions = new HashSet<>();
            
            for (String permissionName : featureDTO.getPermissions()) {
                Permission permission = permissionRepository.findByName(permissionName)
                        .orElseThrow(() -> RBACException.entityNotFound("Permission " + permissionName));
                permissions.add(permission);
            }
            
            feature.setPermissions(permissions);
        }
        
        Feature savedFeature = featureRepository.save(feature);
        
        auditService.logSecurityEvent(
            "CREATE_FEATURE",
            String.format("Created feature '%s' with code '%s'", feature.getName(), feature.getCode()),
            "SUCCESS"
        );
        
        return savedFeature;
    }
    
    /**
     * Update an existing feature
     */
    @CacheEvict(value = {"featureAccess", "userFeatures"}, allEntries = true)
    public Feature updateFeature(Long featureId, FeatureDTO featureDTO) {
        Feature existingFeature = featureRepository.findById(featureId)
                .orElseThrow(() -> RBACException.entityNotFound("Feature"));
        
        // Update fields if provided
        if (featureDTO.getName() != null) {
            existingFeature.setName(featureDTO.getName());
        }
        
        if (featureDTO.getDescription() != null) {
            existingFeature.setDescription(featureDTO.getDescription());
        }
        
        if (featureDTO.getCode() != null) {
            // Check for duplicates if code is being changed
            if (!existingFeature.getCode().equals(featureDTO.getCode())) {
                if (featureRepository.findByCode(featureDTO.getCode()).isPresent()) {
                    throw RBACException.duplicateEntity("Feature with code " + featureDTO.getCode() + " already exists");
                }
            }
            existingFeature.setCode(featureDTO.getCode());
        }
        
        existingFeature.setActive(featureDTO.isActive());
        
        // Update parent feature if provided
        if (featureDTO.getParentFeatureId() != null) {
            if (featureDTO.getParentFeatureId().equals(featureId)) {
                throw RBACException.invalidInput("A feature cannot be its own parent");
            }
            
            Feature parentFeature = featureRepository.findById(featureDTO.getParentFeatureId())
                    .orElseThrow(() -> RBACException.entityNotFound("Parent Feature"));
            existingFeature.setParentFeature(parentFeature);
        } else if (featureDTO.getParentFeatureId() == null && existingFeature.getParentFeature() != null) {
            // Remove parent if null is explicitly provided
            existingFeature.setParentFeature(null);
        }
        
        // Update permissions if provided
        if (featureDTO.getPermissions() != null) {
            Set<Permission> permissions = new HashSet<>();
            
            for (String permissionName : featureDTO.getPermissions()) {
                Permission permission = permissionRepository.findByName(permissionName)
                        .orElseThrow(() -> RBACException.entityNotFound("Permission " + permissionName));
                permissions.add(permission);
            }
            
            existingFeature.setPermissions(permissions);
        }
        
        Feature updatedFeature = featureRepository.save(existingFeature);
        
        auditService.logSecurityEvent(
            "UPDATE_FEATURE",
            String.format("Updated feature '%s' with code '%s'", updatedFeature.getName(), updatedFeature.getCode()),
            "SUCCESS"
        );
        
        return updatedFeature;
    }
    
    /**
     * Delete a feature
     */
    @CacheEvict(value = {"featureAccess", "userFeatures"}, allEntries = true)
    public void deleteFeature(Long featureId) {
        Feature feature = featureRepository.findById(featureId)
                .orElseThrow(() -> RBACException.entityNotFound("Feature"));
        
        // Check if feature has child features
        if (!feature.getChildFeatures().isEmpty()) {
            throw RBACException.invalidOperation("Cannot delete feature with child features");
        }
        
        featureRepository.delete(feature);
        
        auditService.logSecurityEvent(
            "DELETE_FEATURE",
            String.format("Deleted feature '%s' with code '%s'", feature.getName(), feature.getCode()),
            "SUCCESS"
        );
    }
    
    /**
     * Convert Feature to FeatureDTO
     */
    public FeatureDTO convertFeatureToDTO(Feature feature) {
        FeatureDTO dto = FeatureDTO.builder()
                .id(feature.getId())
                .name(feature.getName())
                .description(feature.getDescription())
                .code(feature.getCode())
                .active(feature.isActive())
                .parentFeatureId(feature.getParentFeature() != null ? feature.getParentFeature().getId() : null)
                .permissions(feature.getPermissions().stream()
                        .map(Permission::getName)
                        .collect(Collectors.toList()))
                .build();
        
        // Add child features if any
        if (feature.getChildFeatures() != null && !feature.getChildFeatures().isEmpty()) {
            List<FeatureDTO> childFeatureDTOs = feature.getChildFeatures().stream()
                    .map(this::convertFeatureToDTO)
                    .collect(Collectors.toList());
            dto.setChildFeatures(childFeatureDTOs);
        }
        
        return dto;
    }
    
    /**
     * Get all permissions for a feature, including those from parent features
     */
    public Set<Permission> getAllFeaturePermissions(Feature feature) {
        Set<Permission> allPermissions = new HashSet<>(feature.getPermissions());
        
        // Add permissions from parent feature recursively
        Feature parentFeature = feature.getParentFeature();
        if (parentFeature != null) {
            allPermissions.addAll(getAllFeaturePermissions(parentFeature));
        }
        
        return allPermissions;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/PermissionDataLoaderService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.security.constants.AuthPermissionConstants;
import com.pharmacyhub.security.constants.ExamPermissionConstants;
import com.pharmacyhub.security.constants.PermissionConstants;
import com.pharmacyhub.security.domain.OperationType;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import jakarta.annotation.PostConstruct;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;
import java.util.stream.Collectors;

/**
 * Service responsible for loading and caching permission data
 * Ensures all required permissions are available in the system
 */
@Service
@Slf4j
@RequiredArgsConstructor
public class PermissionDataLoaderService {
    private final PermissionRepository permissionRepository;
    
    // Cache of permission definitions to avoid re-creation during initialization
    private final Map<String, PermissionDefinition> permissionDefinitions = new HashMap<>();
    
    /**
     * Initialize the permissions data loader
     * This method runs after the bean has been constructed
     */
    @PostConstruct
    @Transactional
    public void initialize() {
        log.info("Initializing Permission Data Loader Service...");
        
        // Load all permission definitions first
        loadAllPermissionDefinitions();
        
        // Synchronize repository with definitions
        synchronizePermissions();
    }
    
    /**
     * Load all permission definitions from the different modules
     */
    private void loadAllPermissionDefinitions() {
        log.info("Loading permission definitions...");
        
        // Load core permissions
        loadCorePermissions();
        
        // Load auth-specific permissions
        loadAuthPermissions();
        
        // Load exam-specific permissions
        loadExamPermissions();
        
        // Add more module-specific permissions here as needed
        
        log.info("Loaded {} permission definitions", permissionDefinitions.size());
    }
    
    /**
     * Load core permissions from PermissionConstants class
     */
    private void loadCorePermissions() {
        // User Management
        definePermission(PermissionConstants.MANAGE_USERS, 
            "Manage all users in the system", ResourceType.USER, OperationType.MANAGE);
        definePermission(PermissionConstants.VIEW_USERS, 
            "View users in the system", ResourceType.USER, OperationType.READ);
        
        // Role Management
        definePermission(PermissionConstants.MANAGE_ROLES, 
            "Manage system roles", ResourceType.ROLE, OperationType.MANAGE);
        
        // Permission Management
        definePermission(PermissionConstants.MANAGE_PERMISSIONS, 
            "Manage system permissions", ResourceType.PERMISSION, OperationType.MANAGE);
        
        // Group Management
        definePermission(PermissionConstants.MANAGE_GROUPS, 
            "Manage system groups", ResourceType.GROUP, OperationType.MANAGE);
        
        // System Management
        definePermission(PermissionConstants.MANAGE_SYSTEM, 
            "Manage system operations", ResourceType.SYSTEM_SETTING, OperationType.MANAGE);
        definePermission(PermissionConstants.MANAGE_SYSTEM_SETTINGS, 
            "Manage system settings", ResourceType.SYSTEM_SETTING, OperationType.UPDATE);
        
        // Audit Management
        definePermission(PermissionConstants.VIEW_AUDIT_LOGS, 
            "View all audit logs", ResourceType.AUDIT_LOG, OperationType.READ);
        definePermission(PermissionConstants.VIEW_OWN_AUDIT_LOGS, 
            "View own audit logs", ResourceType.AUDIT_LOG, OperationType.VIEW_OWN);
        definePermission(PermissionConstants.EXPORT_AUDIT_LOGS, 
            "Export audit logs", ResourceType.AUDIT_LOG, OperationType.EXPORT);
        
        // Inventory Management
        definePermission(PermissionConstants.MANAGE_INVENTORY, 
            "Manage inventory", ResourceType.INVENTORY, OperationType.MANAGE);
        definePermission(PermissionConstants.VIEW_PRODUCTS, 
            "View products", ResourceType.MEDICINE, OperationType.READ);
        
        // Reports
        definePermission(PermissionConstants.VIEW_REPORTS, 
            "View reports", ResourceType.REPORTS, OperationType.READ);
    }
    
    /**
     * Load auth-specific permissions from AuthPermissionConstants class
     */
    private void loadAuthPermissions() {
        // Authentication
        definePermission(AuthPermissionConstants.LOGIN, 
            "Log into the system", ResourceType.USER, OperationType.READ);
        definePermission(AuthPermissionConstants.LOGOUT, 
            "Log out of the system", ResourceType.USER, OperationType.READ);
        definePermission(AuthPermissionConstants.REGISTER, 
            "Register a new account", ResourceType.USER, OperationType.CREATE);
        
        // Account Management
        definePermission(AuthPermissionConstants.MANAGE_ACCOUNT, 
            "Manage own account settings", ResourceType.USER, OperationType.UPDATE);
        definePermission(AuthPermissionConstants.VERIFY_EMAIL, 
            "Verify email address", ResourceType.USER, OperationType.UPDATE);
        definePermission(AuthPermissionConstants.RESET_PASSWORD, 
            "Reset password", ResourceType.USER, OperationType.UPDATE);
        
        // Profile
        definePermission(AuthPermissionConstants.VIEW_PROFILE, 
            "View own profile", ResourceType.USER, OperationType.READ);
        definePermission(AuthPermissionConstants.EDIT_PROFILE, 
            "Edit own profile", ResourceType.USER, OperationType.UPDATE);
        
        // Sessions
        definePermission(AuthPermissionConstants.MANAGE_SESSIONS, 
            "Manage active sessions", ResourceType.USER, OperationType.MANAGE);
        definePermission(AuthPermissionConstants.VIEW_SESSIONS, 
            "View active sessions", ResourceType.USER, OperationType.READ);
        
        // User Management (Admin)
        definePermission(AuthPermissionConstants.MANAGE_USERS, 
            "Manage all users", ResourceType.USER, OperationType.MANAGE);
        definePermission(AuthPermissionConstants.VIEW_USERS, 
            "View all users", ResourceType.USER, OperationType.READ);
        definePermission(AuthPermissionConstants.EDIT_USERS, 
            "Edit user details", ResourceType.USER, OperationType.UPDATE);
        definePermission(AuthPermissionConstants.DELETE_USERS, 
            "Delete users", ResourceType.USER, OperationType.DELETE);
        definePermission(AuthPermissionConstants.IMPERSONATE_USER, 
            "Impersonate other users", ResourceType.USER, OperationType.MANAGE, true); // Requires approval
    }
    
    /**
     * Load exam-specific permissions from ExamPermissionConstants class
     */
    private void loadExamPermissions() {
        // Basic Exam Access
        definePermission(ExamPermissionConstants.VIEW_EXAMS, 
            "View available exams", ResourceType.PHARMACY, OperationType.READ);
        definePermission(ExamPermissionConstants.TAKE_EXAM, 
            "Take exams", ResourceType.PHARMACY, OperationType.UPDATE);
        
        // Exam Creation & Management
        definePermission(ExamPermissionConstants.CREATE_EXAM, 
            "Create new exams", ResourceType.PHARMACY, OperationType.CREATE);
        definePermission(ExamPermissionConstants.EDIT_EXAM, 
            "Edit existing exams", ResourceType.PHARMACY, OperationType.UPDATE);
        definePermission(ExamPermissionConstants.DELETE_EXAM, 
            "Delete exams", ResourceType.PHARMACY, OperationType.DELETE);
        definePermission(ExamPermissionConstants.DUPLICATE_EXAM, 
            "Duplicate exams", ResourceType.PHARMACY, OperationType.CREATE);
        
        // Question Management
        definePermission(ExamPermissionConstants.MANAGE_QUESTIONS, 
            "Manage questions within exams", ResourceType.PHARMACY, OperationType.MANAGE);
        
        // Exam Administration
        definePermission(ExamPermissionConstants.PUBLISH_EXAM, 
            "Publish exams to make them available", ResourceType.PHARMACY, OperationType.UPDATE);
        definePermission(ExamPermissionConstants.UNPUBLISH_EXAM, 
            "Unpublish exams", ResourceType.PHARMACY, OperationType.UPDATE);
        definePermission(ExamPermissionConstants.ASSIGN_EXAM, 
            "Assign exams to users", ResourceType.PHARMACY, OperationType.UPDATE);
        
        // Results & Grading
        definePermission(ExamPermissionConstants.GRADE_EXAM, 
            "Grade exam attempts", ResourceType.PHARMACY, OperationType.UPDATE);
        definePermission(ExamPermissionConstants.VIEW_RESULTS, 
            "View exam results", ResourceType.PHARMACY, OperationType.READ);
        definePermission(ExamPermissionConstants.EXPORT_RESULTS, 
            "Export exam results", ResourceType.REPORTS, OperationType.EXPORT);
        
        // Analytics
        definePermission(ExamPermissionConstants.VIEW_ANALYTICS, 
            "View exam analytics", ResourceType.ANALYTICS, OperationType.READ);
    }
    
    /**
     * Define a permission with the given attributes
     */
    private void definePermission(String name, String description, 
                                 ResourceType resourceType, OperationType operationType,
                                 boolean requiresApproval) {
        permissionDefinitions.put(name, new PermissionDefinition(
            name, description, resourceType, operationType, requiresApproval
        ));
    }
    
    /**
     * Define a permission with default requiresApproval = false
     */
    private void definePermission(String name, String description, 
                                 ResourceType resourceType, OperationType operationType) {
        definePermission(name, description, resourceType, operationType, false);
    }
    
    /**
     * Synchronize permissions in the database with the defined permissions
     */
    @Transactional
    public void synchronizePermissions() {
        log.info("Synchronizing permissions with database...");
        
        // Get all existing permissions from the database
        List<Permission> existingPermissions = permissionRepository.findAll();
        Map<String, Permission> existingPermissionMap = existingPermissions.stream()
                .collect(Collectors.toMap(Permission::getName, p -> p));
        
        int created = 0;
        int updated = 0;
        
        // Synchronize each defined permission
        for (PermissionDefinition definition : permissionDefinitions.values()) {
            Permission permission = existingPermissionMap.get(definition.getName());
            
            if (permission == null) {
                // Create new permission
                permission = Permission.builder()
                        .name(definition.getName())
                        .description(definition.getDescription())
                        .resourceType(definition.getResourceType())
                        .operationType(definition.getOperationType())
                        .requiresApproval(definition.isRequiresApproval())
                        .build();
                permissionRepository.save(permission);
                created++;
            } else {
                // Update existing permission if needed
                boolean needsUpdate = false;
                
                if (!Objects.equals(permission.getDescription(), definition.getDescription())) {
                    permission.setDescription(definition.getDescription());
                    needsUpdate = true;
                }
                
                if (permission.getResourceType() != definition.getResourceType()) {
                    permission.setResourceType(definition.getResourceType());
                    needsUpdate = true;
                }
                
                if (permission.getOperationType() != definition.getOperationType()) {
                    permission.setOperationType(definition.getOperationType());
                    needsUpdate = true;
                }
                
                if (permission.isRequiresApproval() != definition.isRequiresApproval()) {
                    permission.setRequiresApproval(definition.isRequiresApproval());
                    needsUpdate = true;
                }
                
                if (needsUpdate) {
                    permissionRepository.save(permission);
                    updated++;
                }
            }
        }
        
        log.info("Permission synchronization complete. Created: {}, Updated: {}", created, updated);
    }
    
    /**
     * Get all permission data in a structured format
     * This is primarily used for the frontend to display all available permissions
     */
    @Cacheable("permissionStructure")
    public Map<String, List<Map<String, Object>>> getPermissionStructure() {
        log.debug("Building permission structure...");
        Map<String, List<Map<String, Object>>> structure = new HashMap<>();
        
        // Group permissions by resource type
        List<Permission> permissions = permissionRepository.findAll();
        Map<ResourceType, List<Permission>> permissionsByResource = permissions.stream()
                .collect(Collectors.groupingBy(Permission::getResourceType));
        
        // Convert to structured format
        for (Map.Entry<ResourceType, List<Permission>> entry : permissionsByResource.entrySet()) {
            String resourceType = entry.getKey().name();
            List<Map<String, Object>> permList = new ArrayList<>();
            
            for (Permission perm : entry.getValue()) {
                Map<String, Object> permData = new HashMap<>();
                permData.put("name", perm.getName());
                permData.put("description", perm.getDescription());
                permData.put("operation", perm.getOperationType().name());
                permData.put("requiresApproval", perm.isRequiresApproval());
                
                permList.add(permData);
            }
            
            structure.put(resourceType, permList);
        }
        
        return structure;
    }
    
    /**
     * Get permissions by resource type
     */
    @Cacheable("permissionsByResource")
    public List<Permission> getPermissionsByResourceType(ResourceType resourceType) {
        return permissionRepository.findAll().stream()
                .filter(p -> p.getResourceType() == resourceType)
                .collect(Collectors.toList());
    }
    
    /**
     * Get all permissions
     */
    @Cacheable("allPermissions")
    public List<Permission> getAllPermissions() {
        return permissionRepository.findAll();
    }
    
    /**
     * Get permissions for a specific feature
     */
    @Cacheable("featurePermissions")
    public List<Permission> getFeaturePermissions(String feature) {
        String prefix = feature + ":";
        return permissionRepository.findAll().stream()
                .filter(p -> p.getName().startsWith(prefix))
                .collect(Collectors.toList());
    }
    
    /**
     * Get permissions for the exams feature
     */
    public List<Permission> getExamPermissions() {
        return getFeaturePermissions("exams");
    }
    
    /**
     * Get permissions for the auth feature
     */
    public List<Permission> getAuthPermissions() {
        return getFeaturePermissions("auth");
    }
    
    /**
     * PermissionDefinition - Internal class for defining permissions
     */
    private static class PermissionDefinition {
        private final String name;
        private final String description;
        private final ResourceType resourceType;
        private final OperationType operationType;
        private final boolean requiresApproval;
        
        public PermissionDefinition(String name, String description, 
                                   ResourceType resourceType, OperationType operationType,
                                   boolean requiresApproval) {
            this.name = name;
            this.description = description;
            this.resourceType = resourceType;
            this.operationType = operationType;
            this.requiresApproval = requiresApproval;
        }
        
        public String getName() {
            return name;
        }
        
        public String getDescription() {
            return description;
        }
        
        public ResourceType getResourceType() {
            return resourceType;
        }
        
        public OperationType getOperationType() {
            return operationType;
        }
        
        public boolean isRequiresApproval() {
            return requiresApproval;
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/RBACService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.engine.PHEngine;
import com.pharmacyhub.engine.PHMapper;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.AuditLog;
import com.pharmacyhub.security.domain.Feature;
import com.pharmacyhub.security.domain.Group;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.dto.GroupDTO;
import com.pharmacyhub.security.dto.PermissionDTO;
import com.pharmacyhub.security.dto.RoleDTO;
import com.pharmacyhub.security.exception.RBACException;
import com.pharmacyhub.security.infrastructure.AuditLogRepository;
import com.pharmacyhub.security.infrastructure.FeatureRepository;
import com.pharmacyhub.security.infrastructure.GroupRepository;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.Validate;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

@Service
@Transactional
@Slf4j
public class RBACService extends PHEngine
{
    private final UserRepository userRepository;
    private final RolesRepository rolesRepository;
    private final PermissionRepository permissionRepository;
    private final GroupRepository groupRepository;
    private final FeatureRepository featureRepository;
    private final AuditLogRepository auditLogRepository;
    private final PHMapper phMapper;
    private final AuditService auditService;
    private final RBACValidationService validationService;
    private final FeatureService featureService;

    public RBACService(
            UserRepository userRepository,
            RolesRepository rolesRepository,
            PermissionRepository permissionRepository,
            GroupRepository groupRepository,
            FeatureRepository featureRepository,
            AuditLogRepository auditLogRepository,
            PHMapper phMapper,
            AuditService auditService,
            RBACValidationService validationService,
            FeatureService featureService)
    {
        this.userRepository = userRepository;
        this.rolesRepository = rolesRepository;
        this.permissionRepository = permissionRepository;
        this.groupRepository = groupRepository;
        this.featureRepository = featureRepository;
        this.auditLogRepository = auditLogRepository;
        this.phMapper = phMapper;
        this.auditService = auditService;
        this.validationService = validationService;
        this.featureService = featureService;
    }

    @Cacheable(value = "userPermissions", key = "#userId")
    public Set<Permission> getUserEffectivePermissions(Long userId)
    {
        User user = userRepository.findById(userId)
                                  .orElseThrow(() -> RBACException.entityNotFound("User"));

        Set<Permission> effectivePermissions = new HashSet<>();

        // Add permissions from roles
        user.getRoles().forEach(role -> {
            effectivePermissions.addAll(role.getPermissions());
            addChildRolePermissions(role, effectivePermissions);
        });

        // Add permissions from groups
        user.getGroups().forEach(group -> {
            group.getRoles().forEach(role -> {
                effectivePermissions.addAll(role.getPermissions());
                addChildRolePermissions(role, effectivePermissions);
            });
        });

        // Handle permission overrides
        handlePermissionOverrides(user, effectivePermissions);
        
        log.debug("Computed {} effective permissions for user ID {}", effectivePermissions.size(), userId);
        return effectivePermissions;
    }

    private void addChildRolePermissions(Role role, Set<Permission> permissions)
    {
        Set<Role> childRoles = role.getChildRoles();
        if (childRoles != null) {
            childRoles.forEach(childRole -> {
                permissions.addAll(childRole.getPermissions());
                addChildRolePermissions(childRole, permissions);
            });
        }
    }
    
    /**
     * Get all roles assigned to a user, including roles from groups.
     */
    @Cacheable(value = "userRoles", key = "#userId")
    public Set<Role> getUserRoles(Long userId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> RBACException.entityNotFound("User"));

        Set<Role> allRoles = new HashSet<>(user.getRoles());
        
        // Add roles from groups
        user.getGroups().forEach(group -> 
            allRoles.addAll(group.getRoles())
        );
        
        return allRoles;
    }

    private void handlePermissionOverrides(User user, Set<Permission> permissions)
    {
        user.getPermissionOverrides().forEach(override -> {
            if (override.startsWith("-"))
            {
                // Remove permission
                permissions.removeIf(p -> p.getName().equals(override.substring(1)));
                log.debug("Removed permission {} due to override for user {}", override.substring(1), user.getId());
            }
            else
            {
                // Add permission
                permissionRepository.findByName(override)
                                    .ifPresent(permission -> {
                                        permissions.add(permission);
                                        log.debug("Added permission {} due to override for user {}", permission.getName(), user.getId());
                                    });
            }
        });
    }

    @PreAuthorize("hasPermission('ROLE', 'MANAGE')")
    @CacheEvict(value = {"roleHierarchy", "userPermissions", "userRoles"}, allEntries = true)
    public Role createRole(RoleDTO roleDTO)
    {
        validationService.validateRoleCreation(roleDTO);
        Role role = phMapper.getRole(roleDTO);
        role = rolesRepository.save(role);
        
        auditService.logSecurityEvent(
            "CREATE_ROLE",
            String.format("Created role '%s'", role.getName()),
            "SUCCESS"
        );
        
        return role;
    }
    
    /**
     * Update an existing role.
     */
    @PreAuthorize("hasPermission('ROLE', 'MANAGE')")
    @CacheEvict(value = {"roleHierarchy", "userPermissions", "userRoles"}, allEntries = true)
    public Role updateRole(Long roleId, RoleDTO roleDTO) {
        Role existingRole = rolesRepository.findById(roleId)
                .orElseThrow(() -> RBACException.entityNotFound("Role"));
        
        // Check if system role is being modified
        if (existingRole.isSystem() && !roleDTO.isSystem()) {
            throw RBACException.invalidOperation("Cannot change system role status");
        }
        
        // Update fields
        if (roleDTO.getDescription() != null) {
            existingRole.setDescription(roleDTO.getDescription());
        }
        
        if (roleDTO.getPrecedence() > 0) {
            existingRole.setPrecedence(roleDTO.getPrecedence());
        }
        
        // Update permissions
        if (roleDTO.getPermissionIds() != null) {
            Set<Permission> permissions = roleDTO.getPermissionIds().stream()
                    .map(id -> permissionRepository.findById(id)
                            .orElseThrow(() -> RBACException.entityNotFound("Permission")))
                    .collect(Collectors.toSet());
            existingRole.setPermissions(permissions);
        }
        
        Role updatedRole = rolesRepository.save(existingRole);
        
        auditService.logSecurityEvent(
            "UPDATE_ROLE",
            String.format("Updated role '%s'", updatedRole.getName()),
            "SUCCESS"
        );
        
        return updatedRole;
    }

    @PreAuthorize("hasPermission('PERMISSION', 'MANAGE')")
    @CacheEvict(value = {"userPermissions"}, allEntries = true)
    public PermissionDTO createPermission(PermissionDTO permissionDTO)
    {
        validationService.validatePermissionCreation(permissionDTO);
        
        Permission permission = phMapper.getPermission(permissionDTO);
        permission = permissionRepository.save(permission);
        
        auditService.logSecurityEvent(
            "CREATE_PERMISSION",
            String.format("Created permission '%s'", permission.getName()),
            "SUCCESS"
        );
        
        return phMapper.getPermissionDTO(permission);
    }

    @PreAuthorize("hasPermission('GROUP', 'MANAGE')")
    @CacheEvict(value = {"groupRoles", "userPermissions", "userRoles"}, allEntries = true)
    public Group createGroup(GroupDTO groupDTO)
    {
        validationService.validateGroupCreation(groupDTO);
        
        Group group = phMapper.getGroup(groupDTO);
        group = groupRepository.save(group);
        
        auditService.logSecurityEvent(
            "CREATE_GROUP",
            String.format("Created group '%s'", group.getName()),
            "SUCCESS"
        );
        
        return group;
    }

    @PreAuthorize("hasPermission('ROLE', 'ASSIGN')")
    @CacheEvict(value = {"userPermissions", "userRoles"}, key = "#userId")
    public void assignRoleToUser(Long userId, Long roleId)
    {
        User user = userRepository.findById(userId)
                                  .orElseThrow(() -> RBACException.entityNotFound("User"));
        Role role = rolesRepository.findById(roleId)
                                   .orElseThrow(() -> RBACException.entityNotFound("Role"));

        // Check if user already has the role
        if (user.getRoles().stream().anyMatch(r -> r.getId().equals(roleId))) {
            log.debug("User {} already has role {}", userId, roleId);
            return;
        }

        user.getRoles().add(role);
        userRepository.save(user);
        
        auditService.logSecurityEvent(
            "ASSIGN_ROLE",
            String.format("Assigned role '%s' to user '%s'", role.getName(), user.getUsername()),
            "SUCCESS"
        );
    }
    
    /**
     * Remove a role from a user.
     */
    @PreAuthorize("hasPermission('ROLE', 'ASSIGN')")
    @CacheEvict(value = {"userPermissions", "userRoles"}, key = "#userId")
    public void removeRoleFromUser(Long userId, Long roleId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> RBACException.entityNotFound("User"));
                
        Role role = rolesRepository.findById(roleId)
                .orElseThrow(() -> RBACException.entityNotFound("Role"));

        if (user.getRoles().removeIf(r -> r.getId().equals(roleId))) {
            userRepository.save(user);
            
            auditService.logSecurityEvent(
                "REMOVE_ROLE",
                String.format("Removed role '%s' from user '%s'", role.getName(), user.getUsername()),
                "SUCCESS"
            );
        }
    }

    @PreAuthorize("hasPermission('GROUP', 'ASSIGN')")
    @CacheEvict(value = {"userPermissions", "userRoles"}, key = "#userId")
    public void assignGroupToUser(Long userId, Long groupId)
    {
        User user = userRepository.findById(userId)
                                  .orElseThrow(() -> RBACException.entityNotFound("User"));
        Group group = groupRepository.findById(groupId)
                                     .orElseThrow(() -> RBACException.entityNotFound("Group"));

        // Check if user already has the group
        if (user.getGroups().stream().anyMatch(g -> g.getId().equals(groupId))) {
            log.debug("User {} already has group {}", userId, groupId);
            return;
        }

        user.getGroups().add(group);
        userRepository.save(user);
        
        auditService.logSecurityEvent(
            "ASSIGN_GROUP",
            String.format("Assigned group '%s' to user '%s'", group.getName(), user.getUsername()),
            "SUCCESS"
        );
    }
    
    /**
     * Remove a group from a user.
     */
    @PreAuthorize("hasPermission('GROUP', 'ASSIGN')")
    @CacheEvict(value = {"userPermissions", "userRoles"}, key = "#userId")
    public void removeGroupFromUser(Long userId, Long groupId) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> RBACException.entityNotFound("User"));
                
        Group group = groupRepository.findById(groupId)
                .orElseThrow(() -> RBACException.entityNotFound("Group"));

        if (user.getGroups().removeIf(g -> g.getId().equals(groupId))) {
            userRepository.save(user);
            
            auditService.logSecurityEvent(
                "REMOVE_GROUP",
                String.format("Removed group '%s' from user '%s'", group.getName(), user.getUsername()),
                "SUCCESS"
            );
        }
    }

    @PreAuthorize("hasPermission('PERMISSION', 'MANAGE')")
    @CacheEvict(value = {"userPermissions"}, key = "#userId")
    public void addPermissionOverride(Long userId, String permission, boolean grant)
    {
        User user = userRepository.findById(userId)
                                  .orElseThrow(() -> RBACException.entityNotFound("User"));

        String override = grant ? permission : "-" + permission;
        
        // Check if the override already exists
        if (user.getPermissionOverrides().contains(override)) {
            log.debug("Permission override {} already exists for user {}", override, userId);
            return;
        }
        
        user.getPermissionOverrides().add(override);
        userRepository.save(user);
        
        auditService.logSecurityEvent(
            "PERMISSION_OVERRIDE",
            String.format("Added permission override '%s' for user '%s'", override, user.getUsername()),
            "SUCCESS"
        );
    }
    
    /**
     * Remove a permission override from a user.
     */
    @PreAuthorize("hasPermission('PERMISSION', 'MANAGE')")
    @CacheEvict(value = {"userPermissions"}, key = "#userId")
    public void removePermissionOverride(Long userId, String override) {
        User user = userRepository.findById(userId)
                .orElseThrow(() -> RBACException.entityNotFound("User"));

        if (user.getPermissionOverrides().remove(override)) {
            userRepository.save(user);
            
            auditService.logSecurityEvent(
                "REMOVE_PERMISSION_OVERRIDE",
                String.format("Removed permission override '%s' for user '%s'", override, user.getUsername()),
                "SUCCESS"
            );
        }
    }

    /**
     * Check if a user has a specific permission.
     */
    @Cacheable(value = "userHasPermission", key = "#userId + '_' + #permissionName")
    public boolean userHasPermission(Long userId, String permissionName) {
        Set<Permission> permissions = getUserEffectivePermissions(userId);
        return permissions.stream()
                .anyMatch(p -> p.getName().equals(permissionName));
    }

    /**
     * Check if a user has a specific role.
     */
    @Cacheable(value = "userHasRole", key = "#userId + '_' + #roleName")
    public boolean userHasRole(Long userId, String roleName) {
        Set<Role> roles = getUserRoles(userId);
        return roles.stream()
                .anyMatch(r -> r.getName().equals(roleName));
    }

    /**
     * Get all permissions available in the system
     */
    @PreAuthorize("hasPermission('PERMISSION', 'MANAGE')")
    public List<Permission> getAllPermissions() {
        return permissionRepository.findAll();
    }

    /**
     * Get all users with a specific role.
     */
    @PreAuthorize("hasPermission('USER', 'READ')")
    public List<User> getUsersByRole(String roleName) {
        return userRepository.findByRolesName(roleName);
    }

    /**
     * Get all users in a specific group.
     */
    @PreAuthorize("hasPermission('GROUP', 'READ')")
    public List<User> getUsersByGroup(String groupName) {
        return userRepository.findByGroupsName(groupName);
    }

    /**
     * Validate user access to a specific resource
     */
    public boolean validateAccess(Long userId, String resourceType, String operation, Long resourceId) {
        Set<Permission> permissions = getUserEffectivePermissions(userId);
        
        // Check for exact permission match
        boolean hasPermission = permissions.stream()
                .anyMatch(p -> p.getResourceType().name().equals(resourceType) && 
                        p.getOperationType().name().equals(operation));
        
        if (hasPermission) {
            auditService.logSecurityEvent(
                "ACCESS_VALIDATION",
                String.format("User ID %d accessed %s:%s for resource ID %d", 
                    userId, resourceType, operation, resourceId),
                "GRANTED"
            );
            return true;
        } else {
            auditService.logSecurityEvent(
                "ACCESS_VALIDATION",
                String.format("User ID %d denied access to %s:%s for resource ID %d", 
                    userId, resourceType, operation, resourceId),
                "DENIED"
            );
            return false;
        }
    }
    
    /**
     * Check if a user has access to a specific feature
     * A user has access if they have at least one of the permissions required by the feature
     */
    @Cacheable(value = "featureAccess", key = "#userId + '_' + #featureCode")
    public boolean userHasFeatureAccess(Long userId, String featureCode) {
        Feature feature = featureRepository.findByCode(featureCode)
                .orElseThrow(() -> RBACException.entityNotFound("Feature with code " + featureCode));
                
        // If feature is not active, deny access
        if (!feature.isActive()) {
            return false;
        }
        
        // Get user's effective permissions
        Set<Permission> userPermissions = getUserEffectivePermissions(userId);
        
        // Check if user has any of the permissions required by the feature
        Set<Permission> featurePermissions = featureService.getAllFeaturePermissions(feature);
        
        // If feature has no permissions, allow access by default
        if (featurePermissions.isEmpty()) {
            return true;
        }
        
        // Check for any matching permission
        for (Permission userPermission : userPermissions) {
            for (Permission featurePermission : featurePermissions) {
                if (userPermission.getId().equals(featurePermission.getId())) {
                    return true;
                }
            }
        }
        
        return false;
    }
    
    /**
     * Check if a user has access to perform a specific operation on a feature
     * A user has access if they have at least one of the permissions required for the operation
     */
    @Cacheable(value = "featureOperationAccess", key = "#userId + '_' + #featureCode + '_' + #operation")
    public boolean userHasFeatureOperation(Long userId, String featureCode, String operation) {
        // First check general feature access
        if (!userHasFeatureAccess(userId, featureCode)) {
            return false;
        }
        
        Feature feature = featureRepository.findByCode(featureCode)
                .orElseThrow(() -> RBACException.entityNotFound("Feature with code " + featureCode));
                
        // If feature doesn't have the specified operation, deny access
        if (!feature.getOperations().contains(operation)) {
            return false;
        }
        
        // Get user's effective permissions
        Set<Permission> userPermissions = getUserEffectivePermissions(userId);
        
        // Check for operation-specific permissions (format: "FEATURE_CODE:OPERATION")
        String operationPermission = featureCode + ":" + operation;
        
        for (Permission permission : userPermissions) {
            if (permission.getName().equals(operationPermission)) {
                return true;
            }
        }
        
        // If no operation-specific permissions found, fall back to general feature permissions
        // This allows backward compatibility with existing features
        return true;
    }
    
    /**
     * Get all features a user has access to
     */
    @Cacheable(value = "userFeatures", key = "#userId")
    public Set<Feature> getUserAccessibleFeatures(Long userId) {
        List<Feature> allFeatures = featureRepository.findByActiveTrue();
        Set<Feature> accessibleFeatures = new HashSet<>();
        
        for (Feature feature : allFeatures) {
            if (userHasFeatureAccess(userId, feature.getCode())) {
                accessibleFeatures.add(feature);
            }
        }
        
        return accessibleFeatures;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/RBACValidationService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.security.domain.Group;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.ResourceType;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.dto.GroupDTO;
import com.pharmacyhub.security.dto.PermissionDTO;
import com.pharmacyhub.security.dto.RoleDTO;
import com.pharmacyhub.security.exception.RBACException;
import com.pharmacyhub.security.infrastructure.GroupRepository;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.Set;

/**
 * Service for validating RBAC operations
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class RBACValidationService {
    private final RolesRepository rolesRepository;
    private final PermissionRepository permissionRepository;
    private final GroupRepository groupRepository;

    /**
     * Validate role creation
     */
    public void validateRoleCreation(RoleDTO roleDTO) {
        // Check for missing name
        if (roleDTO.getName() == null) {
            throw RBACException.invalidData("Role name cannot be null");
        }
        
        try {
            // Convert string to RoleEnum
            RoleEnum roleEnum = validateRoleEnum(roleDTO.getName());
            
            // Check if role with same name already exists
            if (rolesRepository.findByName(roleEnum).isPresent()) {
                throw RBACException.alreadyExists("Role with name " + roleDTO.getName() + " already exists");
            }
        } catch (IllegalArgumentException e) {
            throw RBACException.invalidData("Invalid role name: " + roleDTO.getName());
        }
        
        // Validate permissions if specified
        if (roleDTO.getPermissionIds() != null && !roleDTO.getPermissionIds().isEmpty()) {
            for (Long permissionId : roleDTO.getPermissionIds()) {
                if (!permissionRepository.existsById(permissionId)) {
                    throw RBACException.invalidData("Permission with ID " + permissionId + " does not exist");
                }
            }
        }
    }
    
    /**
     * Validate permission creation
     */
    public void validatePermissionCreation(PermissionDTO permissionDTO) {
        // Check for missing name
        if (permissionDTO.getName() == null || permissionDTO.getName().isEmpty()) {
            throw RBACException.invalidData("Permission name cannot be null or empty");
        }
        
        // Check if permission with same name already exists
        if (permissionRepository.findByName(permissionDTO.getName()).isPresent()) {
            throw RBACException.alreadyExists("Permission with name " + permissionDTO.getName() + " already exists");
        }
        
        // Check if resource type is valid
        if (permissionDTO.getResourceType() == null) {
            log.warn("Resource type not specified for permission {}, defaulting to USER", permissionDTO.getName());
            permissionDTO.setResourceType(ResourceType.USER);
        }
        
        // Check if operation type is valid
        if (permissionDTO.getOperationType() == null) {
            throw RBACException.invalidData("Operation type cannot be null for permission " + permissionDTO.getName());
        }
    }
    
    /**
     * Validate group creation
     */
    public void validateGroupCreation(GroupDTO groupDTO) {
        // Check for missing name
        if (groupDTO.getName() == null || groupDTO.getName().isEmpty()) {
            throw RBACException.invalidData("Group name cannot be null or empty");
        }
        
        // Check if group with same name already exists
        if (groupRepository.findByName(groupDTO.getName()).isPresent()) {
            throw RBACException.alreadyExists("Group with name " + groupDTO.getName() + " already exists");
        }
        
        // Validate roles if specified
        if (groupDTO.getRoleIds() != null && !groupDTO.getRoleIds().isEmpty()) {
            for (Long roleId : groupDTO.getRoleIds()) {
                if (!rolesRepository.existsById(roleId)) {
                    throw RBACException.invalidData("Role with ID " + roleId + " does not exist");
                }
            }
        }
    }
    
    /**
     * Validate user role assignment
     */
    public void validateRoleAssignment(Long userId, Long roleId) {
        if (userId == null) {
            throw RBACException.invalidData("User ID cannot be null");
        }
        
        if (roleId == null) {
            throw RBACException.invalidData("Role ID cannot be null");
        }
        
        if (!rolesRepository.existsById(roleId)) {
            throw RBACException.invalidData("Role with ID " + roleId + " does not exist");
        }
    }
    
    /**
     * Validate user group assignment
     */
    public void validateGroupAssignment(Long userId, Long groupId) {
        if (userId == null) {
            throw RBACException.invalidData("User ID cannot be null");
        }
        
        if (groupId == null) {
            throw RBACException.invalidData("Group ID cannot be null");
        }
        
        if (!groupRepository.existsById(groupId)) {
            throw RBACException.invalidData("Group with ID " + groupId + " does not exist");
        }
    }
    
    /**
     * Validate permission override
     */
    public void validatePermissionOverride(Long userId, String permission, boolean grant) {
        if (userId == null) {
            throw RBACException.invalidData("User ID cannot be null");
        }
        
        if (permission == null || permission.isEmpty()) {
            throw RBACException.invalidData("Permission name cannot be null or empty");
        }
        
        // If granting, verify the permission exists
        if (grant && permissionRepository.findByName(permission).isEmpty()) {
            throw RBACException.invalidData("Permission with name " + permission + " does not exist");
        }
    }
    
    /**
     * Validate role hierarchy management
     */
    public void validateRoleHierarchy(Long parentRoleId, Long childRoleId) {
        if (parentRoleId == null || childRoleId == null) {
            throw RBACException.invalidData("Parent and child role IDs cannot be null");
        }
        
        if (parentRoleId.equals(childRoleId)) {
            throw RBACException.invalidData("A role cannot be its own child");
        }
        
        Role parentRole = rolesRepository.findById(parentRoleId)
            .orElseThrow(() -> RBACException.entityNotFound("Parent role"));
            
        Role childRole = rolesRepository.findById(childRoleId)
            .orElseThrow(() -> RBACException.entityNotFound("Child role"));
            
        // Ensure parent role has higher precedence than child role
        if (parentRole.getPrecedence() >= childRole.getPrecedence()) {
            throw RBACException.invalidData(
                "Parent role must have higher precedence (lower value) than child role. " +
                "Parent precedence: " + parentRole.getPrecedence() + 
                ", Child precedence: " + childRole.getPrecedence());
        }
        
        // Check for circular dependencies
        if (hasCircularDependency(childRole, parentRoleId)) {
            throw RBACException.invalidData("Adding this hierarchy would create a circular dependency");
        }
    }
    
    /**
     * Check if adding a parent role would create a circular dependency
     */
    private boolean hasCircularDependency(Role role, Long potentialParentId) {
        // Load the role with its child roles
        Role loadedRole = rolesRepository.findByIdWithChildRoles(role.getId());
        
        // Check if any of the child roles is the potential parent
        for (Role childRole : loadedRole.getChildRoles()) {
            if (childRole.getId().equals(potentialParentId)) {
                return true;
            }
            
            // Recursively check child roles
            if (hasCircularDependency(childRole, potentialParentId)) {
                return true;
            }
        }
        
        return false;
    }
    
    /**
     * Validate enum values from string
     */
    public RoleEnum validateRoleEnum(String roleName) {
        try {
            return RoleEnum.fromString(roleName);
        } catch (IllegalArgumentException e) {
            throw RBACException.invalidData("Invalid role name: " + roleName);
        }
    }
    
    /**
     * Validate resource type from string
     */
    public ResourceType validateResourceType(String resourceType) {
        try {
            return ResourceType.valueOf(resourceType);
        } catch (IllegalArgumentException e) {
            throw RBACException.invalidData("Invalid resource type: " + resourceType);
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/RoleHierarchyService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.exception.RBACException;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.*;

@Service
@RequiredArgsConstructor
public class RoleHierarchyService {
    private final RolesRepository rolesRepository;
    private final AuditService auditService;

    @Transactional
    @CacheEvict(value = {"roleHierarchy", "userPermissions"}, allEntries = true)
    public void addChildRole(Long parentRoleId, Long childRoleId) {
        Role parentRole = rolesRepository.findById(parentRoleId)
                                         .orElseThrow(() -> RBACException.entityNotFound("Parent role"));
        Role childRole = rolesRepository.findById(childRoleId)
                                        .orElseThrow(() -> RBACException.entityNotFound("Child role"));

        // Check for circular dependency
        if (isCircularDependency(childRole, parentRoleId, new HashSet<>())) {
            throw RBACException.invalidRoleHierarchy();
        }

        // Check precedence
        if (childRole.getPrecedence() <= parentRole.getPrecedence()) {
            throw RBACException.invalidOperation("Child role must have lower precedence than parent role");
        }

        parentRole.getChildRoles().add(childRole);
        rolesRepository.save(parentRole);

        auditService.logSecurityEvent(
            "ADD_CHILD_ROLE",
            String.format("Added role %s as child of %s", childRole.getName(), parentRole.getName()),
            "SUCCESS"
        );
    }

    @Transactional
    @CacheEvict(value = {"roleHierarchy", "userPermissions"}, allEntries = true)
    public void removeChildRole(Long parentRoleId, Long childRoleId) {
        Role parentRole = rolesRepository.findById(parentRoleId)
                                         .orElseThrow(() -> RBACException.entityNotFound("Parent role"));
        Role childRole = rolesRepository.findById(childRoleId)
                                        .orElseThrow(() -> RBACException.entityNotFound("Child role"));

        if (parentRole.getChildRoles().remove(childRole)) {
            rolesRepository.save(parentRole);
            
            auditService.logSecurityEvent(
                "REMOVE_CHILD_ROLE",
                String.format("Removed role %s as child of %s", childRole.getName(), parentRole.getName()),
                "SUCCESS"
            );
        }
    }

    @Transactional(readOnly = true)
    @Cacheable(value = "roleHierarchy", key = "#roleId")
    public Set<Role> getAllChildRoles(Long roleId) {
        Role role = rolesRepository.findById(roleId)
                                   .orElseThrow(() -> RBACException.entityNotFound("Role"));

        Set<Role> allChildRoles = new HashSet<>();
        collectChildRoles(role, allChildRoles);
        return allChildRoles;
    }

    @Transactional(readOnly = true)
    public List<Role> getRolesByPrecedence() {
        return rolesRepository.findAll(Sort.by(Sort.Direction.ASC, "precedence"));
    }

    private boolean isCircularDependency(Role role, Long targetParentId, Set<Long> visited) {
        if (role.getId().equals(targetParentId)) {
            return true;
        }

        if (!visited.add(role.getId())) {
            return false;
        }

        return role.getChildRoles().stream()
            .anyMatch(childRole -> isCircularDependency(childRole, targetParentId, new HashSet<>(visited)));
    }

    private void collectChildRoles(Role role, Set<Role> allChildRoles) {
        role.getChildRoles().forEach(childRole -> {
            allChildRoles.add(childRole);
            collectChildRoles(childRole, allChildRoles);
        });
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/service/UserRoleService.java">
package com.pharmacyhub.security.service;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import com.pharmacyhub.constants.RoleEnum;

import java.util.List;
import java.util.stream.Collectors;

@Service
@RequiredArgsConstructor
public class UserRoleService {
    private final RolesRepository rolesRepository;
    private final UserRepository userRepository;

    public List<Role> getSystemRoles() {
        return rolesRepository.findBySystemTrue();
    }

    public List<Role> getAssignableRoles(String roleName, Long userId) {
        // Convert the roleName string to RoleEnum
        RoleEnum roleEnum = RoleEnum.fromString(roleName);
        
        Role role = rolesRepository.findByName(roleEnum)
                .orElseThrow(() -> new IllegalArgumentException("Role not found: " + roleName));

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));

        List<Role> userRoles = user.getRoles().stream().toList();

        return rolesRepository.findByPrecedenceLessThanEqual(role.getPrecedence())
                .stream()
                .filter(r -> !userRoles.contains(r))
                .collect(Collectors.toList());
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/controller/UserManagementController.java">
package com.pharmacyhub.security.users.controller;

import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.users.dto.UserCreationRequest;
import com.pharmacyhub.security.users.service.UserTypeService;
import com.pharmacyhub.security.users.util.UserConverter;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * REST controller for managing different user types.
 */
@RestController
@RequestMapping("/api/users")
@RequiredArgsConstructor
@Slf4j
public class UserManagementController {
    
    private final UserTypeService userTypeService;
    
    /**
     * Get all super admin users.
     * 
     * @return List of super admin users
     */
    @GetMapping("/super-admins")
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<List<PHUserDTO>> getAllSuperAdmins() {
        List<User> superAdmins = userTypeService.getAllSuperAdmins();
        List<PHUserDTO> superAdminDTOs = mapUsersToDTOs(superAdmins);
        return ResponseEntity.ok(superAdminDTOs);
    }
    
    /**
     * Get all admin users.
     * 
     * @return List of admin users
     */
    @GetMapping("/admins")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public ResponseEntity<List<PHUserDTO>> getAllAdmins() {
        List<User> admins = userTypeService.getAllAdmins();
        List<PHUserDTO> adminDTOs = mapUsersToDTOs(admins);
        return ResponseEntity.ok(adminDTOs);
    }
    
    /**
     * Get all demo users.
     * 
     * @return List of demo users
     */
    @GetMapping("/demo-users")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public ResponseEntity<List<PHUserDTO>> getAllDemoUsers() {
        List<User> demoUsers = userTypeService.getAllDemoUsers();
        List<PHUserDTO> demoUserDTOs = mapUsersToDTOs(demoUsers);
        return ResponseEntity.ok(demoUserDTOs);
    }
    
    /**
     * Get users by type with pagination.
     * 
     * @param userType User type to filter by
     * @param pageable Pagination information
     * @return Page of users of the specified type
     */
    @GetMapping("/by-type/{userType}")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public ResponseEntity<Page<PHUserDTO>> getUsersByType(
            @PathVariable UserType userType,
            Pageable pageable) {
        Page<User> users = userTypeService.getUsersByType(userType, pageable);
        Page<PHUserDTO> userDTOs = users.map(this::mapUserToDTO);
        return ResponseEntity.ok(userDTOs);
    }
    
    /**
     * Create a new super admin user.
     * 
     * @param request User creation request
     * @return Created super admin user
     */
    @PostMapping("/super-admins")
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<PHUserDTO> createSuperAdmin(@Valid @RequestBody UserCreationRequest request) {
        User superAdmin = userTypeService.createSuperAdmin(
                request.getEmail(),
                request.getFirstName(),
                request.getLastName(),
                request.getPassword(),
                request.getContactNumber());
        return ResponseEntity.status(HttpStatus.CREATED).body(mapUserToDTO(superAdmin));
    }
    
    /**
     * Create a new admin user.
     * 
     * @param request User creation request
     * @return Created admin user
     */
    @PostMapping("/admins")
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    public ResponseEntity<PHUserDTO> createAdmin(@Valid @RequestBody UserCreationRequest request) {
        User admin = userTypeService.createAdmin(
                request.getEmail(),
                request.getFirstName(),
                request.getLastName(),
                request.getPassword(),
                request.getContactNumber());
        return ResponseEntity.status(HttpStatus.CREATED).body(mapUserToDTO(admin));
    }
    
    /**
     * Create a new demo user.
     * 
     * @param request User creation request
     * @return Created demo user
     */
    @PostMapping("/demo-users")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public ResponseEntity<PHUserDTO> createDemoUser(@Valid @RequestBody UserCreationRequest request) {
        User demoUser = userTypeService.createDemoUser(
                request.getEmail(),
                request.getFirstName(),
                request.getLastName(),
                request.getPassword(),
                request.getContactNumber());
        return ResponseEntity.status(HttpStatus.CREATED).body(mapUserToDTO(demoUser));
    }
    
    /**
     * Get permissions for a user.
     * 
     * @param userId User ID
     * @return Set of permissions for the user
     */
    @GetMapping("/{userId}/permissions")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN') or authentication.principal.id == #userId")
    public ResponseEntity<Set<String>> getUserPermissions(@PathVariable Long userId) {
        Set<Permission> permissions = userTypeService.getUserPermissions(userId);
        Set<String> permissionNames = permissions.stream()
                .map(Permission::getName)
                .collect(Collectors.toSet());
        return ResponseEntity.ok(permissionNames);
    }
    
    /**
     * Get roles for a user.
     * 
     * @param userId User ID
     * @return Set of roles for the user
     */
    @GetMapping("/{userId}/roles")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN') or authentication.principal.id == #userId")
    public ResponseEntity<Set<String>> getUserRoles(@PathVariable Long userId) {
        Set<Role> roles = userTypeService.getUserRoles(userId);
        Set<String> roleNames = roles.stream()
                .map(Role::getName)
                .collect(Collectors.toSet());
        return ResponseEntity.ok(roleNames);
    }
    
    /**
     * Check if a user is a super admin.
     * 
     * @param userId User ID
     * @return true if the user is a super admin, false otherwise
     */
    @GetMapping("/{userId}/is-super-admin")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public ResponseEntity<Boolean> isSuperAdmin(@PathVariable Long userId) {
        boolean isSuperAdmin = userTypeService.isSuperAdmin(userId);
        return ResponseEntity.ok(isSuperAdmin);
    }
    
    /**
     * Check if a user is an admin.
     * 
     * @param userId User ID
     * @return true if the user is an admin, false otherwise
     */
    @GetMapping("/{userId}/is-admin")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public ResponseEntity<Boolean> isAdmin(@PathVariable Long userId) {
        boolean isAdmin = userTypeService.isAdmin(userId);
        return ResponseEntity.ok(isAdmin);
    }
    
    /**
     * Check if a user is a demo user.
     * 
     * @param userId User ID
     * @return true if the user is a demo user, false otherwise
     */
    @GetMapping("/{userId}/is-demo-user")
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public ResponseEntity<Boolean> isDemoUser(@PathVariable Long userId) {
        boolean isDemoUser = userTypeService.isDemoUser(userId);
        return ResponseEntity.ok(isDemoUser);
    }
    
    /**
     * Map a list of users to DTOs.
     * 
     * @param users List of users
     * @return List of user DTOs
     */
    private List<PHUserDTO> mapUsersToDTOs(List<User> users) {
        return users.stream()
                .map(UserConverter::toDTO)
                .collect(Collectors.toList());
    }
    
    /**
     * Map a user to a DTO.
     * 
     * @param user User
     * @return User DTO
     */
    private PHUserDTO mapUserToDTO(User user) {
        return UserConverter.toDTO(user);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/dto/UserCreationRequest.java">
package com.pharmacyhub.security.users.dto;

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Pattern;
import jakarta.validation.constraints.Size;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO for user creation requests.
 */
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class UserCreationRequest {
    
    @NotBlank(message = "Email is required")
    @Email(message = "Email must be valid")
    private String email;
    
    @NotBlank(message = "First name is required")
    @Size(min = 2, max = 50, message = "First name must be between 2 and 50 characters")
    private String firstName;
    
    @NotBlank(message = "Last name is required")
    @Size(min = 2, max = 50, message = "Last name must be between 2 and 50 characters")
    private String lastName;
    
    @NotBlank(message = "Password is required")
    @Size(min = 8, message = "Password must be at least 8 characters long")
    @Pattern(
        regexp = "^(?=.*[0-9])(?=.*[a-z])(?=.*[A-Z])(?=.*[@#$%^&+=!]).*$",
        message = "Password must contain at least one digit, one lowercase letter, one uppercase letter, and one special character"
    )
    private String password;
    
    private String contactNumber;
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/factory/UserTypeFactory.java">
package com.pharmacyhub.security.users.factory;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Group;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.infrastructure.GroupRepository;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import com.pharmacyhub.security.service.RBACService;
import com.pharmacyhub.constants.RoleEnum;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.Optional;
import java.util.Set;
import lombok.extern.slf4j.Slf4j;

/**
 * Factory service for creating different types of users with appropriate
 * roles and permissions.
 */
@Service
@Slf4j
public class UserTypeFactory {
    private final UserRepository userRepository;
    private final GroupRepository groupRepository;
    private final RolesRepository rolesRepository;
    private final PasswordEncoder passwordEncoder;
    private final RBACService rbacService;

    @Autowired
    public UserTypeFactory(
            UserRepository userRepository,
            GroupRepository groupRepository,
            RolesRepository rolesRepository,
            PasswordEncoder passwordEncoder,
            RBACService rbacService) {
        this.userRepository = userRepository;
        this.groupRepository = groupRepository;
        this.rolesRepository = rolesRepository;
        this.passwordEncoder = passwordEncoder;
        this.rbacService = rbacService;
    }

    /**
     * Creates a Super Admin user with full system access.
     * 
     * @param email User's email address
     * @param firstName User's first name
     * @param lastName User's last name
     * @param password User's password
     * @param extraInfo Additional user information (optional)
     * @return The created Super Admin user
     */
    @Transactional
    public User createSuperAdmin(String email, String firstName, String lastName, String password, String... extraInfo) {
        log.info("Creating Super Admin user: {}", email);
        
        // Check if user already exists
        Optional<User> existingUser = userRepository.findByEmailAddress(email);
        if (existingUser.isPresent()) {
            log.warn("User with email {} already exists, returning existing user", email);
            return existingUser.get();
        }
        
        // Create base user with SUPER_ADMIN type
        User user = createBaseUser(email, firstName, lastName, password, UserType.SUPER_ADMIN);
        
        // Add SUPER_ADMIN role directly
        Optional<Role> superAdminRole = rolesRepository.findByName(RoleEnum.SUPER_ADMIN);
        if (superAdminRole.isPresent()) {
            user.setRole(superAdminRole.get());
        }
        
        // Save user to generate ID
        user = userRepository.save(user);
        
        // Assign to SuperAdmins group
        Group superAdminGroup = groupRepository.findByName("SuperAdmins")
                .orElseThrow(() -> new RuntimeException("SuperAdmins group not found"));
        user.getGroups().add(superAdminGroup);
        
        // Add contact number if provided
        if (extraInfo != null && extraInfo.length > 0 && extraInfo[0] != null) {
            user.setContactNumber(extraInfo[0]);
        }
        
        return userRepository.save(user);
    }

    /**
     * Creates a regular Admin user with administrative privileges.
     * 
     * @param email User's email address
     * @param firstName User's first name
     * @param lastName User's last name
     * @param password User's password
     * @param extraInfo Additional user information (optional)
     * @return The created Admin user
     */
    @Transactional
    public User createAdmin(String email, String firstName, String lastName, String password, String... extraInfo) {
        log.info("Creating Admin user: {}", email);
        
        // Check if user already exists
        Optional<User> existingUser = userRepository.findByEmailAddress(email);
        if (existingUser.isPresent()) {
            log.warn("User with email {} already exists, returning existing user", email);
            return existingUser.get();
        }
        
        // Create user with ADMIN type
        User user = createBaseUser(email, firstName, lastName, password, UserType.ADMIN);
        
        // Add ADMIN role directly
        Optional<Role> adminRole = rolesRepository.findByName(RoleEnum.ADMIN);
        if (adminRole.isPresent()) {
            user.setRole(adminRole.get());
        }
        
        // Save user to generate ID
        user = userRepository.save(user);
        
        // Assign to Administrators group
        Group adminGroup = groupRepository.findByName("Administrators")
                .orElseThrow(() -> new RuntimeException("Administrators group not found"));
        user.getGroups().add(adminGroup);
        
        // Add contact number if provided
        if (extraInfo != null && extraInfo.length > 0 && extraInfo[0] != null) {
            user.setContactNumber(extraInfo[0]);
        }
        
        return userRepository.save(user);
    }

    /**
     * Creates a Demo user with limited access for demonstration purposes.
     * 
     * @param email User's email address
     * @param firstName User's first name
     * @param lastName User's last name
     * @param password User's password
     * @param extraInfo Additional user information (optional)
     * @return The created Demo user
     */
    @Transactional
    public User createDemoUser(String email, String firstName, String lastName, String password, String... extraInfo) {
        log.info("Creating Demo user: {}", email);
        
        // Check if user already exists
        Optional<User> existingUser = userRepository.findByEmailAddress(email);
        if (existingUser.isPresent()) {
            log.warn("User with email {} already exists, returning existing user", email);
            return existingUser.get();
        }
        
        // Create user with USER type for demo
        User user = createBaseUser(email, firstName, lastName, password, UserType.USER);
        
        // Add USER role directly
        Optional<Role> userRole = rolesRepository.findByName(RoleEnum.USER);
        if (userRole.isPresent()) {
            user.setRole(userRole.get());
        }
        
        // Save user to generate ID
        user = userRepository.save(user);
        
        // Assign to DemoUsers group
        Group demoGroup = groupRepository.findByName("DemoUsers")
                .orElseThrow(() -> new RuntimeException("DemoUsers group not found"));
        user.getGroups().add(demoGroup);
        
        // Add contact number if provided
        if (extraInfo != null && extraInfo.length > 0 && extraInfo[0] != null) {
            user.setContactNumber(extraInfo[0]);
        }
        
        return userRepository.save(user);
    }

    /**
     * Creates a base user with common properties.
     * 
     * @param email User's email address
     * @param firstName User's first name
     * @param lastName User's last name
     * @param password User's password
     * @param userType User's type
     * @return The created base user
     */
    private User createBaseUser(
            String email, 
            String firstName, 
            String lastName, 
            String password,
            UserType userType) {
        User user = new User();
        user.setEmailAddress(email);
        user.setFirstName(firstName);
        user.setLastName(lastName);
        user.setPassword(passwordEncoder.encode(password));
        user.setUserType(userType);
        user.setActive(true);
        user.setVerified(true);
        user.setRegistered(true);
        user.setAccountNonLocked(true);
        user.setOpenToConnect(true);
        user.setRoles(new HashSet<>());
        user.setGroups(new HashSet<>());
        return user;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/groups/GroupSeeder.java">
package com.pharmacyhub.security.users.groups;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.security.domain.Group;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.infrastructure.GroupRepository;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import com.pharmacyhub.security.infrastructure.PermissionRepository;
import jakarta.annotation.PostConstruct;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.transaction.annotation.Transactional;

import java.util.HashSet;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.stream.Collectors;
import lombok.extern.slf4j.Slf4j;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;

/**
 * Seeds predefined groups for different user types.
 * Creates three main groups:
 * - SuperAdmins: Full system access
 * - Administrators: Administrative access but not system settings
 * - DemoUsers: Limited read-only access for demonstration
 */
@Component
@Order(Ordered.LOWEST_PRECEDENCE - 100)
@Slf4j
public class GroupSeeder implements ApplicationListener<ContextRefreshedEvent> {
    @Autowired
    private GroupRepository groupRepository;
    
    @Autowired
    private RolesRepository rolesRepository;
    
    @Autowired
    private PermissionRepository permissionRepository;

    /**
     * Initialize the predefined groups.
     */
    @Override
    @Transactional
    public void onApplicationEvent(ContextRefreshedEvent event) {
        log.info("Checking for groups in onApplicationEvent...");
        
        // We don't need to create the groups anymore since RoleInitializer handles that,
        // but we'll verify they exist for DefaultUsersInitializer
        boolean adminGroupExists = groupRepository.findByName("Administrators").isPresent();
        boolean superAdminGroupExists = groupRepository.findByName("SuperAdmins").isPresent();
        boolean demoGroupExists = groupRepository.findByName("DemoUsers").isPresent();
        
        if (adminGroupExists && superAdminGroupExists && demoGroupExists) {
            log.info("All required groups exist. Ready for DefaultUsersInitializer.");
        } else {
            log.warn("Some required groups are missing. RoleInitializer may not have run correctly.");
            if (!adminGroupExists) log.warn("Missing: Administrators group");
            if (!superAdminGroupExists) log.warn("Missing: SuperAdmins group");
            if (!demoGroupExists) log.warn("Missing: DemoUsers group");
        }
    }
    
    /**
     * This method is kept for reference but not used directly anymore.
     * The initialization has been moved to onApplicationEvent.
     */
    @PostConstruct
    public void init() {
        log.info("PostConstruct method in GroupSeeder - not doing initialization here.");
    }

    /**
     * Creates the SuperAdmins group with full system access.
     * NOT directly called via PostConstruct - handled by RoleInitializer.
     */
    private void createSuperAdminGroup() {
        if (groupRepository.findByName("SuperAdmins").isEmpty()) {
            log.info("Creating SuperAdmins group...");
            
            // Find the SUPER_ADMIN role
            Optional<Role> superAdminRole = rolesRepository.findByName(RoleEnum.SUPER_ADMIN);
            
            if (superAdminRole.isPresent()) {
                Set<Role> roles = new HashSet<>();
                roles.add(superAdminRole.get());
                
                // Also add the ADMIN role
                Optional<Role> adminRole = rolesRepository.findByName(RoleEnum.ADMIN);
                adminRole.ifPresent(roles::add);
                
                Group group = Group.builder()
                    .name("SuperAdmins")
                    .description("Super administrators with full system access")
                    .roles(roles)
                    .build();
                    
                groupRepository.save(group);
                log.info("SuperAdmins group created successfully");
            } else {
                log.error("Could not create SuperAdmins group - SUPER_ADMIN role not found");
            }
        }
    }

    /**
     * Creates the Administrators group with administrative privileges.
     * NOT directly called via PostConstruct - handled by RoleInitializer.
     */
    private void createAdminGroup() {
        if (groupRepository.findByName("Administrators").isEmpty()) {
            log.info("Creating Administrators group...");
            
            // Find the ADMIN role
            Optional<Role> adminRole = rolesRepository.findByName(RoleEnum.ADMIN);
            
            if (adminRole.isPresent()) {
                Set<Role> roles = new HashSet<>();
                roles.add(adminRole.get());
                
                Group group = Group.builder()
                    .name("Administrators")
                    .description("Regular administrators with management privileges")
                    .roles(roles)
                    .build();
                    
                groupRepository.save(group);
                log.info("Administrators group created successfully");
            } else {
                log.error("Could not create Administrators group - ADMIN role not found");
            }
        }
    }

    /**
     * Creates the DemoUsers group with limited access for demonstration.
     * NOT directly called via PostConstruct - handled by RoleInitializer.
     */
    private void createDemoUserGroup() {
        if (groupRepository.findByName("DemoUsers").isEmpty()) {
            log.info("Creating DemoUsers group...");
            
            // Find the USER role
            Optional<Role> userRole = rolesRepository.findByName(RoleEnum.USER);
            
            if (userRole.isPresent()) {
                Set<Role> roles = new HashSet<>();
                roles.add(userRole.get());
                
                Group group = Group.builder()
                    .name("DemoUsers")
                    .description("Demo users with limited read-only access")
                    .roles(roles)
                    .build();
                    
                groupRepository.save(group);
                log.info("DemoUsers group created successfully");
            } else {
                log.error("Could not create DemoUsers group - USER role not found");
            }
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/initializer/DefaultUsersInitializer.java">
package com.pharmacyhub.security.users.initializer;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.users.factory.UserTypeFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.core.Ordered;
import org.springframework.core.annotation.Order;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import jakarta.annotation.PostConstruct;
import lombok.extern.slf4j.Slf4j;

/**
 * Initializes default users for the system.
 * Creates a super admin, regular admin, and demo user if they don't already exist.
 * Depends on GroupSeeder to ensure groups are created first.
 */
@Component
@Order(Ordered.LOWEST_PRECEDENCE - 50)
@Slf4j
public class DefaultUsersInitializer implements ApplicationListener<ContextRefreshedEvent> {
    private final UserTypeFactory userTypeFactory;
    private final UserRepository userRepository;
    
    @Value("${pharmacyhub.superadmin.email:superadmin@pharmacyhub.com}")
    private String superAdminEmail;
    
    @Value("${pharmacyhub.superadmin.password:superadmin123}")
    private String superAdminPassword;
    
    @Value("${pharmacyhub.admin.email:admin@pharmacyhub.com}")
    private String adminEmail;
    
    @Value("${pharmacyhub.admin.password:admin123}")
    private String adminPassword;
    
    @Value("${pharmacyhub.demo.email:demo@pharmacyhub.com}")
    private String demoEmail;
    
    @Value("${pharmacyhub.demo.password:demo123}")
    private String demoPassword;
    
    @Autowired
    public DefaultUsersInitializer(
            UserTypeFactory userTypeFactory,
            UserRepository userRepository) {
        this.userTypeFactory = userTypeFactory;
        this.userRepository = userRepository;
    }
    
    /**
     * When the application is fully initialized,
     * this method will run to create default users.
     */
    @Override
    @Transactional
    public void onApplicationEvent(ContextRefreshedEvent event) {
        try {
            log.info("Initializing default users on ContextRefreshedEvent...");
            createDefaultSuperAdmin();
            createDefaultAdmin();
            createDefaultDemoUser();
            log.info("Default users initialization completed.");
        } catch (Exception e) {
            log.error("Error initializing default users", e);
        }
    }
    
    /**
     * Legacy initialization method - keeping for reference, but functionality
     * has been moved to onApplicationEvent method.
     */
    @PostConstruct
    public void initialize() {
        log.info("PostConstruct method in DefaultUsersInitializer - not doing initialization here.");
    }
    
    /**
     * Creates the default super admin user if it doesn't exist.
     */
    private void createDefaultSuperAdmin() {
        if (userRepository.findByEmailAddress(superAdminEmail).isEmpty()) {
            log.info("Creating default Super Admin user...");
            User superAdmin = userTypeFactory.createSuperAdmin(
                    superAdminEmail,
                    "Super",
                    "Admin",
                    superAdminPassword);
            log.info("Default Super Admin created: {}", superAdmin.getEmailAddress());
        } else {
            log.info("Default Super Admin already exists.");
        }
    }
    
    /**
     * Creates the default admin user if it doesn't exist.
     */
    private void createDefaultAdmin() {
        if (userRepository.findByEmailAddress(adminEmail).isEmpty()) {
            log.info("Creating default Admin user...");
            User admin = userTypeFactory.createAdmin(
                    adminEmail,
                    "Regular",
                    "Admin",
                    adminPassword);
            log.info("Default Admin created: {}", admin.getEmailAddress());
        } else {
            log.info("Default Admin already exists.");
        }
    }
    
    /**
     * Creates the default demo user if it doesn't exist.
     */
    private void createDefaultDemoUser() {
        if (userRepository.findByEmailAddress(demoEmail).isEmpty()) {
            log.info("Creating default Demo user...");
            User demoUser = userTypeFactory.createDemoUser(
                    demoEmail,
                    "Demo",
                    "User",
                    demoPassword);
            log.info("Default Demo User created: {}", demoUser.getEmailAddress());
        } else {
            log.info("Default Demo User already exists.");
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/README.md">
# Directory-Based User Types Implementation

This document outlines the directory-based approach for implementing different user types in the PharmacyHub application.

## Overview

The implementation uses a structured directory approach to organize code related to user types:

```
com.pharmacyhub.security.users/
  ├── factory/
  │   └── UserTypeFactory.java       # Factory for creating different user types
  ├── initializer/
  │   └── DefaultUsersInitializer.java  # Initialize default users of all types
  ├── groups/
  │   └── GroupSeeder.java           # Configure and seed user groups
  ├── service/
  │   └── UserTypeService.java       # Service for user type-specific operations
  ├── controller/
  │   └── UserManagementController.java # REST endpoints for user management
  ├── dto/
  │   └── UserCreationRequest.java   # DTO for user creation requests
  ├── util/
  │   ├── UserConverter.java         # Utility for user-related conversions
  │   └── UserCreator.java           # Fluent interface for creating users
  └── README.md                      # Documentation
```

## User Types and Roles Hierarchy

The system implements a clear hierarchical structure:

1. **Groups**: Collections of roles
   - SuperAdmins group
   - Administrators group
   - DemoUsers group

2. **Roles**: Collections of permissions
   - SUPER_ADMIN role (highest precedence)
   - ADMIN role
   - USER role (for demo users)

3. **Permissions**: Fine-grained access controls
   - Various permissions for different resources and operations

## User Types

### 1. Super Admin
- Full system access
- Belongs to SuperAdmins group
- Has SUPER_ADMIN role
- Can manage all users, roles, and system settings
- Default credentials: superadmin@pharmacyhub.com / superadmin123

### 2. Admin
- Administrative access (but not system settings)
- Belongs to Administrators group
- Has ADMIN role
- Can manage regular operations but not system settings
- Default credentials: admin@pharmacyhub.com / admin123

### 3. Demo User
- Limited read-only access
- Belongs to DemoUsers group
- Has USER role
- For demonstration and testing purposes
- Default credentials: demo@pharmacyhub.com / demo123

## How to Use

### Creating Users Programmatically

```java
// Method 1: Using UserTypeService
@Autowired
private UserTypeService userTypeService;

// Create a super admin
User superAdmin = userTypeService.createSuperAdmin(
    "super.admin@example.com", 
    "Super", 
    "Admin", 
    "password123", 
    "1234567890"
);

// Create a regular admin
User admin = userTypeService.createAdmin(
    "admin@example.com", 
    "Regular", 
    "Admin", 
    "password123", 
    null
);

// Create a demo user
User demoUser = userTypeService.createDemoUser(
    "demo@example.com", 
    "Demo", 
    "User", 
    "password123", 
    null
);

// Method 2: Using fluent UserCreator (recommended)
@Autowired
private UserCreator userCreator;

// Create a super admin with fluent interface
User superAdmin = userCreator.superAdmin()
    .withEmail("super.admin@example.com")
    .withFirstName("Super")
    .withLastName("Admin")
    .withPassword("password123")
    .withContactNumber("1234567890")
    .build();

// Create a regular admin with fluent interface
User admin = userCreator.admin()
    .withEmail("admin@example.com")
    .withFirstName("Regular")
    .withLastName("Admin")
    .withPassword("password123")
    .build();

// Create a demo user with fluent interface
User demoUser = userCreator.demoUser()
    .withEmail("demo@example.com")
    .withFirstName("Demo")
    .withLastName("User")
    .withPassword("password123")
    .build();
```

### REST API Endpoints

The system provides REST endpoints for managing user types:

1. **Get Users**
   - GET `/api/users/super-admins` - Get all super admins
   - GET `/api/users/admins` - Get all admins
   - GET `/api/users/demo-users` - Get all demo users
   - GET `/api/users/by-type/{userType}` - Get users by type with pagination

2. **Create Users**
   - POST `/api/users/super-admins` - Create a super admin
   - POST `/api/users/admins` - Create an admin
   - POST `/api/users/demo-users` - Create a demo user

3. **User Information**
   - GET `/api/users/{userId}/permissions` - Get user permissions
   - GET `/api/users/{userId}/roles` - Get user roles
   - GET `/api/users/{userId}/is-super-admin` - Check if user is a super admin
   - GET `/api/users/{userId}/is-admin` - Check if user is an admin
   - GET `/api/users/{userId}/is-demo-user` - Check if user is a demo user

## Configuration

Default user credentials can be configured in `application.properties` or `application.yml`:

```properties
# Super Admin credentials
pharmacyhub.superadmin.email=superadmin@pharmacyhub.com
pharmacyhub.superadmin.password=superadmin123

# Admin credentials
pharmacyhub.admin.email=admin@pharmacyhub.com
pharmacyhub.admin.password=admin123

# Demo user credentials
pharmacyhub.demo.email=demo@pharmacyhub.com
pharmacyhub.demo.password=demo123
```

## Security and Authorization

The implementation includes proper security checks:

- Role-based access control using Spring Security
- Method-level security using `@PreAuthorize`
- Proper validation for user inputs
- Secure password storage using encryption
</file>

<file path="src/main/java/com/pharmacyhub/security/users/service/UserTypeService.java">
package com.pharmacyhub.security.users.service;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Group;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.infrastructure.GroupRepository;
import com.pharmacyhub.security.service.RBACService;
import com.pharmacyhub.security.users.factory.UserTypeFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.Optional;
import lombok.extern.slf4j.Slf4j;

/**
 * Service for managing users of different types (SuperAdmin, Admin, DemoUser).
 * Provides user type-specific operations and queries.
 */
@Service
@Slf4j
public class UserTypeService {
    private final UserRepository userRepository;
    private final GroupRepository groupRepository;
    private final RBACService rbacService;
    private final UserTypeFactory userTypeFactory;
    
    @Autowired
    public UserTypeService(
            UserRepository userRepository,
            GroupRepository groupRepository,
            RBACService rbacService,
            UserTypeFactory userTypeFactory) {
        this.userRepository = userRepository;
        this.groupRepository = groupRepository;
        this.rbacService = rbacService;
        this.userTypeFactory = userTypeFactory;
    }
    
    /**
     * Gets all super admin users.
     * Requires SUPER_ADMIN or ADMIN role.
     * 
     * @return List of super admin users
     */
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public List<User> getAllSuperAdmins() {
        Group superAdminGroup = groupRepository.findByName("SuperAdmins")
                .orElseThrow(() -> new RuntimeException("SuperAdmins group not found"));
        return userRepository.findByGroupsContaining(superAdminGroup);
    }
    
    /**
     * Gets all admin users.
     * Requires SUPER_ADMIN or ADMIN role.
     * 
     * @return List of admin users
     */
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public List<User> getAllAdmins() {
        Group adminGroup = groupRepository.findByName("Administrators")
                .orElseThrow(() -> new RuntimeException("Administrators group not found"));
        return userRepository.findByGroupsContaining(adminGroup);
    }
    
    /**
     * Gets all demo users.
     * Requires SUPER_ADMIN or ADMIN role.
     * 
     * @return List of demo users
     */
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public List<User> getAllDemoUsers() {
        Group demoGroup = groupRepository.findByName("DemoUsers")
                .orElseThrow(() -> new RuntimeException("DemoUsers group not found"));
        return userRepository.findByGroupsContaining(demoGroup);
    }
    
    /**
     * Gets all users of a specific type.
     * Requires SUPER_ADMIN or ADMIN role.
     * 
     * @param userType The user type to filter by
     * @param pageable Pagination information
     * @return Page of users of the specified type
     */
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    public Page<User> getUsersByType(UserType userType, Pageable pageable) {
        return userRepository.findByUserType(userType, pageable);
    }
    
    /**
     * Creates a new super admin user.
     * Requires SUPER_ADMIN role.
     * 
     * @param email User's email address
     * @param firstName User's first name
     * @param lastName User's last name
     * @param password User's password
     * @param contactNumber User's contact number (optional)
     * @return The created super admin user
     */
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    @Transactional
    public User createSuperAdmin(String email, String firstName, String lastName, String password, String contactNumber) {
        return userTypeFactory.createSuperAdmin(email, firstName, lastName, password, contactNumber);
    }
    
    /**
     * Creates a new admin user.
     * Requires SUPER_ADMIN role.
     * 
     * @param email User's email address
     * @param firstName User's first name
     * @param lastName User's last name
     * @param password User's password
     * @param contactNumber User's contact number (optional)
     * @return The created admin user
     */
    @PreAuthorize("hasRole('SUPER_ADMIN')")
    @Transactional
    public User createAdmin(String email, String firstName, String lastName, String password, String contactNumber) {
        return userTypeFactory.createAdmin(email, firstName, lastName, password, contactNumber);
    }
    
    /**
     * Creates a new demo user.
     * Requires SUPER_ADMIN or ADMIN role.
     * 
     * @param email User's email address
     * @param firstName User's first name
     * @param lastName User's last name
     * @param password User's password
     * @param contactNumber User's contact number (optional)
     * @return The created demo user
     */
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN')")
    @Transactional
    public User createDemoUser(String email, String firstName, String lastName, String password, String contactNumber) {
        return userTypeFactory.createDemoUser(email, firstName, lastName, password, contactNumber);
    }
    
    /**
     * Gets the permissions for a specific user.
     * Requires SUPER_ADMIN or ADMIN role, or the user to be accessing their own permissions.
     * 
     * @param userId The user ID
     * @return Set of permissions for the user
     */
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN') or authentication.principal.id == #userId")
    public Set<Permission> getUserPermissions(Long userId) {
        return rbacService.getUserEffectivePermissions(userId);
    }
    
    /**
     * Gets the roles for a specific user.
     * Requires SUPER_ADMIN or ADMIN role, or the user to be accessing their own roles.
     * 
     * @param userId The user ID
     * @return Set of roles for the user
     */
    @PreAuthorize("hasAnyRole('SUPER_ADMIN', 'ADMIN') or authentication.principal.id == #userId")
    public Set<Role> getUserRoles(Long userId) {
        return rbacService.getUserRoles(userId);
    }
    
    /**
     * Checks if a user is a super admin.
     * 
     * @param userId The user ID
     * @return true if the user is a super admin, false otherwise
     */
    public boolean isSuperAdmin(Long userId) {
        Optional<User> userOpt = userRepository.findById(userId);
        if (userOpt.isEmpty()) {
            return false;
        }
        
        User user = userOpt.get();
        // Check if user has SUPER_ADMIN role or is in SuperAdmins group
        return user.getUserType() == UserType.SUPER_ADMIN || 
               user.getGroups().stream().anyMatch(group -> "SuperAdmins".equals(group.getName()));
    }
    
    /**
     * Checks if a user is an admin.
     * 
     * @param userId The user ID
     * @return true if the user is an admin, false otherwise
     */
    public boolean isAdmin(Long userId) {
        Optional<User> userOpt = userRepository.findById(userId);
        if (userOpt.isEmpty()) {
            return false;
        }
        
        User user = userOpt.get();
        // Check if user has ADMIN role or is in Administrators group
        return user.getUserType() == UserType.ADMIN || 
               user.getGroups().stream().anyMatch(group -> "Administrators".equals(group.getName()));
    }
    
    /**
     * Checks if a user is a demo user.
     * 
     * @param userId The user ID
     * @return true if the user is a demo user, false otherwise
     */
    public boolean isDemoUser(Long userId) {
        Optional<User> userOpt = userRepository.findById(userId);
        if (userOpt.isEmpty()) {
            return false;
        }
        
        User user = userOpt.get();
        // Check if user is in DemoUsers group
        return user.getGroups().stream().anyMatch(group -> "DemoUsers".equals(group.getName()));
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/util/UserConverter.java">
package com.pharmacyhub.security.users.util;

import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.entity.User;
import lombok.experimental.UtilityClass;

/**
 * Utility class for converting between User entities and DTOs.
 */
@UtilityClass
public class UserConverter {
    
    /**
     * Convert a User entity to a PHUserDTO.
     * 
     * @param user User entity
     * @return PHUserDTO
     */
    public static PHUserDTO toDTO(User user) {
        if (user == null) {
            return null;
        }
        
        return PHUserDTO.builder()
                .id(user.getId())
                .emailAddress(user.getEmailAddress())
                .firstName(user.getFirstName())
                .lastName(user.getLastName())
                .contactNumber(user.getContactNumber())
                .userType(user.getUserType())
                .openToConnect(user.isOpenToConnect())
                .registered(user.isRegistered())
                .build();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/security/users/util/UserCreator.java">
package com.pharmacyhub.security.users.util;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.users.factory.UserTypeFactory;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

/**
 * A utility class for easily creating users of different types.
 * Provides a fluent interface for user creation.
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class UserCreator {
    private final UserTypeFactory userTypeFactory;
    
    /**
     * Create a super admin user.
     */
    public SuperAdminBuilder superAdmin() {
        return new SuperAdminBuilder(userTypeFactory);
    }
    
    /**
     * Create an admin user.
     */
    public AdminBuilder admin() {
        return new AdminBuilder(userTypeFactory);
    }
    
    /**
     * Create a demo user.
     */
    public DemoUserBuilder demoUser() {
        return new DemoUserBuilder(userTypeFactory);
    }
    
    /**
     * Base builder class for all user types.
     */
    public abstract static class UserBuilder<T extends UserBuilder<T>> {
        protected final UserTypeFactory userTypeFactory;
        protected String email;
        protected String firstName;
        protected String lastName;
        protected String password;
        protected String contactNumber;
        
        protected UserBuilder(UserTypeFactory userTypeFactory) {
            this.userTypeFactory = userTypeFactory;
        }
        
        /**
         * Set the email address.
         */
        @SuppressWarnings("unchecked")
        public T withEmail(String email) {
            this.email = email;
            return (T) this;
        }
        
        /**
         * Set the first name.
         */
        @SuppressWarnings("unchecked")
        public T withFirstName(String firstName) {
            this.firstName = firstName;
            return (T) this;
        }
        
        /**
         * Set the last name.
         */
        @SuppressWarnings("unchecked")
        public T withLastName(String lastName) {
            this.lastName = lastName;
            return (T) this;
        }
        
        /**
         * Set the password.
         */
        @SuppressWarnings("unchecked")
        public T withPassword(String password) {
            this.password = password;
            return (T) this;
        }
        
        /**
         * Set the contact number.
         */
        @SuppressWarnings("unchecked")
        public T withContactNumber(String contactNumber) {
            this.contactNumber = contactNumber;
            return (T) this;
        }
        
        /**
         * Build the user.
         */
        public abstract User build();
    }
    
    /**
     * Builder for super admin users.
     */
    public static class SuperAdminBuilder extends UserBuilder<SuperAdminBuilder> {
        public SuperAdminBuilder(UserTypeFactory userTypeFactory) {
            super(userTypeFactory);
        }
        
        @Override
        public User build() {
            return userTypeFactory.createSuperAdmin(email, firstName, lastName, password, contactNumber);
        }
    }
    
    /**
     * Builder for admin users.
     */
    public static class AdminBuilder extends UserBuilder<AdminBuilder> {
        public AdminBuilder(UserTypeFactory userTypeFactory) {
            super(userTypeFactory);
        }
        
        @Override
        public User build() {
            return userTypeFactory.createAdmin(email, firstName, lastName, password, contactNumber);
        }
    }
    
    /**
     * Builder for demo users.
     */
    public static class DemoUserBuilder extends UserBuilder<DemoUserBuilder> {
        public DemoUserBuilder(UserTypeFactory userTypeFactory) {
            super(userTypeFactory);
        }
        
        @Override
        public User build() {
            return userTypeFactory.createDemoUser(email, firstName, lastName, password, contactNumber);
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/seeder/AdminUserSeeder.java">
package com.pharmacyhub.seeder;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.Optional;

@Component
public class AdminUserSeeder {
    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;

    public void loadUsers() {
        loadAdmin();
        loadSuperAdmin();
    }

    private void loadAdmin() {
        try {
            String email = "admin@pharmacyhub.pk";
            Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.ADMIN);

            if (userRepository.findByEmailAddress(email).isEmpty()) {
                User user = new User();
                user.setFirstName("Admin");
                user.setLastName("User");
                user.setEmailAddress(email);
                user.setPassword(passwordEncoder.encode("admin"));
                user.setRole(optionalRole.get());
                user.setRegistered(true);
                user.setUserType(UserType.ADMIN);
                userRepository.save(user);
            }
        } catch (Exception e) {
            // Handle the exception appropriately (e.g., log it)
            e.printStackTrace();
        }
    }

    public void loadSuperAdmin() {
        try {
            String email = "superadmin@pharmacyhub.pk";
            Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.SUPER_ADMIN);

            if (userRepository.findByEmailAddress(email).isEmpty()) {
                User user = new User();
                user.setFirstName("Super");
                user.setLastName("Admin");
                user.setEmailAddress(email);
                user.setPassword(passwordEncoder.encode("superadmin"));
                user.setRole(optionalRole.get());
                user.setRegistered(true);
                user.setUserType(UserType.SUPER_ADMIN);
                userRepository.save(user);
            }
        } catch (Exception e) {
            // Handle the exception appropriately (e.g., log it)
            e.printStackTrace();
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/seeder/PharmacistSeeder.java">
package com.pharmacyhub.seeder;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.entity.Pharmacist;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.repository.PharmacistRepository;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.stream.IntStream;

@Component
public class PharmacistSeeder {
    @Value("#{'${pharmacyhub.test.data.pharmacist}'.split('-')}")
    private List<Integer> range;

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private PharmacistRepository pharmacistRepository;

    public void loadUsers() {
        Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.USER);

        IntStream.rangeClosed(range.get(0), range.get(1))
                .forEach(i -> {
                    try {
                        String email = "user" + i + "@pharmacyhub.pk";

                        if (userRepository.findByEmailAddress(email).isEmpty()) {
                            User user = new User();
                            user.setFirstName("User " + i);
                            user.setLastName("Pharmacist");
                            user.setEmailAddress(email);
                            user.setPassword(passwordEncoder.encode("user" + i));
                            user.setRole(optionalRole.get());
                            user.setRegistered(true);
                            user.setUserType(UserType.PHARMACIST);
                            userRepository.save(user);

                            Pharmacist pharmacist = Pharmacist.builder()
                                    .categoryAvailable("Yes")
                                    .licenseDuration("1 year")
                                    .experience("Yes")
                                    .city("Lahore")
                                    .location("NFC")
                                    .universityName("UCP")
                                    .batch("F16")
                                    .contactNumber("03456142607")
                                    .categoryProvince("")
                                    .user(user)
                                    .build();

                            pharmacistRepository.save(pharmacist);
                        }
                    } catch (Exception e) {
                        // Handle the exception appropriately (e.g., log it)
                        e.printStackTrace();
                    }
                });
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/seeder/PharmacyManagerSeeder.java">
package com.pharmacyhub.seeder;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.entity.PharmacyManager;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.repository.PharmacyManagerRepository;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.stream.IntStream;

@Component
public class PharmacyManagerSeeder {
    @Value("#{'${pharmacyhub.test.data.pharmacy-manager}'.split('-')}")
    private List<Integer> range;

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private PharmacyManagerRepository pharmacyManagerRepository;

    public void loadUsers() {
        Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.USER);

        IntStream.rangeClosed(range.get(0), range.get(1))
                .forEach(i -> {
                    try {
                        String email = "manager" + i + "@pharmacyhub.pk";

                        if (userRepository.findByEmailAddress(email).isEmpty()) {
                            User user = new User();
                            user.setFirstName("User " + i);
                            user.setLastName("Manager");
                            user.setEmailAddress(email);
                            user.setPassword(passwordEncoder.encode("manager" + i));
                            user.setRole(optionalRole.get());
                            user.setRegistered(true);
                            user.setUserType(UserType.PHARMACY_MANAGER);
                            userRepository.save(user);

                            PharmacyManager pharmacyManager = PharmacyManager.builder()
                                    .city("Lahore")
                                    .area("NFC")
                                    .contactNumber("03456142607")
                                    .experience("2 years")
                                    .previousPharmacyName("ABC Pharmacy")
                                    .currentJobStatus("Active")
                                    .shiftTime("Morning")
                                    .user(user)
                                    .build();

                            pharmacyManagerRepository.save(pharmacyManager);
                        }
                    } catch (Exception e) {
                        // Handle the exception appropriately (e.g., log it)
                        e.printStackTrace();
                    }
                });
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/seeder/ProprietorSeeder.java">
package com.pharmacyhub.seeder;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.entity.Proprietor;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.repository.ProprietorRepository;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.stream.IntStream;

@Component
public class ProprietorSeeder {
    @Value("#{'${pharmacyhub.test.data.proprietor}'.split('-')}")
    private List<Integer> range;

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private ProprietorRepository proprietorRepository;

    public void loadUsers() {
        Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.USER);

        IntStream.rangeClosed(range.get(0), range.get(1))
                .forEach(i -> {
                    try {
                        String email = "proprietor" + i + "@pharmacyhub.pk";

                        if (userRepository.findByEmailAddress(email).isEmpty()) {
                            User user = new User();
                            user.setFirstName("User " + i);
                            user.setLastName("Proprietor");
                            user.setEmailAddress(email);
                            user.setPassword(passwordEncoder.encode("proprietor" + i));
                            user.setRole(optionalRole.get());
                            user.setRegistered(true);
                            user.setUserType(UserType.PROPRIETOR);
                            userRepository.save(user);

                            Proprietor proprietor = Proprietor.builder()
                                    .city("Lahore")
                                    .location("NFC")
                                    .contactNumber("03456142607")
                                    .user(user)
                                    .build();

                            proprietorRepository.save(proprietor);
                        }
                    } catch (Exception e) {
                        // Handle the exception appropriately (e.g., log it)
                        e.printStackTrace();
                    }
                });
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/seeder/RoleSeeder.java">
package com.pharmacyhub.seeder;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import java.util.Map;

@Component
public class RoleSeeder {
    @Autowired
    private RoleRepository roleRepository;

    private static final Map<RoleEnum, Integer> ROLE_PRECEDENCE = Map.ofEntries(
        Map.entry(RoleEnum.SUPER_ADMIN, 1),
        Map.entry(RoleEnum.ADMIN, 2),
        Map.entry(RoleEnum.PHARMACY_MANAGER, 3),
        Map.entry(RoleEnum.PROPRIETOR, 3),
        Map.entry(RoleEnum.PHARMACIST, 4),
        Map.entry(RoleEnum.INSTRUCTOR, 4),
        Map.entry(RoleEnum.SALESMAN, 5),
        Map.entry(RoleEnum.STUDENT, 6),
        Map.entry(RoleEnum.EXAM_CREATOR, 5),
        Map.entry(RoleEnum.USER, 7)
    );

    private static final Map<RoleEnum, String> ROLE_DESCRIPTIONS = Map.ofEntries(
        Map.entry(RoleEnum.SUPER_ADMIN, "Super administrator with full system access"),
        Map.entry(RoleEnum.ADMIN, "Administrator with system management capabilities"),
        Map.entry(RoleEnum.PHARMACIST, "Licensed pharmacist user"),
        Map.entry(RoleEnum.PHARMACY_MANAGER, "Pharmacy manager user"),
        Map.entry(RoleEnum.PROPRIETOR, "Pharmacy proprietor/owner"),
        Map.entry(RoleEnum.SALESMAN, "Sales representative"),
        Map.entry(RoleEnum.INSTRUCTOR, "Instructor who can create and manage exams"),
        Map.entry(RoleEnum.STUDENT, "Student who can take exams"),
        Map.entry(RoleEnum.EXAM_CREATOR, "User who can create and manage exams"),
        Map.entry(RoleEnum.USER, "Basic system user")
    );

    public void loadRoles() {
        ROLE_PRECEDENCE.forEach((roleName, precedence) -> {
            if (roleRepository.findByName(roleName).isEmpty()) {
                Role role = Role.builder()
                    .name(roleName)
                    .description(ROLE_DESCRIPTIONS.get(roleName))
                    .precedence(precedence)
                    .system(true)
                    .build();
                roleRepository.save(role);
            }
        });
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/seeder/SalesmanSeeder.java">
package com.pharmacyhub.seeder;

import com.pharmacyhub.constants.RoleEnum;
import com.pharmacyhub.entity.Salesman;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.entity.enums.UserType;
import com.pharmacyhub.repository.SalesmanRepository;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.repository.RoleRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Optional;
import java.util.stream.IntStream;

@Component
public class SalesmanSeeder {
    @Value("#{'${pharmacyhub.test.data.salesman}'.split('-')}")
    private List<Integer> range;

    @Autowired
    private UserRepository userRepository;
    @Autowired
    private RoleRepository roleRepository;
    @Autowired
    private PasswordEncoder passwordEncoder;
    @Autowired
    private SalesmanRepository salesmanRepository;

    public void loadUsers() {
        Optional<Role> optionalRole = roleRepository.findByName(RoleEnum.USER);

        IntStream.rangeClosed(range.get(0), range.get(1))
                .forEach(i -> {
                    try {
                        String email = "salesman" + i + "@pharmacyhub.pk";

                        if (userRepository.findByEmailAddress(email).isEmpty()) {
                            User user = new User();
                            user.setFirstName("User " + i);
                            user.setLastName("Salesman");
                            user.setEmailAddress(email);
                            user.setPassword(passwordEncoder.encode("salesman" + i));
                            user.setRole(optionalRole.get());
                            user.setRegistered(true);
                            user.setUserType(UserType.SALESMAN);
                            userRepository.save(user);

                            Salesman salesman = Salesman.builder()
                                    .city("Lahore")
                                    .area("NFC")
                                    .contactNumber("03456142607")
                                    .experience("2 years")
                                    .previousPharmacyName("ABC Pharmacy")
                                    .currentJobStatus("Active")
                                    .shiftTime("Morning")
                                    .user(user)
                                    .build();

                            salesmanRepository.save(salesman);
                        }
                    } catch (Exception e) {
                        // Handle the exception appropriately (e.g., log it)
                        e.printStackTrace();
                    }
                });
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/EmailService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.entity.Otp;
import jakarta.mail.MessagingException;
import jakarta.mail.internet.MimeMessage;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.mail.javamail.JavaMailSender;
import org.springframework.mail.javamail.MimeMessageHelper;
import org.springframework.stereotype.Service;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

@Service
public class EmailService
{
  @Autowired
  private JavaMailSender mailSender;
  @Autowired
  private ResourceLoader resourceLoader;

  @Value("${spring.mail.username}")
  private String emailAddress;

  public void sendHtmlMail(Otp otp) throws MessagingException
  {
    String subject = "Your OTP for Pharmacy Hub";
    String body = prepareHtmlContent("${otp}",otp.getCode(),"OtpEmail.html");
    emailSender(otp.getUser().getEmailAddress(), subject, body);
  }


  public void sendVerificationEmail(String emailAddress, String token) throws MessagingException
  {
    String verificationUrl = "https://localhost:8080/auth/verify?token=" + token;

    String subject = "Welcome to Pharmacy Hub";
    String body = prepareHtmlContent("${verificationUrl}",verificationUrl,"EmailVerification.html");
    emailSender(emailAddress, subject, body);
  }


  private void emailSender(String emailAddress, String subject, String body) throws MessagingException
  {
    MimeMessage message = mailSender.createMimeMessage();

      MimeMessageHelper helper = new MimeMessageHelper(message, true, "utf-8");
      helper.setTo(emailAddress);
      helper.setSubject(subject);
      helper.setText(body, true);

    mailSender.send(message);
  }

  public String prepareHtmlContent(String key, String value, String template)
  {
    String htmlTemplate = loadHtmlTemplate(template);
    return htmlTemplate.replace(key, value);
  }

  public String loadHtmlTemplate(String htmlTemplate)
  {
    Resource resource = resourceLoader.getResource("classpath:templates/"+htmlTemplate);
    StringBuilder contentBuilder = new StringBuilder();

    try (BufferedReader reader = new BufferedReader(new InputStreamReader(resource.getInputStream(), "UTF-8")))
    {
      String line;
      while ((line = reader.readLine()) != null)
      {
        contentBuilder.append(line).append(System.lineSeparator());
      }
    }
    catch (IOException e)
    {
      e.printStackTrace();
    }

    return contentBuilder.toString();
  }



}
</file>

<file path="src/main/java/com/pharmacyhub/service/EntryService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.entity.Entry;
import com.pharmacyhub.repository.EntryRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class EntryService {

    @Autowired
    private EntryRepository entryRepository;
    @Autowired
    private GoogleContactService googleContactService;

    public List<Entry> getAllEntries() {
        return entryRepository.findAll();
    }

    public Optional<Entry> getEntryById(Long id) {
        return entryRepository.findById(id);
    }

    public Entry saveEntry(Entry entry) {
        Entry savedEntry = entryRepository.save(entry);
        try {
            googleContactService.saveEntryToGoogleContacts(savedEntry);
        } catch (IOException e) {
            // Log the error and handle it appropriately
            e.printStackTrace();
        }
        return savedEntry;
    }

    public void deleteEntry(Long id) {
        entryRepository.deleteById(id);
    }

    public Entry updateEntry(Long id, Entry entryDetails) {
        Entry entry = entryRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("Entry not found for this id :: " + id));

        entry.setName(entryDetails.getName());
        entry.setProfession(entryDetails.getProfession());
        entry.setPharmacyName(entryDetails.getPharmacyName());
        entry.setPotential(entryDetails.getPotential());
        entry.setExperience(entryDetails.getExperience());
        entry.setContactNumber(entryDetails.getContactNumber());
        entry.setCity(entryDetails.getCity());
        entry.setArea(entryDetails.getArea());
        entry.setNotes(entryDetails.getNotes());

        return entryRepository.save(entry);
    }

    public List<Entry> searchEntries(String query) {
        List<Entry> allEntries = entryRepository.findAll();
        return allEntries.stream()
                .filter(entry -> entry.getName().toLowerCase().contains(query.toLowerCase()) ||
                        entry.getPharmacyName().toLowerCase().contains(query.toLowerCase()) ||
                        entry.getCity().toLowerCase().contains(query.toLowerCase()))
                .collect(Collectors.toList());
    }

    public long getEntryCount() {
        return entryRepository.count();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/ExamAttemptService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.FlaggedQuestion;
import com.pharmacyhub.domain.entity.ExamAttempt;
import com.pharmacyhub.domain.entity.ExamResult;
import com.pharmacyhub.domain.entity.UserAnswer;
import com.pharmacyhub.dto.ExamResultDTO;
import com.pharmacyhub.dto.response.ExamAttemptResponseDTO;
import com.pharmacyhub.dto.response.FlaggedQuestionResponseDTO;

import java.util.List;
import java.util.Optional;

public interface ExamAttemptService {
    
    List<ExamAttemptResponseDTO> getAttemptsByUserId(String userId);
    
    List<ExamAttemptResponseDTO> getAttemptsByExamAndUserId(Long examId, String userId);
    
    ExamAttemptResponseDTO getAttemptById(Long id);
    
    ExamAttemptResponseDTO startExam(Long examId, String userId);
    
    void saveAnswer(Long attemptId, Long questionId, String selectedOptionId, Integer timeSpent);
    
    /**
     * Submit an exam and calculate the result
     * @param attemptId the exam attempt ID
     * @return the calculated exam result
     */
    ExamResultDTO submitExamAttempt(Long attemptId);
    
    /**
     * Get the result for a completed exam
     * @param attemptId the exam attempt ID
     * @return the exam result
     */
    ExamResultDTO getExamResult(Long attemptId);
    
    /**
     * Flag a question for review later
     * @param attemptId the exam attempt ID
     * @param questionId the question ID to flag
     * @return the updated exam attempt
     */
    ExamAttempt flagQuestion(Long attemptId, Long questionId);
    
    /**
     * Unflag a previously flagged question
     * @param attemptId the exam attempt ID
     * @param questionId the question ID to unflag
     * @return the updated exam attempt
     */
    ExamAttempt unflagQuestion(Long attemptId, Long questionId);
    
    /**
     * Get all flagged questions for an attempt
     * @param attemptId the exam attempt ID
     * @return a list of flagged questions DTOs
     */
    List<FlaggedQuestionResponseDTO> getFlaggedQuestions(Long attemptId);
}
</file>

<file path="src/main/java/com/pharmacyhub/service/ExamAttemptServiceImpl.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.*;
import com.pharmacyhub.domain.repository.ExamAttemptRepository;
import com.pharmacyhub.domain.repository.ExamRepository;
import com.pharmacyhub.domain.repository.ExamResultRepository;
import com.pharmacyhub.domain.repository.UserAnswerRepository;
import com.pharmacyhub.domain.repository.FlaggedQuestionRepository;
import com.pharmacyhub.domain.repository.QuestionRepository;
import com.pharmacyhub.dto.ExamResultDTO;
import com.pharmacyhub.dto.response.ExamAttemptResponseDTO;
import com.pharmacyhub.dto.response.FlaggedQuestionResponseDTO;
import jakarta.persistence.EntityNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Transactional
public class ExamAttemptServiceImpl implements ExamAttemptService {
    
    private static final Logger logger = LoggerFactory.getLogger(ExamAttemptServiceImpl.class);
    
    private final ExamAttemptRepository examAttemptRepository;
    private final ExamRepository examRepository;
    private final UserAnswerRepository userAnswerRepository;
    private final ExamResultRepository examResultRepository;
    private final FlaggedQuestionRepository flaggedQuestionRepository;
    private final QuestionRepository questionRepository;
    
    public ExamAttemptServiceImpl(
            ExamAttemptRepository examAttemptRepository,
            ExamRepository examRepository,
            UserAnswerRepository userAnswerRepository,
            ExamResultRepository examResultRepository,
            FlaggedQuestionRepository flaggedQuestionRepository,
            QuestionRepository questionRepository) {
        this.examAttemptRepository = examAttemptRepository;
        this.examRepository = examRepository;
        this.userAnswerRepository = userAnswerRepository;
        this.examResultRepository = examResultRepository;
        this.flaggedQuestionRepository = flaggedQuestionRepository;
        this.questionRepository = questionRepository;
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<ExamAttemptResponseDTO> getAttemptsByUserId(String userId) {
        List<ExamAttempt> attempts = examAttemptRepository.findByUserId(userId);
        return attempts.stream()
                .map(this::mapToExamAttemptResponseDTO)
                .collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<ExamAttemptResponseDTO> getAttemptsByExamAndUserId(Long examId, String userId) {
        List<ExamAttempt> attempts = examAttemptRepository.findByExamIdAndUserId(examId, userId);
        return attempts.stream()
                .map(this::mapToExamAttemptResponseDTO)
                .collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public ExamAttemptResponseDTO getAttemptById(Long id) {
        ExamAttempt attempt = examAttemptRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new EntityNotFoundException("Exam attempt not found with id: " + id));
        return mapToExamAttemptResponseDTO(attempt);
    }
    
    @Override
    public ExamAttemptResponseDTO startExam(Long examId, String userId) {
        Exam exam = examRepository.findByIdAndNotDeleted(examId)
                .orElseThrow(() -> new EntityNotFoundException("Exam not found with id: " + examId));
        
        if (exam.getStatus() != Exam.ExamStatus.PUBLISHED) {
            throw new IllegalStateException("Cannot start an exam that is not published");
        }
        
        ExamAttempt attempt = new ExamAttempt();
        attempt.setExam(exam);
        attempt.setUserId(userId);
        attempt.setStartTime(LocalDateTime.now());
        attempt.setStatus(ExamAttempt.AttemptStatus.IN_PROGRESS);
        
        ExamAttempt savedAttempt = examAttemptRepository.save(attempt);
        return mapToExamAttemptResponseDTO(savedAttempt);
    }
    
    @Override
    public void saveAnswer(Long attemptId, Long questionId, String selectedOptionId, Integer timeSpent) {
        ExamAttempt attempt = examAttemptRepository.findByIdAndNotDeleted(attemptId)
                .orElseThrow(() -> new EntityNotFoundException("Exam attempt not found with id: " + attemptId));
        
        if (attempt.getStatus() != ExamAttempt.AttemptStatus.IN_PROGRESS) {
            throw new IllegalStateException("Cannot save answer for an exam that is not in progress");
        }
        
        Question question = questionRepository.findById(questionId)
                .orElseThrow(() -> new EntityNotFoundException("Question not found with id: " + questionId));
        
        // Check if an answer for this question already exists
        Optional<UserAnswer> existingAnswer = userAnswerRepository.findByAttemptIdAndQuestionId(
                attemptId, questionId);
        
        if (existingAnswer.isPresent()) {
            // Update existing answer
            UserAnswer answer = existingAnswer.get();
            answer.setSelectedOptionId(selectedOptionId);
            answer.setTimeSpent(timeSpent);
            userAnswerRepository.save(answer);
        } else {
            // Save new answer
            UserAnswer newAnswer = new UserAnswer();
            newAnswer.setAttempt(attempt);
            newAnswer.setQuestion(question);
            newAnswer.setSelectedOptionId(selectedOptionId);
            newAnswer.setTimeSpent(timeSpent);
            userAnswerRepository.save(newAnswer);
            attempt.getAnswers().add(newAnswer);
        }
        
        examAttemptRepository.save(attempt);
    }
    
    @Override
    public ExamResultDTO submitExamAttempt(Long attemptId) {
        ExamAttempt attempt = examAttemptRepository.findByIdAndNotDeleted(attemptId)
                .orElseThrow(() -> new EntityNotFoundException("Exam attempt not found with id: " + attemptId));
        
        if (attempt.getStatus() != ExamAttempt.AttemptStatus.IN_PROGRESS) {
            throw new IllegalStateException("Cannot submit an exam that is not in progress");
        }
        
        // Update attempt status
        attempt.setStatus(ExamAttempt.AttemptStatus.COMPLETED);
        attempt.setEndTime(LocalDateTime.now());
        examAttemptRepository.save(attempt);
        
        // Calculate and save result
        ExamResult result = calculateExamResult(attempt);
        
        // Map to DTO
        return mapToExamResultDTO(result, attempt);
    }
    
    @Override
    public ExamResultDTO getExamResult(Long attemptId) {
        ExamAttempt attempt = examAttemptRepository.findByIdAndNotDeleted(attemptId)
                .orElseThrow(() -> new EntityNotFoundException("Exam attempt not found with id: " + attemptId));
        
        if (attempt.getStatus() != ExamAttempt.AttemptStatus.COMPLETED) {
            throw new IllegalStateException("Cannot get result for an exam that is not completed");
        }
        
        ExamResult result = examResultRepository.findByAttemptId(attemptId)
                .orElseThrow(() -> new EntityNotFoundException("Exam result not found for attempt id: " + attemptId));
        
        return mapToExamResultDTO(result, attempt);
    }
    
    @Override
    public ExamAttempt flagQuestion(Long attemptId, Long questionId) {
        ExamAttempt attempt = examAttemptRepository.findByIdAndNotDeleted(attemptId)
                .orElseThrow(() -> new EntityNotFoundException("Exam attempt not found with id: " + attemptId));
        
        Question question = questionRepository.findById(questionId)
                .orElseThrow(() -> new EntityNotFoundException("Question not found with id: " + questionId));
        
        // Check if question belongs to the exam
        if (!question.getExam().getId().equals(attempt.getExam().getId())) {
            throw new IllegalArgumentException("Question does not belong to this exam");
        }
        
        // Check if question is already flagged
        if (flaggedQuestionRepository.existsByAttemptIdAndQuestionId(attemptId, questionId)) {
            // Already flagged, nothing to do
            return attempt;
        }
        
        // Create new flagged question
        FlaggedQuestion flaggedQuestion = new FlaggedQuestion();
        flaggedQuestion.setAttempt(attempt);
        flaggedQuestion.setQuestion(question);
        
        flaggedQuestionRepository.save(flaggedQuestion);
        
        return attempt;
    }
    
    @Override
    public ExamAttempt unflagQuestion(Long attemptId, Long questionId) {
        ExamAttempt attempt = examAttemptRepository.findByIdAndNotDeleted(attemptId)
                .orElseThrow(() -> new EntityNotFoundException("Exam attempt not found with id: " + attemptId));
        
        flaggedQuestionRepository.findByAttemptIdAndQuestionIdAndDeletedFalse(attemptId, questionId)
                .ifPresent(flaggedQuestion -> {
                    flaggedQuestion.setDeleted(true);
                    flaggedQuestionRepository.save(flaggedQuestion);
                });
        
        return attempt;
    }
    
    @Override
    public List<FlaggedQuestionResponseDTO> getFlaggedQuestions(Long attemptId) {
        // Check if attempt exists
        if (!examAttemptRepository.existsById(attemptId)) {
            throw new EntityNotFoundException("Exam attempt not found with id: " + attemptId);
        }
        
        List<FlaggedQuestion> flaggedQuestions = flaggedQuestionRepository.findByAttemptIdAndDeletedFalse(attemptId);
        
        return flaggedQuestions.stream()
                .map(this::mapToFlaggedQuestionResponseDTO)
                .collect(Collectors.toList());
    }
    
    /**
     * Calculate exam result based on user answers
     */
    private ExamResult calculateExamResult(ExamAttempt attempt) {
        Exam exam = attempt.getExam();
        List<Question> questions = questionRepository.findByExamId(exam.getId());
        List<UserAnswer> userAnswers = userAnswerRepository.findByAttemptId(attempt.getId());
        
        int totalQuestions = questions.size();
        int correctCount = 0;
        int totalTimeSpent = 0;
        
        // Map of questionId to Question for quick lookup
        Map<Long, Question> questionMap = questions.stream()
                .collect(Collectors.toMap(Question::getId, q -> q));
        
        // Map of questionId to UserAnswer for quick lookup
        Map<Long, UserAnswer> answerMap = userAnswers.stream()
                .collect(Collectors.toMap(
                        answer -> answer.getQuestion().getId(),
                        answer -> answer,
                        (a1, a2) -> a1 // Keep first in case of duplicate (should not happen)
                ));
        
        // Calculate scores
        List<ExamResultDTO.QuestionResultDTO> questionResults = new ArrayList<>();
        
        for (Question question : questions) {
            UserAnswer userAnswer = answerMap.get(question.getId());
            boolean isCorrect = false;
            String userAnswerId = null;
            int timeSpent = 0;
            
            if (userAnswer != null) {
                userAnswerId = userAnswer.getSelectedOptionId();
                timeSpent = userAnswer.getTimeSpent();
                totalTimeSpent += timeSpent;
                
                // Check if answer is correct
                isCorrect = userAnswerId != null && userAnswerId.equals(question.getCorrectAnswer());
                if (isCorrect) {
                    correctCount++;
                }
            }
        }
        
        int totalAnswered = userAnswers.size();
        int incorrectCount = totalAnswered - correctCount;
        int unansweredCount = totalQuestions - totalAnswered;
        
        // Calculate score as a percentage
        double score = (double) correctCount / totalQuestions * 100;
        boolean isPassed = score >= exam.getPassingMarks();
        
        // Create and save result
        ExamResult result = new ExamResult();
        result.setAttempt(attempt);
        result.setScore(score);
        result.setTotalQuestions(totalQuestions);
        result.setCorrectAnswers(correctCount);
        result.setIncorrectAnswers(incorrectCount);
        result.setUnanswered(unansweredCount);
        result.setTimeSpent(totalTimeSpent);
        result.setIsPassed(isPassed);
        result.setCompletedAt(LocalDateTime.now());
        
        return examResultRepository.save(result);
    }
    
    /**
     * Map ExamAttempt entity to ExamAttemptResponseDTO
     */
    private ExamAttemptResponseDTO mapToExamAttemptResponseDTO(ExamAttempt attempt) {
        ExamAttemptResponseDTO dto = new ExamAttemptResponseDTO();
        dto.setId(attempt.getId());
        dto.setExamId(attempt.getExam().getId());
        dto.setExamTitle(attempt.getExam().getTitle());
        dto.setUserId(attempt.getUserId());
        dto.setStartTime(attempt.getStartTime().toString());
        if (attempt.getEndTime() != null) {
            dto.setEndTime(attempt.getEndTime().toString());
        }
        dto.setStatus(attempt.getStatus().toString());
        
        return dto;
    }
    
    /**
     * Map FlaggedQuestion entity to FlaggedQuestionResponseDTO
     */
    private FlaggedQuestionResponseDTO mapToFlaggedQuestionResponseDTO(FlaggedQuestion flaggedQuestion) {
        FlaggedQuestionResponseDTO dto = new FlaggedQuestionResponseDTO();
        dto.setQuestionId(flaggedQuestion.getQuestion().getId());
        dto.setAttemptId(flaggedQuestion.getAttempt().getId());
        dto.setQuestionText(flaggedQuestion.getQuestion().getQuestionText());
        return dto;
    }
    
    /**
     * Map ExamResult entity to ExamResultDTO
     */
    private ExamResultDTO mapToExamResultDTO(ExamResult result, ExamAttempt attempt) {
        Exam exam = attempt.getExam();
        List<UserAnswer> userAnswers = userAnswerRepository.findByAttemptId(attempt.getId());
        List<Question> questions = questionRepository.findByExamId(exam.getId());
        
        // Map of questionId to Question for quick lookup
        Map<Long, Question> questionMap = questions.stream()
                .collect(Collectors.toMap(Question::getId, q -> q));
        
        // Map of questionId to UserAnswer for quick lookup
        Map<Long, UserAnswer> answerMap = userAnswers.stream()
                .collect(Collectors.toMap(
                        answer -> answer.getQuestion().getId(),
                        answer -> answer,
                        (a1, a2) -> a1 // Keep first in case of duplicate (should not happen)
                ));
        
        // Create question results
        List<ExamResultDTO.QuestionResultDTO> questionResults = new ArrayList<>();
        
        for (Question question : questions) {
            UserAnswer userAnswer = answerMap.get(question.getId());
            boolean isCorrect = false;
            String userAnswerId = null;
            int earnedPoints = 0;
            
            if (userAnswer != null) {
                userAnswerId = userAnswer.getSelectedOptionId();
                
                // Check if answer is correct
                isCorrect = userAnswerId != null && userAnswerId.equals(question.getCorrectAnswer());
                if (isCorrect) {
                    earnedPoints = question.getMarks();
                }
            }
            
            ExamResultDTO.QuestionResultDTO questionResult = ExamResultDTO.QuestionResultDTO.builder()
                    .questionId(question.getId())
                    .questionText(question.getQuestionText())
                    .userAnswerId(userAnswerId)
                    .correctAnswerId(question.getCorrectAnswer())
                    .isCorrect(isCorrect)
                    .explanation(question.getExplanation())
                    .points(question.getMarks())
                    .earnedPoints(earnedPoints)
                    .build();
            
            questionResults.add(questionResult);
        }
        
        // Build the result DTO
        return ExamResultDTO.builder()
                .examId(exam.getId())
                .examTitle(exam.getTitle())
                .score(result.getScore())
                .totalMarks(exam.getTotalMarks())
                .passingMarks(exam.getPassingMarks())
                .isPassed(result.getIsPassed())
                .timeSpent(result.getTimeSpent())
                .questionResults(questionResults)
                .build();
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/ExamService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.Exam;
import com.pharmacyhub.dto.request.ExamFilterRequestDTO;
import com.pharmacyhub.dto.response.ExamResponseDTO;

import java.util.List;
import java.util.Map;
import java.util.Optional;

/**
 * Service interface for managing exams
 */
public interface ExamService {
    
    /**
     * Find all active (non-deleted) exams
     */
    List<Exam> findAllActive();
    
    /**
     * Find all published exams
     */
    List<Exam> findAllPublished();
    
    /**
     * Find an exam by ID
     */
    Optional<Exam> findById(Long id);
    
    /**
     * Find exams by status
     */
    List<Exam> findByStatus(Exam.ExamStatus status);
    
    /**
     * Check if an exam with the given title exists
     */
    boolean existsByTitle(String title);
    
    /**
     * Find papers by filter criteria
     */
    List<ExamResponseDTO> findPapersByFilter(ExamFilterRequestDTO filters);
    
    /**
     * Find a paper by ID
     */
    ExamResponseDTO findPaperById(Long id);
    
    /**
     * Get exam statistics
     */
    Map<String, Object> getExamStats();
    
    /**
     * Create a new exam
     */
    Exam createExam(Exam exam);
    
    /**
     * Update an existing exam
     */
    Exam updateExam(Long id, Exam exam);
    
    /**
     * Delete an exam
     */
    void deleteExam(Long id);
    
    /**
     * Publish an exam
     */
    Exam publishExam(Long id);
    
    /**
     * Archive an exam
     */
    Exam archiveExam(Long id);
}
</file>

<file path="src/main/java/com/pharmacyhub/service/ExamServiceImpl.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.Exam;
import com.pharmacyhub.domain.entity.ExamAttempt;
import com.pharmacyhub.domain.entity.Question;
import com.pharmacyhub.domain.repository.ExamAttemptRepository;
import com.pharmacyhub.domain.repository.ExamRepository;
import com.pharmacyhub.domain.repository.ExamResultRepository;
import com.pharmacyhub.domain.repository.QuestionRepository;
import com.pharmacyhub.dto.request.ExamFilterRequestDTO;
import com.pharmacyhub.dto.response.ExamResponseDTO;
import jakarta.persistence.EntityNotFoundException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Transactional
public class ExamServiceImpl implements ExamService {
    
    private static final Logger logger = LoggerFactory.getLogger(ExamServiceImpl.class);
    
    private final ExamRepository examRepository;
    private final QuestionRepository questionRepository;
    private final ExamAttemptRepository examAttemptRepository;
    private final ExamResultRepository examResultRepository;
    
    @Autowired
    public ExamServiceImpl(
            ExamRepository examRepository, 
            QuestionRepository questionRepository,
            ExamAttemptRepository examAttemptRepository,
            ExamResultRepository examResultRepository) {
        this.examRepository = examRepository;
        this.questionRepository = questionRepository;
        this.examAttemptRepository = examAttemptRepository;
        this.examResultRepository = examResultRepository;
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Exam> findAllActive() {
        return examRepository.findByDeletedFalse();
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Exam> findAllPublished() {
        return examRepository.findByStatusAndDeletedFalse(Exam.ExamStatus.PUBLISHED);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Optional<Exam> findById(Long id) {
        return examRepository.findByIdAndDeletedFalse(id);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Exam> findByStatus(Exam.ExamStatus status) {
        return examRepository.findByStatusAndDeletedFalse(status);
    }
    
    @Override
    @Transactional(readOnly = true)
    public boolean existsByTitle(String title) {
        return examRepository.existsByTitle(title);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<ExamResponseDTO> findPapersByFilter(ExamFilterRequestDTO filters) {
        logger.info("Finding papers with filters: {}", filters);
        
        List<Exam> exams;
        
        if (filters.getType() != null) {
            // Filter by paper type
            String paperType = filters.getType().toUpperCase();
            // Implement custom filtering based on paper type
            exams = examRepository.findByTagsContainingAndDeletedFalse(paperType);
        } else {
            // No specific type, get all published exams
            exams = findAllPublished();
        }
        
        // Apply difficulty filter if specified
        if (filters.getDifficulty() != null && !filters.getDifficulty().isEmpty()) {
            exams = exams.stream()
                    .filter(exam -> hasTag(exam, filters.getDifficulty()))
                    .collect(Collectors.toList());
        }
        
        // Apply topic/subject filter if specified
        if (filters.getTopic() != null && !filters.getTopic().isEmpty()) {
            exams = exams.stream()
                    .filter(exam -> hasTag(exam, filters.getTopic()))
                    .collect(Collectors.toList());
        }
        
        // Convert to DTOs and return
        return exams.stream()
                .map(this::mapToExamResponseDTO)
                .collect(Collectors.toList());
    }
    
    @Override
    @Transactional(readOnly = true)
    public ExamResponseDTO findPaperById(Long id) {
        Exam exam = examRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new EntityNotFoundException("Paper not found with id: " + id));
        
        return mapToExamResponseDTO(exam);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Map<String, Object> getExamStats() {
        Map<String, Object> stats = new HashMap<>();
        
        // Count total papers
        long totalPapers = examRepository.countByStatusAndDeletedFalse(Exam.ExamStatus.PUBLISHED);
        stats.put("totalPapers", totalPapers);
        
        // Get average duration
        Double avgDuration = examRepository.getAverageDuration();
        stats.put("avgDuration", avgDuration != null ? avgDuration : 0);
        
        // Get completion rate
        Double completionRate = examResultRepository.getAverageCompletionRate();
        stats.put("completionRate", completionRate != null ? completionRate : 0);
        
        // Count active users (users with at least one attempt)
        long activeUsers = examAttemptRepository.countDistinctUserIds();
        stats.put("activeUsers", activeUsers);
        
        return stats;
    }
    
    @Override
    public Exam createExam(Exam exam) {
        // Validate exam
        validateExam(exam);
        
        if (examRepository.existsByTitle(exam.getTitle())) {
            throw new IllegalArgumentException("An exam with this title already exists");
        }
        
        exam.setStatus(Exam.ExamStatus.DRAFT);
        
        // Save the exam
        Exam savedExam = examRepository.save(exam);
        
        // Save questions if provided
        if (exam.getQuestions() != null && !exam.getQuestions().isEmpty()) {
            for (Question question : exam.getQuestions()) {
                question.setExam(savedExam);
            }
            questionRepository.saveAll(exam.getQuestions());
        }
        
        return savedExam;
    }
    
    @Override
    public Exam updateExam(Long id, Exam exam) {
        // Find existing exam
        Exam existingExam = examRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new EntityNotFoundException("Exam not found with id: " + id));
        
        // Validate exam
        validateExam(exam);
        
        if (!existingExam.getTitle().equals(exam.getTitle()) && 
            examRepository.existsByTitle(exam.getTitle())) {
            throw new IllegalArgumentException("An exam with this title already exists");
        }
        
        // Update basic properties
        existingExam.setTitle(exam.getTitle());
        existingExam.setDescription(exam.getDescription());
        existingExam.setDuration(exam.getDuration());
        existingExam.setTotalMarks(exam.getTotalMarks());
        existingExam.setPassingMarks(exam.getPassingMarks());
        existingExam.setStatus(exam.getStatus());
        
        // Save the updated exam
        Exam updatedExam = examRepository.save(existingExam);
        
        // Update questions if provided
        if (exam.getQuestions() != null) {
            // Get existing questions
            List<Question> existingQuestions = questionRepository.findByExamIdAndDeletedFalse(id);
            
            // Mark all existing questions as deleted
            for (Question question : existingQuestions) {
                question.setDeleted(true);
            }
            questionRepository.saveAll(existingQuestions);
            
            // Add new questions
            for (Question question : exam.getQuestions()) {
                question.setExam(updatedExam);
                question.setId(null); // Ensure new questions are created
            }
            questionRepository.saveAll(exam.getQuestions());
        }
        
        return updatedExam;
    }
    
    @Override
    public void deleteExam(Long id) {
        Exam exam = examRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new EntityNotFoundException("Exam not found with id: " + id));
        
        // Soft delete
        exam.setDeleted(true);
        examRepository.save(exam);
        
        // Soft delete all questions
        List<Question> questions = questionRepository.findByExamIdAndDeletedFalse(id);
        for (Question question : questions) {
            question.setDeleted(true);
        }
        questionRepository.saveAll(questions);
    }
    
    @Override
    public Exam publishExam(Long id) {
        Exam exam = examRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new EntityNotFoundException("Exam not found with id: " + id));
        
        // Check if the exam has questions
        List<Question> questions = questionRepository.findByExamIdAndDeletedFalse(id);
        if (questions.isEmpty()) {
            throw new IllegalStateException("Cannot publish an exam without questions");
        }
        
        // Update status
        exam.setStatus(Exam.ExamStatus.PUBLISHED);
        return examRepository.save(exam);
    }
    
    @Override
    public Exam archiveExam(Long id) {
        Exam exam = examRepository.findByIdAndDeletedFalse(id)
                .orElseThrow(() -> new EntityNotFoundException("Exam not found with id: " + id));
        
        // Update status
        exam.setStatus(Exam.ExamStatus.ARCHIVED);
        return examRepository.save(exam);
    }
    
    /**
     * Map exam entity to response DTO
     */
    private ExamResponseDTO mapToExamResponseDTO(Exam exam) {
        ExamResponseDTO dto = new ExamResponseDTO();
        dto.setId(exam.getId());
        dto.setTitle(exam.getTitle());
        dto.setDescription(exam.getDescription());
        dto.setDuration(exam.getDuration());
        dto.setTotalMarks(exam.getTotalMarks());
        dto.setPassingMarks(exam.getPassingMarks());
        dto.setStatus(exam.getStatus());
        
        // Get question count
        int questionCount = questionRepository.countByExamIdAndDeletedFalse(exam.getId());
        dto.setAttemptCount(questionCount);
        
        // Get exam statistics
        Long attemptCount = examAttemptRepository.countByExamIdAndStatusAndDeletedFalse(
                exam.getId(), ExamAttempt.AttemptStatus.COMPLETED);
        dto.setAttemptCount(attemptCount != null ? attemptCount.intValue() : 0);
        
        // Get success rate
        Double successRate = examResultRepository.getSuccessRateByExamId(exam.getId());
        dto.setAverageScore(successRate != null ? successRate : 0.0);
        
        // Get tags
        List<String> tags = new ArrayList<>();
        if (exam.getTags() != null) {
            tags.addAll(exam.getTags());
        }
        
        return dto;
    }
    
    /**
     * Extract paper type from exam tags
     */
    private String getPaperType(Exam exam) {
        if (exam.getTags() == null) {
            return "PRACTICE"; // Default type
        }
        
        for (String tag : exam.getTags()) {
            if (tag.equalsIgnoreCase("MODEL")) {
                return "MODEL";
            } else if (tag.equalsIgnoreCase("PAST")) {
                return "PAST";
            } else if (tag.equalsIgnoreCase("SUBJECT")) {
                return "SUBJECT";
            }
        }
        
        return "PRACTICE"; // Default type
    }
    
    /**
     * Check if exam has a specific tag
     */
    private boolean hasTag(Exam exam, String tag) {
        if (exam.getTags() == null) {
            return false;
        }
        
        return exam.getTags().stream()
                .anyMatch(t -> t.equalsIgnoreCase(tag));
    }
    
    /**
     * Validate exam
     */
    private void validateExam(Exam exam) {
        if (exam.getTitle() == null || exam.getTitle().trim().isEmpty()) {
            throw new IllegalArgumentException("Exam title is required");
        }
        
        if (exam.getDuration() == null || exam.getDuration() < 0) {
            throw new IllegalArgumentException("Exam duration must be positive or zero");
        }
        
        if (exam.getTotalMarks() == null || exam.getTotalMarks() < 0) {
            throw new IllegalArgumentException("Total marks must be positive or zero");
        }
        
        if (exam.getPassingMarks() == null || exam.getPassingMarks() < 0) {
            throw new IllegalArgumentException("Passing marks must be positive or zero");
        }
        
        if (exam.getPassingMarks() > exam.getTotalMarks()) {
            throw new IllegalArgumentException("Passing marks cannot be greater than total marks");
        }
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/GoogleContactService.java">
package com.pharmacyhub.service;

import com.google.api.client.auth.oauth2.Credential;
import com.google.api.client.googleapis.auth.oauth2.GoogleAuthorizationCodeFlow;
import com.google.api.client.googleapis.auth.oauth2.GoogleClientSecrets;
import com.google.api.client.googleapis.javanet.GoogleNetHttpTransport;
import com.google.api.client.http.javanet.NetHttpTransport;
import com.google.api.client.json.JsonFactory;
import com.google.api.client.json.jackson2.JacksonFactory;
import com.google.api.client.util.store.FileDataStoreFactory;
import com.google.api.services.people.v1.PeopleService;
import com.google.api.services.people.v1.model.Name;
import com.google.api.services.people.v1.model.Person;
import com.google.api.services.people.v1.model.PhoneNumber;
import com.pharmacyhub.entity.Entry;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.security.GeneralSecurityException;
import java.util.Collections;
import java.util.List;

@Service
public class GoogleContactService {

    private static final String APPLICATION_NAME = "Pharmacy Hub";
    private static final JsonFactory JSON_FACTORY = JacksonFactory.getDefaultInstance();
    private static final String TOKENS_DIRECTORY_PATH = "tokens";
    private static final List<String> SCOPES = Collections.singletonList("https://www.googleapis.com/auth/contacts");

    @Autowired
    private ResourceLoader resourceLoader;

    private final NetHttpTransport HTTP_TRANSPORT;

    public GoogleContactService() throws GeneralSecurityException, IOException {
        HTTP_TRANSPORT = GoogleNetHttpTransport.newTrustedTransport();
    }

    private Credential getCredentials() throws IOException {
        Resource resource = resourceLoader.getResource("classpath:credentials.json");
        InputStream in = resource.getInputStream();
        GoogleClientSecrets clientSecrets = GoogleClientSecrets.load(JSON_FACTORY, new InputStreamReader(in));

        GoogleAuthorizationCodeFlow flow = new GoogleAuthorizationCodeFlow.Builder(
                HTTP_TRANSPORT, JSON_FACTORY, clientSecrets, SCOPES)
                .setDataStoreFactory(new FileDataStoreFactory(new java.io.File(TOKENS_DIRECTORY_PATH)))
                .setAccessType("offline")
                .build();

        // Here you would typically use a more robust way to get the user's credentials
        // This is a simplified version for demonstration purposes
        return flow.loadCredential("user");
    }

    public void saveEntryToGoogleContacts(Entry entry) throws IOException {
        Credential credential = getCredentials();
        PeopleService peopleService = new PeopleService.Builder(HTTP_TRANSPORT, JSON_FACTORY, credential)
                .setApplicationName(APPLICATION_NAME)
                .build();

        Person contactToCreate = new Person();
        contactToCreate.setNames(Collections.singletonList(new Name().setGivenName(entry.getName())));
        contactToCreate.setPhoneNumbers(Collections.singletonList(new PhoneNumber().setValue(entry.getContactNumber())));

        Person createdContact = peopleService.people().createContact(contactToCreate).execute();
        System.out.println("Contact created: " + createdContact.getResourceName());
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/HealthService.java">
package com.pharmacyhub.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

@Service
public class HealthService {

    @Autowired
    private JdbcTemplate jdbcTemplate;

    public Map<String, Object> getHealthStatus() {
        Map<String, Object> status = new HashMap<>();
        Map<String, Object> details = new HashMap<>();
        boolean isHealthy = true;
        String message = "API server is available";

        // Check database connectivity
        try {
            jdbcTemplate.queryForObject("SELECT 1", Integer.class);
            details.put("database", "connected");
        } catch (Exception e) {
            isHealthy = false;
            message = "Database connection failed";
            details.put("database", "disconnected");
            details.put("error", e.getMessage());
        }

        // Add system info
        details.put("timestamp", LocalDateTime.now().toString());
        details.put("memory", Runtime.getRuntime().freeMemory() / 1024 / 1024 + "MB free");
        details.put("version", "1.0.0");
        details.put("environment", System.getProperty("spring.profiles.active", "default"));

        status.put("status", isHealthy);
        status.put("message", message);
        status.put("details", details);

        return status;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/JsonExamUploadService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.Exam;
import com.pharmacyhub.domain.entity.Option;
import com.pharmacyhub.domain.entity.Question;
import com.pharmacyhub.dto.request.JsonExamUploadRequestDTO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.core.type.TypeReference;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;

/**
 * Service for processing JSON data and creating exams
 */
@Service
public class JsonExamUploadService {
    private static final Logger logger = LoggerFactory.getLogger(JsonExamUploadService.class);
    
    private final ExamService examService;
    private final ObjectMapper objectMapper;
    
    @Autowired
    public JsonExamUploadService(ExamService examService, ObjectMapper objectMapper) {
        this.examService = examService;
        this.objectMapper = objectMapper;
    }
    
    /**
     * Process JSON data and create an exam
     * 
     * @param requestDTO The request containing exam metadata and JSON content
     * @return The created exam
     */
    @Transactional
    public Exam processJsonAndCreateExam(JsonExamUploadRequestDTO requestDTO) {
        try {
            // Parse JSON content
            List<Map<String, Object>> jsonData = objectMapper.readValue(
                    requestDTO.getJsonContent(), 
                    new TypeReference<List<Map<String, Object>>>() {}
            );
            
            // Create exam entity
            Exam exam = new Exam();
            exam.setTitle(requestDTO.getTitle());
            exam.setDescription(requestDTO.getDescription());
            exam.setDuration(requestDTO.getDuration());
            
            // We'll calculate totalMarks based on questions (default 1 mark per question)
            int totalMarks = jsonData.size();
            exam.setTotalMarks(totalMarks);
            
            // Set passing marks if provided, otherwise use default (60% of total)
            if (requestDTO.getPassingMarks() != null) {
                exam.setPassingMarks(requestDTO.getPassingMarks());
            } else {
                exam.setPassingMarks((int) Math.ceil(totalMarks * 0.6));
            }
            
            // Set status
            exam.setStatus(requestDTO.getStatus() != null ? requestDTO.getStatus() : Exam.ExamStatus.DRAFT);
            
            // Set tags
            exam.setTags(requestDTO.getTags());
            
            // Process questions
            List<Question> questions = processQuestions(jsonData, exam);
            exam.setQuestions(questions);
            
            // Create exam
            return examService.createExam(exam);
            
        } catch (Exception e) {
            logger.error("Error processing JSON data: {}", e.getMessage(), e);
            throw new RuntimeException("Error processing JSON data: " + e.getMessage(), e);
        }
    }
    
    /**
     * Process JSON data and convert to Question entities
     * 
     * @param jsonData The JSON data
     * @param exam The parent exam
     * @return List of Question entities
     */
    private List<Question> processQuestions(List<Map<String, Object>> jsonData, Exam exam) {
        List<Question> questions = new ArrayList<>();
        
        for (int i = 0; i < jsonData.size(); i++) {
            Map<String, Object> questionData = jsonData.get(i);
            
            // Create question
            Question question = new Question();
            question.setExam(exam);
            
            // Set question number (use existing or create sequential)
            int questionNumber = getQuestionNumber(questionData, i);
            question.setQuestionNumber(questionNumber);
            
            // Set question text
            String questionText = getQuestionText(questionData);
            question.setQuestionText(questionText);
            
            // Set explanation if available
            if (questionData.containsKey("explanation")) {
                question.setExplanation(questionData.get("explanation").toString());
            }
            
            // Set default marks (1 per question)
            question.setMarks(1);
            
            // Process options
            Object optionsObj = questionData.get("options");
            List<Option> options = processOptions(optionsObj, question);
            question.setOptions(options);
            
            // Set correct answer
            String correctAnswer = getCorrectAnswer(questionData);
            question.setCorrectAnswer(correctAnswer);
            
            questions.add(question);
        }
        
        return questions;
    }
    
    /**
     * Get question number from data
     */
    private int getQuestionNumber(Map<String, Object> questionData, int defaultIndex) {
        // Check different possible field names
        if (questionData.containsKey("number")) {
            return parseIntValue(questionData.get("number"));
        } else if (questionData.containsKey("question_number")) {
            return parseIntValue(questionData.get("question_number"));
        } else if (questionData.containsKey("questionNumber")) {
            return parseIntValue(questionData.get("questionNumber"));
        }
        
        // Default to index + 1
        return defaultIndex + 1;
    }
    
    /**
     * Get question text from data
     */
    private String getQuestionText(Map<String, Object> questionData) {
        // Check different possible field names
        if (questionData.containsKey("question")) {
            return questionData.get("question").toString();
        } else if (questionData.containsKey("text")) {
            return questionData.get("text").toString();
        } else if (questionData.containsKey("questionText")) {
            return questionData.get("questionText").toString();
        }
        
        throw new IllegalArgumentException("Question text not found in JSON data");
    }
    
    /**
     * Get correct answer from data
     */
    private String getCorrectAnswer(Map<String, Object> questionData) {
        if (!questionData.containsKey("answer")) {
            throw new IllegalArgumentException("Correct answer not found in JSON data");
        }
        
        String answer = questionData.get("answer").toString();
        
        // Extract just the letter if it's in a format like "A)" or "A) Option text"
        if (answer.length() > 1) {
            if (answer.matches("^[A-D]\\).*") || answer.matches("^[A-D]\\s.*")) {
                answer = answer.substring(0, 1);
            }
        }
        
        return answer.toUpperCase();
    }
    
    /**
     * Process options from JSON data
     */
    private List<Option> processOptions(Object optionsObj, Question question) {
        List<Option> optionList = new ArrayList<>();
        
        if (optionsObj == null) {
            throw new IllegalArgumentException("Options not found in JSON data");
        }
        
        try {
            // If options is a Map with A, B, C, D keys
            if (optionsObj instanceof Map<?, ?>) {
                @SuppressWarnings("unchecked")
                Map<String, Object> optionsMap = (Map<String, Object>) optionsObj;
                
                for (Map.Entry<String, Object> entry : optionsMap.entrySet()) {
                    String label = entry.getKey();
                    String text = entry.getValue().toString();
                    
                    Option option = new Option();
                    option.setQuestion(question);
                    option.setLabel(label);
                    option.setText(text);
                    
                    // Don't set isCorrect here - we'll set it later based on the correctAnswer
                    
                    optionList.add(option);
                }
            }
            // If options is a List
            else if (optionsObj instanceof List<?>) {
                @SuppressWarnings("unchecked")
                List<Object> optionsList = (List<Object>) optionsObj;
                
                // Generate labels A, B, C, D...
                for (int i = 0; i < optionsList.size(); i++) {
                    String label = String.valueOf((char) ('A' + i));
                    String text;
                    
                    // Handle different formats (string or object with text property)
                    if (optionsList.get(i) instanceof String) {
                        text = (String) optionsList.get(i);
                    } else if (optionsList.get(i) instanceof Map<?, ?>) {
                        @SuppressWarnings("unchecked")
                        Map<String, Object> optionMap = (Map<String, Object>) optionsList.get(i);
                        text = optionMap.get("text").toString();
                    } else {
                        throw new IllegalArgumentException("Invalid option format in JSON data");
                    }
                    
                    Option option = new Option();
                    option.setQuestion(question);
                    option.setLabel(label);
                    option.setText(text);
                    
                    optionList.add(option);
                }
            } else {
                throw new IllegalArgumentException("Invalid options format in JSON data");
            }
            
            // Mark the correct option
            String correctAnswer = question.getCorrectAnswer();
            for (Option option : optionList) {
                if (option.getLabel().equalsIgnoreCase(correctAnswer)) {
                    option.setIsCorrect(true);
                } else {
                    option.setIsCorrect(false);
                }
            }
            
            return optionList;
            
        } catch (Exception e) {
            logger.error("Error processing options: {}", e.getMessage(), e);
            throw new RuntimeException("Error processing options: " + e.getMessage(), e);
        }
    }
    
    /**
     * Parse integer value from object
     */
    private int parseIntValue(Object value) {
        if (value instanceof Integer) {
            return (Integer) value;
        } else if (value instanceof String) {
            return Integer.parseInt((String) value);
        } else if (value instanceof Number) {
            return ((Number) value).intValue();
        }
        
        throw new IllegalArgumentException("Cannot parse integer value: " + value);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/OptionService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.Option;
import java.util.List;
import java.util.Optional;

public interface OptionService {
    List<Option> getOptionsByQuestionId(Long questionId);
    Optional<Option> getOptionById(Long id);
    Option createOption(Option option);
    Option updateOption(Long id, Option option);
    void deleteOption(Long id);
    Optional<Option> getCorrectOptionByQuestionId(Long questionId);
    Long countOptionsByQuestionId(Long questionId);
    boolean existsByQuestionIdAndLabel(Long questionId, String label);
}
</file>

<file path="src/main/java/com/pharmacyhub/service/OptionServiceImpl.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.Option;
import com.pharmacyhub.domain.repository.OptionRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class OptionServiceImpl implements OptionService {

    private final OptionRepository optionRepository;

    public OptionServiceImpl(OptionRepository optionRepository) {
        this.optionRepository = optionRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public List<Option> getOptionsByQuestionId(Long questionId) {
        return optionRepository.findByQuestionId(questionId);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<Option> getOptionById(Long id) {
        return optionRepository.findByIdAndNotDeleted(id);
    }

    @Override
    public Option createOption(Option option) {
        return optionRepository.save(option);
    }

    @Override
    public Option updateOption(Long id, Option optionDetails) {
        Option option = optionRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new EntityNotFoundException("Option not found with id: " + id));

        option.setLabel(optionDetails.getLabel());
        option.setText(optionDetails.getText());
        option.setIsCorrect(optionDetails.getIsCorrect());

        return optionRepository.save(option);
    }

    @Override
    public void deleteOption(Long id) {
        Option option = optionRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new EntityNotFoundException("Option not found with id: " + id));
        option.setDeleted(true);
        optionRepository.save(option);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<Option> getCorrectOptionByQuestionId(Long questionId) {
        return optionRepository.findCorrectOptionByQuestionId(questionId);
    }

    @Override
    @Transactional(readOnly = true)
    public Long countOptionsByQuestionId(Long questionId) {
        return optionRepository.countByQuestionId(questionId);
    }

    @Override
    @Transactional(readOnly = true)
    public boolean existsByQuestionIdAndLabel(Long questionId, String label) {
        return optionRepository.existsByQuestionIdAndLabel(questionId, label);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/OtpService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.UserDTO;
import com.pharmacyhub.entity.Otp;
import com.pharmacyhub.entity.User;
import com.pharmacyhub.repository.OtpRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.Optional;
import java.util.Random;

import jakarta.mail.MessagingException;

@Service
public class OtpService
{
  @Autowired
  private OtpRepository otpRepository;
  @Autowired
  private UserService userService;
  @Autowired
  private EmailService emailService;

  public Otp generateOtp(UserDTO userDTO)
  {
    User user = userService.getUserByEmailAddress((UserDTO) userDTO);
    if (user != null)
    {
      Otp otp = new Otp();
      otp.setUser(user);
      otp.setCode(generateRandomOtpCode());
      otp.setCreatedAt(LocalDateTime.now());
      otp.setExpiresAt(LocalDateTime.now().plusMinutes(5));
      otpRepository.save(otp);

      sendOtpToUser(otp);
      return otp;
    }
    return null;
  }

  private void sendOtpToUser(Otp otp)
  {
    try
    {
      emailService.sendHtmlMail(otp);
    }
    catch (MessagingException e)
    {
      throw new RuntimeException(e);
    }
  }

  public boolean validateOtp(UserDTO userDTO)
  {
    User user = userService.getUserByEmailAddress(userDTO);
    if (user != null)
    {
      Optional<Otp> otpOptional = otpRepository.findTopByUserAndCodeOrderByCreatedAtDesc(user, userDTO.getOtpCode());
      if (otpOptional.isPresent())
      {
        Otp otp = otpOptional.get();
        return !otp.getExpiresAt().isBefore(LocalDateTime.now());
      }
    }
    return false;
  }

  private String generateRandomOtpCode()
  {
    Random random = new Random();
    int otp = 100000 + random.nextInt(900000);
    return String.valueOf(otp);
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/PermissionApiService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.security.constants.ExamPermissionConstants;
import com.pharmacyhub.security.domain.Permission;
import com.pharmacyhub.security.service.RBACService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Service for handling permission-related API operations
 * Provides methods for the API controllers to check user permissions
 */
@Service
public class PermissionApiService {
    private static final Logger logger = LoggerFactory.getLogger(PermissionApiService.class);
    
    private final RBACService rbacService;
    private final UserService userService;
    
    // Cache for permission checks to reduce DB queries
    private final Map<String, Boolean> permissionCache = new ConcurrentHashMap<>();
    
    public PermissionApiService(RBACService rbacService, UserService userService) {
        this.rbacService = rbacService;
        this.userService = userService;
    }
    
    /**
     * Check if the current user has a specific permission
     */
    public boolean hasPermission(String permission) {
        User currentUser = userService.getLoggedInUser();
        if (currentUser == null) {
            return false;
        }
        
        // Generate cache key
        String cacheKey = currentUser.getId() + ":" + permission;
        
        // Check cache first
        Boolean cachedResult = permissionCache.get(cacheKey);
        if (cachedResult != null) {
            return cachedResult;
        }
        
        // Get permissions and check
        boolean hasPermission = rbacService.userHasPermission(currentUser.getId(), permission);
        
        // Cache the result
        permissionCache.put(cacheKey, hasPermission);
        
        return hasPermission;
    }
    
    /**
     * Check multiple permissions at once for the current user
     * Returns a map of permission names to boolean values
     */
    public Map<String, Boolean> checkMultiplePermissions(String... permissions) {
        User currentUser = userService.getLoggedInUser();
        Map<String, Boolean> result = new HashMap<>();
        
        if (currentUser == null) {
            for (String permission : permissions) {
                result.put(permission, false);
            }
            return result;
        }
        
        Set<Permission> userPermissions = rbacService.getUserEffectivePermissions(currentUser.getId());
        
        for (String permission : permissions) {
            boolean hasPermission = userPermissions.stream()
                    .anyMatch(p -> p.getName().equals(permission));
            
            result.put(permission, hasPermission);
        }
        
        return result;
    }
    
    /**
     * Check all exam permissions for the current user
     * Returns a map of exam permission names to boolean values
     */
    public Map<String, Boolean> checkExamPermissions() {
        Map<String, Boolean> result = new HashMap<>();
        
        // Basic exam access
        result.put(ExamPermissionConstants.VIEW_EXAMS, hasPermission(ExamPermissionConstants.VIEW_EXAMS));
        result.put(ExamPermissionConstants.TAKE_EXAM, hasPermission(ExamPermissionConstants.TAKE_EXAM));
        
        // Exam management
        result.put(ExamPermissionConstants.CREATE_EXAM, hasPermission(ExamPermissionConstants.CREATE_EXAM));
        result.put(ExamPermissionConstants.EDIT_EXAM, hasPermission(ExamPermissionConstants.EDIT_EXAM));
        result.put(ExamPermissionConstants.DELETE_EXAM, hasPermission(ExamPermissionConstants.DELETE_EXAM));
        result.put(ExamPermissionConstants.DUPLICATE_EXAM, hasPermission(ExamPermissionConstants.DUPLICATE_EXAM));
        
        // Question management
        result.put(ExamPermissionConstants.MANAGE_QUESTIONS, hasPermission(ExamPermissionConstants.MANAGE_QUESTIONS));
        
        // Exam administration
        result.put(ExamPermissionConstants.PUBLISH_EXAM, hasPermission(ExamPermissionConstants.PUBLISH_EXAM));
        result.put(ExamPermissionConstants.UNPUBLISH_EXAM, hasPermission(ExamPermissionConstants.UNPUBLISH_EXAM));
        result.put(ExamPermissionConstants.ASSIGN_EXAM, hasPermission(ExamPermissionConstants.ASSIGN_EXAM));
        
        // Results & grading
        result.put(ExamPermissionConstants.GRADE_EXAM, hasPermission(ExamPermissionConstants.GRADE_EXAM));
        result.put(ExamPermissionConstants.VIEW_RESULTS, hasPermission(ExamPermissionConstants.VIEW_RESULTS));
        result.put(ExamPermissionConstants.EXPORT_RESULTS, hasPermission(ExamPermissionConstants.EXPORT_RESULTS));
        
        // Analytics
        result.put(ExamPermissionConstants.VIEW_ANALYTICS, hasPermission(ExamPermissionConstants.VIEW_ANALYTICS));
        
        return result;
    }
    
    /**
     * Check if the current user has admin privileges for exams
     * Admin privileges include create, edit, delete, publish, etc.
     */
    public boolean hasExamAdminPrivileges() {
        return hasPermission(ExamPermissionConstants.CREATE_EXAM) &&
               hasPermission(ExamPermissionConstants.EDIT_EXAM) &&
               hasPermission(ExamPermissionConstants.PUBLISH_EXAM);
    }
    
    /**
     * Clear the permission cache for a user
     * Should be called when a user's permissions change
     */
    public void clearPermissionCache(Long userId) {
        if (userId == null) {
            permissionCache.clear();
            return;
        }
        
        String userPrefix = userId + ":";
        permissionCache.keySet().removeIf(key -> key.startsWith(userPrefix));
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/PharmacistService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.constants.UserEnum;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.PharmacistDTO;
import com.pharmacyhub.dto.display.ConnectionDisplayDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.engine.PHEngine;
import com.pharmacyhub.engine.PHMapper;
import com.pharmacyhub.entity.Pharmacist;
import com.pharmacyhub.entity.connections.PharmacistsConnections;
import com.pharmacyhub.repository.PharmacistRepository;
import com.pharmacyhub.repository.PharmacyManagerRepository;
import com.pharmacyhub.repository.ProprietorRepository;
import com.pharmacyhub.repository.SalesmanRepository;
import com.pharmacyhub.repository.connections.PharmacistsConnectionsRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Transactional
public class PharmacistService extends PHEngine implements PHUserService
{
  private final Logger log = LoggerFactory.getLogger(PharmacistService.class);

  @Autowired
  private PharmacistRepository pharmacistRepository;
  @Autowired
  private SalesmanRepository salesmanRepository;
  @Autowired
  private ProprietorRepository proprietorRepository;
  @Autowired
  private PharmacyManagerRepository pharmacyManagerRepository;
  
  @Autowired
  private PharmacistsConnectionsRepository pharmacistsConnectionsRepository;
  @Autowired
  private PHMapper phMapper;

  @Override
  public PHUserDTO saveUser(PHUserDTO pharmacistDTO)
  {
    Pharmacist pharmacist = phMapper.getPharmacist((PharmacistDTO) pharmacistDTO);
    getLoggedInUser().setRegistered(true);
    getLoggedInUser().setUserType(com.pharmacyhub.entity.enums.UserType.PHARMACIST);
    pharmacist.setUser(getLoggedInUser());
    Pharmacist savedPharmacist = pharmacistRepository.save(pharmacist);
    return phMapper.getPharmacistDTO(savedPharmacist);
  }

  @Override
  public PHUserDTO updateUser(PHUserDTO proprietorDTO)
  {
    Pharmacist pharmacist = phMapper.getPharmacist((PharmacistDTO) proprietorDTO);
    pharmacist.setUser(getLoggedInUser());
    Pharmacist savedPharmacist = pharmacistRepository.save(pharmacist);
    return phMapper.getPharmacistDTO(savedPharmacist);
  }

  @Override
  public PHUserDTO findUser(long id)
  {
    Optional<Pharmacist> pharmacist = pharmacistRepository.findById(id);
    return phMapper.getPharmacistDTO(pharmacist.get());
  }

  @Override
  public List<UserDisplayDTO> findAllUsers()
  {
    return pharmacistRepository.findAll().stream().map(pharmacist -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(pharmacist.getUser());
      userDisplayDTO.setPharmacist(phMapper.getPharmacistDTO(pharmacist));

      userDisplayDTO.setConnected(getAllUserConnections().stream().anyMatch(userDisplayDTO1 -> {
        return userDisplayDTO1.getPharmacist().getId().equals(pharmacist.getId());
      }));

      return userDisplayDTO;
    }).collect(Collectors.toList());
  }

  @Override
  public void connectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    Pharmacist pharmacist = phMapper.getPharmacist((PharmacistDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<PharmacistsConnections> pharmacistsConnectionsList = pharmacistsConnectionsRepository.findByUserAndPharmacistAndState(getLoggedInUser(), pharmacist, StateEnum.READY_TO_CONNECT);

    if (pharmacistsConnectionsList.isEmpty())
    {
      PharmacistsConnections pharmacistsConnections = new PharmacistsConnections();
      pharmacistsConnections.setPharmacist(pharmacist);
      pharmacistsConnections.setUser(getLoggedInUser());
      pharmacistsConnectionsRepository.save(pharmacistsConnections);
    }
  }

  @Override
  public List<UserDisplayDTO> getAllUserConnections()
  {
    List<PharmacistsConnections> pharmacistsConnectionsList = pharmacistsConnectionsRepository.findByUserAndState(getLoggedInUser(), StateEnum.READY_TO_CONNECT);

    return pharmacistsConnectionsList.stream().map(pharmacistsConnection -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(pharmacistsConnection.getPharmacist().getUser());
      userDisplayDTO.setPharmacist(phMapper.getPharmacistDTO(pharmacistsConnection.getPharmacist()));
      return userDisplayDTO;
    }).collect(Collectors.toList());
  }

  @Override
  public void updateState(PHUserConnectionDTO userConnectionDTO)
  {
    PharmacistsConnections pharmacistsConnections = pharmacistsConnectionsRepository.findById(userConnectionDTO.getId()).get();
    pharmacistsConnections.setState(userConnectionDTO.getState());
    pharmacistsConnectionsRepository.save(pharmacistsConnections);
  }

  @Override
  public void updateNotes(PHUserConnectionDTO userConnectionDTO)
  {
    PharmacistsConnections pharmacistsConnections = pharmacistsConnectionsRepository.findById(userConnectionDTO.getId()).get();
    pharmacistsConnections.setNotes(userConnectionDTO.getNotes());
    pharmacistsConnectionsRepository.save(pharmacistsConnections);
  }

  @Override
  public void disconnectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    Pharmacist pharmacist = phMapper.getPharmacist((PharmacistDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<PharmacistsConnections> pharmacistsConnectionsList = pharmacistsConnectionsRepository.findByUserAndPharmacistAndState(getLoggedInUser(), pharmacist, StateEnum.READY_TO_CONNECT);

    PharmacistsConnections pharmacistsConnection = pharmacistsConnectionsList.stream().findFirst().get();
    pharmacistsConnection.setState(StateEnum.CLIENT_DISCONNECT);
    pharmacistsConnectionsRepository.save(pharmacistsConnection);
  }

  @Override
  public List getAllConnections()
  {
    List<PharmacistsConnections> pharmacistsConnectionsList = pharmacistsConnectionsRepository.findAll();

    return pharmacistsConnectionsList.stream().map(pharmacistsConnection -> {
      ConnectionDisplayDTO connectionDisplayDTO = phMapper.getConnectionDisplayDTO(pharmacistsConnection);

      connectionDisplayDTO.getUser().setPharmacist(null);
      connectionDisplayDTO.getUser().setSalesman(null);
      connectionDisplayDTO.getUser().setPharmacyManager(null);
      connectionDisplayDTO.getUser().setProprietor(null);
      
      if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACIST.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacist(
                phMapper.getPharmacistDTO(
                        pharmacistRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }
      
      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PROPRIETOR.getUserEnum())){
        connectionDisplayDTO.getUser().setProprietor(
                phMapper.getProprietorDTO(
                        proprietorRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }
      
      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.SALESMAN.getUserEnum())){
        connectionDisplayDTO.getUser().setSalesman(
                phMapper.getSalesmanDTO(
                        salesmanRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }
      
      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACY_MANAGER.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacyManager(
                phMapper.getPharmacyManagerDTO(
                        pharmacyManagerRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }
      
      return connectionDisplayDTO;
    }).collect(Collectors.toList());
  
  }

  public Pharmacist getPharmacist() {
    return pharmacistRepository.findByUser(getLoggedInUser());
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/PharmacyManagerService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.constants.UserEnum;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.PharmacyManagerDTO;
import com.pharmacyhub.dto.display.ConnectionDisplayDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.engine.PHEngine;
import com.pharmacyhub.engine.PHMapper;
import com.pharmacyhub.entity.PharmacyManager;
import com.pharmacyhub.entity.connections.PharmacyManagerConnections;
import com.pharmacyhub.repository.PharmacistRepository;
import com.pharmacyhub.repository.PharmacyManagerRepository;
import com.pharmacyhub.repository.ProprietorRepository;
import com.pharmacyhub.repository.SalesmanRepository;
import com.pharmacyhub.repository.connections.PharmacyManagerConnectionsRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
public class PharmacyManagerService extends PHEngine implements PHUserService
{
  private final Logger log = LoggerFactory.getLogger(PharmacistService.class);

  @Autowired
  private PharmacistRepository pharmacistRepository;
  @Autowired
  private SalesmanRepository salesmanRepository;
  @Autowired
  private ProprietorRepository proprietorRepository;
  @Autowired
  private PharmacyManagerRepository pharmacyManagerRepository;

  @Autowired
  private PharmacyManagerConnectionsRepository pharmacyManagerConnectionsRepository;
  @Autowired
  private PHMapper phMapper;


  @Override
  public PHUserDTO saveUser(PHUserDTO pharmacyManagerDTO)
  {
    PharmacyManager PharmacyManager = phMapper.getPharmacyManager((PharmacyManagerDTO) pharmacyManagerDTO);
    getLoggedInUser().setRegistered(true);
    getLoggedInUser().setUserType(com.pharmacyhub.entity.enums.UserType.PHARMACY_MANAGER);
    PharmacyManager.setUser(getLoggedInUser());
    PharmacyManager savedPharmacyManager = pharmacyManagerRepository.save(PharmacyManager);
    return phMapper.getPharmacyManagerDTO(savedPharmacyManager);
  }

  @Override
  public PHUserDTO updateUser(PHUserDTO pharmacyManagerDTO)
  {
    PharmacyManager PharmacyManager = phMapper.getPharmacyManager((PharmacyManagerDTO) pharmacyManagerDTO);
    PharmacyManager.setUser(getLoggedInUser());
    PharmacyManager savedPharmacyManager = pharmacyManagerRepository.save(PharmacyManager);
    return phMapper.getPharmacyManagerDTO(savedPharmacyManager);
  }

  @Override
  public PHUserDTO findUser(long id)
  {
    Optional<PharmacyManager> pharmacyManager = pharmacyManagerRepository.findById(id);
    return phMapper.getPharmacyManagerDTO(pharmacyManager.get());
  }

  @Override
  public List<UserDisplayDTO> findAllUsers()
  {
    return pharmacyManagerRepository.findAll().stream().map(pharmacyManager -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(pharmacyManager.getUser());
      userDisplayDTO.setPharmacyManager(phMapper.getPharmacyManagerDTO(pharmacyManager));
      userDisplayDTO.setConnected(getAllUserConnections().stream().anyMatch(userDisplayDTO1 -> {
        return userDisplayDTO1.getPharmacyManager().getId().equals(pharmacyManager.getId());
      }));

      return userDisplayDTO;
    }).collect(Collectors.toList());
  }

  @Override
  public void connectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    PharmacyManager pharmacyManager = phMapper.getPharmacyManager((PharmacyManagerDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<PharmacyManagerConnections> pharmacyManagerConnectionsList = pharmacyManagerConnectionsRepository.findByUserAndPharmacyManagerAndState(getLoggedInUser(), pharmacyManager, StateEnum.READY_TO_CONNECT);

    if (pharmacyManagerConnectionsList.isEmpty())
    {
      PharmacyManagerConnections pharmacyManagerConnections = new PharmacyManagerConnections();
      pharmacyManagerConnections.setPharmacyManager(pharmacyManager);
      pharmacyManagerConnections.setUser(getLoggedInUser());
      pharmacyManagerConnectionsRepository.save(pharmacyManagerConnections);
    }
  }

  @Override
  public List<UserDisplayDTO> getAllUserConnections()
  {
    List<PharmacyManagerConnections> pharmacyManagerConnectionsList = pharmacyManagerConnectionsRepository.findByUserAndState(getLoggedInUser(), StateEnum.READY_TO_CONNECT);

    return pharmacyManagerConnectionsList.stream().map(pharmacyManagerConnection -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(pharmacyManagerConnection.getPharmacyManager().getUser());
      userDisplayDTO.setPharmacyManager(phMapper.getPharmacyManagerDTO(pharmacyManagerConnection.getPharmacyManager()));
      return userDisplayDTO;
    }).collect(Collectors.toList());

  }

  @Override
  public void updateState(PHUserConnectionDTO userConnectionDTO)
  {
    PharmacyManagerConnections pharmacyManagerConnections = pharmacyManagerConnectionsRepository.findById(userConnectionDTO.getId()).get();
    pharmacyManagerConnections.setState(userConnectionDTO.getState());
    pharmacyManagerConnectionsRepository.save(pharmacyManagerConnections);
  }

  @Override
  public void updateNotes(PHUserConnectionDTO userConnectionDTO)
  {
    PharmacyManagerConnections pharmacyManagerConnections = pharmacyManagerConnectionsRepository.findById(userConnectionDTO.getId()).get();
    pharmacyManagerConnections.setNotes(userConnectionDTO.getNotes());
    pharmacyManagerConnectionsRepository.save(pharmacyManagerConnections);
  }

  @Override
  public List getAllConnections()
  {
    List<PharmacyManagerConnections> pharmacyManagerConnections = pharmacyManagerConnectionsRepository.findAll();

    return pharmacyManagerConnections.stream().map(pharmacistsConnection -> {
      ConnectionDisplayDTO connectionDisplayDTO = phMapper.getConnectionDisplayDTO(pharmacistsConnection);

      connectionDisplayDTO.getUser().setPharmacist(null);
      connectionDisplayDTO.getUser().setSalesman(null);
      connectionDisplayDTO.getUser().setPharmacyManager(null);
      connectionDisplayDTO.getUser().setProprietor(null);
      
      if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACIST.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacist(
                phMapper.getPharmacistDTO(
                        pharmacistRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PROPRIETOR.getUserEnum())){
        connectionDisplayDTO.getUser().setProprietor(
                phMapper.getProprietorDTO(
                        proprietorRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.SALESMAN.getUserEnum())){
        connectionDisplayDTO.getUser().setSalesman(
                phMapper.getSalesmanDTO(
                        salesmanRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACY_MANAGER.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacyManager(
                phMapper.getPharmacyManagerDTO(
                        pharmacyManagerRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      return connectionDisplayDTO;
    }).collect(Collectors.toList());


  }

  @Override
  public void disconnectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    PharmacyManager pharmacyManager = phMapper.getPharmacyManager((PharmacyManagerDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<PharmacyManagerConnections> pharmacyManagerConnectionsList = pharmacyManagerConnectionsRepository.findByUserAndPharmacyManagerAndState(getLoggedInUser(), pharmacyManager, StateEnum.READY_TO_CONNECT);

    PharmacyManagerConnections pharmacyManagerConnection = pharmacyManagerConnectionsList.stream().findFirst().get();
    pharmacyManagerConnection.setState(StateEnum.CLIENT_DISCONNECT);
    pharmacyManagerConnectionsRepository.save(pharmacyManagerConnection);
  }

  public PharmacyManager getPharmacyManager() {
    return pharmacyManagerRepository.findByUser(getLoggedInUser());
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/PHUserService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;

import java.util.List;

public interface PHUserService
{
  PHUserDTO saveUser(PHUserDTO phUserDTO);

  PHUserDTO updateUser(PHUserDTO phUserDTO);

  PHUserDTO findUser(long id);

  List<UserDisplayDTO> findAllUsers();

  void connectWith(PHUserConnectionDTO phUserConnectionDTO);

  void disconnectWith(PHUserConnectionDTO phUserConnectionDTO);

  List<UserDisplayDTO> getAllUserConnections();

  void updateState(PHUserConnectionDTO userConnectionDTO);

  void updateNotes(PHUserConnectionDTO userConnectionDTO);

  List getAllConnections();
}
</file>

<file path="src/main/java/com/pharmacyhub/service/ProprietorService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.constants.UserEnum;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.ProprietorDTO;
import com.pharmacyhub.dto.display.ConnectionDisplayDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.engine.PHEngine;
import com.pharmacyhub.engine.PHMapper;
import com.pharmacyhub.entity.Proprietor;
import com.pharmacyhub.entity.connections.ProprietorsConnections;
import com.pharmacyhub.repository.PharmacistRepository;
import com.pharmacyhub.repository.PharmacyManagerRepository;
import com.pharmacyhub.repository.ProprietorRepository;
import com.pharmacyhub.repository.SalesmanRepository;
import com.pharmacyhub.repository.connections.ProprietorsConnectionsRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Service Implementation for managing {@link Proprietor}.
 */
@Service
public class ProprietorService extends PHEngine implements PHUserService
{
  private final Logger log = LoggerFactory.getLogger(ProprietorService.class);
  @Autowired
  private ProprietorsConnectionsRepository proprietorsConnectionsRepository;
  
  @Autowired
  private PharmacistRepository pharmacistRepository;
  @Autowired
  private SalesmanRepository salesmanRepository;
  @Autowired
  private ProprietorRepository proprietorRepository;
  @Autowired
  private PharmacyManagerRepository pharmacyManagerRepository;

  @Autowired
  private PHMapper phMapper;


  @Override
  public PHUserDTO saveUser(PHUserDTO proprietorDTO)
  {
    Proprietor proprietor = phMapper.getProprietor((ProprietorDTO) proprietorDTO);
    getLoggedInUser().setRegistered(true);
    proprietor.setUser(getLoggedInUser());
    getLoggedInUser().setUserType(com.pharmacyhub.entity.enums.UserType.PROPRIETOR);
    Proprietor savedProprietor = proprietorRepository.save(proprietor);
    return phMapper.getProprietorDTO(savedProprietor);
  }

  @Override
  public PHUserDTO updateUser(PHUserDTO proprietorDTO)
  {
    Proprietor proprietor = phMapper.getProprietor((ProprietorDTO) proprietorDTO);
    proprietor.setUser(getLoggedInUser());
    Proprietor savedProprietor = proprietorRepository.save(proprietor);
    return phMapper.getProprietorDTO(savedProprietor);
  }

  @Override
  public PHUserDTO findUser(long id)
  {
    Optional<Proprietor> proprietor = proprietorRepository.findById(id);
    return phMapper.getProprietorDTO(proprietor.get());
  }

  @Override
  public List<UserDisplayDTO> findAllUsers()
  {
    return proprietorRepository.findAll().stream().map(proprietor -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(proprietor.getUser());
      userDisplayDTO.setProprietor(phMapper.getProprietorDTO(proprietor));

      userDisplayDTO.setConnected(getAllUserConnections().stream().anyMatch(userDisplayDTO1 -> {
       return userDisplayDTO1.getProprietor().getId().equals(proprietor.getId());
      }));

      return userDisplayDTO;
    }).collect(Collectors.toList());
  }

  @Override
  public void connectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    Proprietor proprietor = phMapper.getProprietor((ProprietorDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<ProprietorsConnections> proprietorConnectionsList = proprietorsConnectionsRepository.findByUserAndProprietorAndState(getLoggedInUser(), proprietor, StateEnum.READY_TO_CONNECT);

    if (proprietorConnectionsList.isEmpty())
    {
      ProprietorsConnections proprietorConnections = new ProprietorsConnections();
      proprietorConnections.setProprietor(proprietor);
      proprietorConnections.setUser(getLoggedInUser());
      proprietorsConnectionsRepository.save(proprietorConnections);
    }
  }

  @Override
  public List<UserDisplayDTO> getAllUserConnections()
  {
    List<ProprietorsConnections> proprietorConnectionsList = proprietorsConnectionsRepository.findByUserAndState(getLoggedInUser(), StateEnum.READY_TO_CONNECT);

    return proprietorConnectionsList.stream().map(proprietorConnection -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(proprietorConnection.getProprietor().getUser());
      userDisplayDTO.setProprietor(phMapper.getProprietorDTO(proprietorConnection.getProprietor()));
      return userDisplayDTO;
    }).collect(Collectors.toList());

  }

  @Override
  public void updateState(PHUserConnectionDTO userConnectionDTO)
  {
    ProprietorsConnections proprietorsConnections = proprietorsConnectionsRepository.findById(userConnectionDTO.getId()).get();
    proprietorsConnections.setState(userConnectionDTO.getState());
    proprietorsConnectionsRepository.save(proprietorsConnections);
  }

  @Override
  public List getAllConnections()
  {
    List<ProprietorsConnections> proprietorsConnections = proprietorsConnectionsRepository.findAll();

    return proprietorsConnections.stream().map(pharmacistsConnection -> {
      ConnectionDisplayDTO connectionDisplayDTO = phMapper.getConnectionDisplayDTO(pharmacistsConnection);

      connectionDisplayDTO.getUser().setPharmacist(null);
      connectionDisplayDTO.getUser().setSalesman(null);
      connectionDisplayDTO.getUser().setPharmacyManager(null);
      connectionDisplayDTO.getUser().setProprietor(null);
      
      if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACIST.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacist(
                phMapper.getPharmacistDTO(
                        pharmacistRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PROPRIETOR.getUserEnum())){
        connectionDisplayDTO.getUser().setProprietor(
                phMapper.getProprietorDTO(
                        proprietorRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.SALESMAN.getUserEnum())){
        connectionDisplayDTO.getUser().setSalesman(
                phMapper.getSalesmanDTO(
                        salesmanRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACY_MANAGER.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacyManager(
                phMapper.getPharmacyManagerDTO(
                        pharmacyManagerRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      return connectionDisplayDTO;
    }).collect(Collectors.toList());


  }

  @Override
  public void updateNotes(PHUserConnectionDTO userConnectionDTO)
  {
    ProprietorsConnections proprietorsConnections = proprietorsConnectionsRepository.findById(userConnectionDTO.getId()).get();
    proprietorsConnections.setNotes(userConnectionDTO.getNotes());
    proprietorsConnectionsRepository.save(proprietorsConnections);
  }

  @Override
  public void disconnectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    Proprietor proprietor = phMapper.getProprietor((ProprietorDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<ProprietorsConnections> proprietorConnectionsList = proprietorsConnectionsRepository.findByUserAndProprietorAndState(getLoggedInUser(), proprietor, StateEnum.READY_TO_CONNECT);

    ProprietorsConnections proprietorConnection = proprietorConnectionsList.stream().findFirst().get();
    proprietorConnection.setState(StateEnum.CLIENT_DISCONNECT);
    proprietorsConnectionsRepository.save(proprietorConnection);
  }

  public Proprietor getProprietor() {
    return proprietorRepository.findByUser(getLoggedInUser());
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/QuestionService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.Question;

import java.util.List;
import java.util.Optional;

public interface QuestionService {
    /**
     * Get all questions for an exam
     */
    List<Question> getQuestionsByExamId(Long examId);
    
    /**
     * Find a question by ID
     */
    Optional<Question> getQuestionById(Long id);
    
    /**
     * Find a question by ID (aliased method)
     */
    Optional<Question> findById(Long id);
    
    /**
     * Find all questions for an exam
     */
    List<Question> findByExamId(Long examId);
    
    /**
     * Find questions by topic
     */
    List<Question> findByTopic(String topic);
    
    /**
     * Find questions by difficulty level
     */
    List<Question> findByDifficulty(String difficulty);
    
    /**
     * Find random questions with optional filters
     */
    List<Question> findRandom(int count, String topic, String difficulty);
    
    /**
     * Create a new question
     */
    Question createQuestion(Question question);
    
    /**
     * Update an existing question
     */
    Question updateQuestion(Long id, Question question);
    
    /**
     * Delete a question
     */
    void deleteQuestion(Long id);
    
    /**
     * Get the highest question number for an exam
     */
    Integer getMaxQuestionNumberByExamId(Long examId);
    
    /**
     * Count questions for an exam
     */
    Long countQuestionsByExamId(Long examId);
}
</file>

<file path="src/main/java/com/pharmacyhub/service/QuestionServiceImpl.java">
package com.pharmacyhub.service;

import com.pharmacyhub.domain.entity.Question;
import com.pharmacyhub.domain.repository.QuestionRepository;
import jakarta.persistence.EntityNotFoundException;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

@Service
@Transactional
public class QuestionServiceImpl implements QuestionService {
    
    private final QuestionRepository questionRepository;

    public QuestionServiceImpl(QuestionRepository questionRepository) {
        this.questionRepository = questionRepository;
    }

    @Override
    @Transactional(readOnly = true)
    public List<Question> getQuestionsByExamId(Long examId) {
        return questionRepository.findByExamId(examId);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<Question> getQuestionById(Long id) {
        return questionRepository.findByIdAndNotDeleted(id);
    }
    
    @Override
    @Transactional(readOnly = true)
    public Optional<Question> findById(Long id) {
        return questionRepository.findByIdAndNotDeleted(id);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Question> findByExamId(Long examId) {
        return questionRepository.findByExamId(examId);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Question> findByTopic(String topic) {
        return questionRepository.findByTopic(topic);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Question> findByDifficulty(String difficulty) {
        return questionRepository.findByDifficulty(difficulty);
    }
    
    @Override
    @Transactional(readOnly = true)
    public List<Question> findRandom(int count, String topic, String difficulty) {
        return questionRepository.findRandom(count, topic, difficulty);
    }

    @Override
    public Question createQuestion(Question question) {
        return questionRepository.save(question);
    }

    @Override
    @Transactional
    public Question updateQuestion(Long id, Question questionDetails) {
        // 1. Find the existing question
        Question question = questionRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new EntityNotFoundException("Question not found with id: " + id));

        // 2. Update basic question properties
        if (questionDetails.getQuestionText() != null) {
            question.setQuestionText(questionDetails.getQuestionText());
        }
        if (questionDetails.getCorrectAnswer() != null) {
            question.setCorrectAnswer(questionDetails.getCorrectAnswer());
        }
        if (questionDetails.getExplanation() != null) {
            question.setExplanation(questionDetails.getExplanation());
        }
        if (questionDetails.getMarks() != null) {
            question.setMarks(questionDetails.getMarks());
        }
        if (questionDetails.getType() != null) {
            question.setType(questionDetails.getType());
        }
        if (questionDetails.getTopic() != null) {
            question.setTopic(questionDetails.getTopic());
        }
        if (questionDetails.getDifficulty() != null) {
            question.setDifficulty(questionDetails.getDifficulty());
        }
        
        // 3. Update options if provided
        if (questionDetails.getOptions() != null && !questionDetails.getOptions().isEmpty()) {
            // Update existing options
            questionDetails.getOptions().forEach(updatedOption -> {
                // If the option has an ID, it's an existing option to update
                if (updatedOption.getId() != null) {
                    question.getOptions().stream()
                        .filter(o -> o.getId().equals(updatedOption.getId()))
                        .findFirst()
                        .ifPresent(existingOption -> {
                            // Update option text if provided
                            if (updatedOption.getText() != null) {
                                existingOption.setText(updatedOption.getText());
                            }
                            
                            // Update option label if provided
                            if (updatedOption.getLabel() != null) {
                                existingOption.setLabel(updatedOption.getLabel());
                            }
                        });
                }
            });
            
            // 4. Mark all options as correct/incorrect based on correctAnswer
            if (question.getCorrectAnswer() != null) {
                question.getOptions().forEach(option -> {
                    option.setIsCorrect(question.getCorrectAnswer().equals(option.getLabel()));
                });
            }
        }

        // 5. Save and return the updated question
        return questionRepository.save(question);
    }

    @Override
    public void deleteQuestion(Long id) {
        Question question = questionRepository.findByIdAndNotDeleted(id)
                .orElseThrow(() -> new EntityNotFoundException("Question not found with id: " + id));
        question.setDeleted(true);
        questionRepository.save(question);
    }

    @Override
    @Transactional(readOnly = true)
    public Integer getMaxQuestionNumberByExamId(Long examId) {
        return questionRepository.findMaxQuestionNumberByExamId(examId);
    }

    @Override
    @Transactional(readOnly = true)
    public Long countQuestionsByExamId(Long examId) {
        return questionRepository.countByExamId(examId);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/SalesmanService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.constants.StateEnum;
import com.pharmacyhub.constants.UserEnum;
import com.pharmacyhub.dto.PHUserConnectionDTO;
import com.pharmacyhub.dto.PHUserDTO;
import com.pharmacyhub.dto.SalesmanDTO;
import com.pharmacyhub.dto.display.ConnectionDisplayDTO;
import com.pharmacyhub.dto.display.UserDisplayDTO;
import com.pharmacyhub.engine.PHEngine;
import com.pharmacyhub.engine.PHMapper;
import com.pharmacyhub.entity.Salesman;
import com.pharmacyhub.entity.connections.SalesmenConnections;
import com.pharmacyhub.repository.PharmacistRepository;
import com.pharmacyhub.repository.PharmacyManagerRepository;
import com.pharmacyhub.repository.ProprietorRepository;
import com.pharmacyhub.repository.SalesmanRepository;
import com.pharmacyhub.repository.connections.SalesmenConnectionsRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Transactional
public class SalesmanService extends PHEngine implements PHUserService
{
  private final Logger log = LoggerFactory.getLogger(PharmacistService.class);

  @Autowired
  private PharmacistRepository pharmacistRepository;
  @Autowired
  private SalesmanRepository salesmanRepository;
  @Autowired
  private ProprietorRepository proprietorRepository;
  @Autowired
  private PharmacyManagerRepository pharmacyManagerRepository;
  
  @Autowired
  private SalesmenConnectionsRepository salesmenConnectionsRepository;

  @Autowired
  private PHMapper phMapper;

  @Override
  public PHUserDTO saveUser(PHUserDTO salesmanDTO)
  {
    Salesman salesman = phMapper.getSalesman((SalesmanDTO) salesmanDTO);
    getLoggedInUser().setRegistered(true);
    salesman.setUser(getLoggedInUser());
    getLoggedInUser().setUserType(com.pharmacyhub.entity.enums.UserType.SALESMAN);
    Salesman savedSalesman = salesmanRepository.save(salesman);
    return phMapper.getSalesmanDTO(savedSalesman);
  }

  @Override
  public PHUserDTO updateUser(PHUserDTO salesmanDTO)
  {
    Salesman salesman = phMapper.getSalesman((SalesmanDTO) salesmanDTO);
    salesman.setUser(getLoggedInUser());
    Salesman savedSalesman = salesmanRepository.save(salesman);
    return phMapper.getSalesmanDTO(savedSalesman);
  }

  @Override
  public PHUserDTO findUser(long id)
  {
    Optional<Salesman> salesman = salesmanRepository.findById(id);
    return phMapper.getSalesmanDTO(salesman.get());
  }

  @Override
  public List<UserDisplayDTO> findAllUsers()
  {
    return salesmanRepository.findAll().stream().map(salesman -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(salesman.getUser());
      userDisplayDTO.setSalesman(phMapper.getSalesmanDTO(salesman));

      userDisplayDTO.setConnected(getAllUserConnections().stream().anyMatch(userDisplayDTO1 -> {
        return userDisplayDTO1.getSalesman().getId().equals(salesman.getId());
      }));

      return userDisplayDTO;
    }).collect(Collectors.toList());
  }

  @Override
  public void connectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    Salesman salesman = phMapper.getSalesman((SalesmanDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<SalesmenConnections> salesmanConnectionsList = salesmenConnectionsRepository.findByUserAndSalesmanAndState(getLoggedInUser(), salesman, StateEnum.READY_TO_CONNECT);

    if (salesmanConnectionsList.isEmpty())
    {
      SalesmenConnections salesmanConnections = new SalesmenConnections();
      salesmanConnections.setSalesman(salesman);
      salesmanConnections.setUser(getLoggedInUser());
      salesmenConnectionsRepository.save(salesmanConnections);
    }
  }

  @Override
  public List<UserDisplayDTO> getAllUserConnections()
  {
    List<SalesmenConnections> salesmanConnectionsList = salesmenConnectionsRepository.findByUserAndState(getLoggedInUser(), StateEnum.READY_TO_CONNECT);

    return salesmanConnectionsList.stream().map(salesmanConnection -> {
      UserDisplayDTO userDisplayDTO = phMapper.getUserDisplayDTO(salesmanConnection.getSalesman().getUser());
      userDisplayDTO.setSalesman(phMapper.getSalesmanDTO(salesmanConnection.getSalesman()));
      return userDisplayDTO;
    }).collect(Collectors.toList());

  }

  @Override
  public List getAllConnections()
  {
    List<SalesmenConnections> salesmenConnections = salesmenConnectionsRepository.findAll();

    return salesmenConnections.stream().map(pharmacistsConnection -> {
      ConnectionDisplayDTO connectionDisplayDTO = phMapper.getConnectionDisplayDTO(pharmacistsConnection);

      connectionDisplayDTO.getUser().setPharmacist(null);
      connectionDisplayDTO.getUser().setSalesman(null);
      connectionDisplayDTO.getUser().setPharmacyManager(null);
      connectionDisplayDTO.getUser().setProprietor(null);
      
      if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACIST.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacist(
                phMapper.getPharmacistDTO(
                        pharmacistRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PROPRIETOR.getUserEnum())){
        connectionDisplayDTO.getUser().setProprietor(
                phMapper.getProprietorDTO(
                        proprietorRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.SALESMAN.getUserEnum())){
        connectionDisplayDTO.getUser().setSalesman(
                phMapper.getSalesmanDTO(
                        salesmanRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      else if(connectionDisplayDTO.getUser().getUserType().equals(UserEnum.PHARMACY_MANAGER.getUserEnum())){
        connectionDisplayDTO.getUser().setPharmacyManager(
                phMapper.getPharmacyManagerDTO(
                        pharmacyManagerRepository.findByUser(
                                phMapper.getUser(connectionDisplayDTO.getUser())
                        )
                )
        );
      }

      return connectionDisplayDTO;
    }).collect(Collectors.toList());


  }

  @Override
  public void updateState(PHUserConnectionDTO userConnectionDTO)
  {
    SalesmenConnections salesmenConnections = salesmenConnectionsRepository.findById(userConnectionDTO.getId()).get();
    salesmenConnections.setState(userConnectionDTO.getState());
    salesmenConnectionsRepository.save(salesmenConnections);
  }

  @Override
  public void updateNotes(PHUserConnectionDTO userConnectionDTO)
  {
    SalesmenConnections salesmenConnections = salesmenConnectionsRepository.findById(userConnectionDTO.getId()).get();
    salesmenConnections.setNotes(userConnectionDTO.getNotes());
    salesmenConnectionsRepository.save(salesmenConnections);
  }

  @Override
  public void disconnectWith(PHUserConnectionDTO phUserConnectionDTO)
  {
    Salesman salesman = phMapper.getSalesman((SalesmanDTO) findUser(phUserConnectionDTO.getConnectWith()));
    List<SalesmenConnections> salesmanConnectionsList = salesmenConnectionsRepository.findByUserAndSalesmanAndState(getLoggedInUser(), salesman, StateEnum.READY_TO_CONNECT);

    SalesmenConnections salesmanConnection = salesmanConnectionsList.stream().findFirst().get();
    salesmanConnection.setState(StateEnum.CLIENT_DISCONNECT);
    salesmenConnectionsRepository.save(salesmanConnection);
  }
  
  public Salesman getSalesman(){
    return salesmanRepository.findByUser(getLoggedInUser());
  }
}
</file>

<file path="src/main/java/com/pharmacyhub/service/UserService.java">
package com.pharmacyhub.service;

import com.pharmacyhub.entity.User;
import com.pharmacyhub.repository.UserRepository;
import com.pharmacyhub.security.domain.Role;
import com.pharmacyhub.security.infrastructure.RolesRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;
import com.pharmacyhub.dto.UserDTO;
import com.pharmacyhub.dto.PHUserDTO;
import java.util.Optional;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.context.SecurityContextHolder;
import com.pharmacyhub.entity.enums.UserType;
import org.springframework.security.core.Authentication;
import org.springframework.security.crypto.password.PasswordEncoder;
import com.pharmacyhub.dto.ChangePasswordDTO;
import com.pharmacyhub.constants.RoleEnum;

@Service
@RequiredArgsConstructor
public class UserService {
    private final RolesRepository rolesRepository;
    private final UserRepository userRepository;
    private final PasswordEncoder passwordEncoder;

    public List<Role> getSystemRoles() {
        return rolesRepository.findBySystemTrue();
    }

    public List<Role> getAssignableRoles(String roleName, Long userId) {
        // Convert the roleName string to RoleEnum
        RoleEnum roleEnum = RoleEnum.fromString(roleName);
        
        Role role = rolesRepository.findByName(roleEnum)
                .orElseThrow(() -> new IllegalArgumentException("Role not found: " + roleName));

        User user = userRepository.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));

        List<Role> userRoles = user.getRoles().stream().toList();

        return rolesRepository.findByPrecedenceLessThanEqual(role.getPrecedence())
                .stream()
                .filter(r -> !userRoles.contains(r))
                .collect(Collectors.toList());
    }

    public PHUserDTO saveUser(UserDTO userDTO) {
        // Check if user already exists
        Optional<User> existingUser = userRepository.findByEmailAddress(userDTO.getEmailAddress());
        if (existingUser.isPresent()) {
            return null;
        }

        // Create new user
        User user = new User();
        user.setEmailAddress(userDTO.getEmailAddress());
        user.setPassword(passwordEncoder.encode(userDTO.getPassword()));
        user.setFirstName(userDTO.getFirstName());
        user.setLastName(userDTO.getLastName());
        user.setVerificationToken(java.util.UUID.randomUUID().toString());
        user.setVerified(false);
        user.setActive(true);
        user.setRegistered(true);
        user.setAccountNonLocked(true);
        user.setOpenToConnect(true);

        // Save user
        user = userRepository.save(user);

        // Convert to DTO and return
        return UserDTO.builder()
            .id(user.getId())
            .emailAddress(user.getEmailAddress())
            .firstName(user.getFirstName())
            .lastName(user.getLastName())
            .contactNumber(user.getContactNumber())
            .openToConnect(user.isOpenToConnect())
            .registered(user.isRegistered())
            .build();
    }

    public boolean verifyUser(String token) {
        Optional<User> userOptional = userRepository.findByVerificationToken(token);
        if (userOptional.isPresent()) {
            User user = userOptional.get();
            user.setVerified(true);
            user.setVerificationToken(null);
            userRepository.save(user);
            return true;
        }
        return false;
    }

    public List<User> getUsers() {
        // Implementation for getting all users
        return userRepository.findAll(); // Replace with actual implementation
    }

     public UserType getUserType(Long userId) {
         User user = userRepository.findById(userId)
                 .orElseThrow(() -> new IllegalArgumentException("User not found: " + userId));
        return user.getUserType();
    }

    public User getUserByEmailAddress(UserDTO userDTO) {
        Optional<User> userOptional = userRepository.findByEmailAddress(userDTO.getEmailAddress());
        return userOptional.orElse(null);
    }

    public boolean forgotPassword(UserDTO userDTO) {
         Optional<User> userOptional = userRepository.findByEmailAddress(userDTO.getEmailAddress());
         if (userOptional.isPresent()) {
             User user = userOptional.get();
             user.setPassword(passwordEncoder.encode(userDTO.getPassword()));
             userRepository.save(user);
             return true;
         }
         return false;
    }

    public PHUserDTO changeUserPassword(ChangePasswordDTO changePasswordDTO) {
        // Implementation for changing user password
        User currentUser = getLoggedInUser();
        if (currentUser != null && passwordEncoder.matches(changePasswordDTO.getCurrentPassword(), currentUser.getPassword())) {
            currentUser.setPassword(passwordEncoder.encode(changePasswordDTO.getNewPassword()));
            userRepository.save(currentUser);
            return UserDTO.builder()
                .id(currentUser.getId())
                .emailAddress(currentUser.getEmailAddress())
                .firstName(currentUser.getFirstName())
                .lastName(currentUser.getLastName())
                .contactNumber(currentUser.getContactNumber())
                .openToConnect(currentUser.isOpenToConnect())
                .registered(currentUser.isRegistered())
                .build();
        }
        return null; 
    }

    public PHUserDTO editUserInformation(UserDTO userDTO) {
        User currentUser = getLoggedInUser();
        if (currentUser != null) {
            currentUser.setFirstName(userDTO.getFirstName());
            currentUser.setLastName(userDTO.getLastName());
            // Only update if provided
            if (userDTO.getContactNumber() != null) {
                currentUser.setContactNumber(userDTO.getContactNumber());
            }
            userRepository.save(currentUser);
            return UserDTO.builder()
                .id(currentUser.getId())
                .emailAddress(currentUser.getEmailAddress())
                .firstName(currentUser.getFirstName())
                .lastName(currentUser.getLastName())
                .contactNumber(currentUser.getContactNumber())
                .openToConnect(currentUser.isOpenToConnect())
                .registered(currentUser.isRegistered())
                .build();
        }
        return null; 
    }

    public List<User> findAll() {
        return userRepository.findAll();
    }

    public PHUserDTO getUserCompleteInformation() {
        User currentUser = getLoggedInUser();
        if (currentUser != null) {
            return UserDTO.builder()
                .id(currentUser.getId())
                .emailAddress(currentUser.getEmailAddress())
                .firstName(currentUser.getFirstName())
                .lastName(currentUser.getLastName())
                .contactNumber(currentUser.getContactNumber())
                .openToConnect(currentUser.isOpenToConnect())
                .registered(currentUser.isRegistered())
                .build();
        }
        return null;
 
    }

    public boolean updateUserStatus() {
        User currentUser = getLoggedInUser();
        if (currentUser != null) {
            currentUser.setOpenToConnect(!currentUser.isOpenToConnect());
            userRepository.save(currentUser);
            return true;
        }
        return false;
    }

    public User getLoggedInUser() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication == null) {
            return null;
        }
        
        Object principal = authentication.getPrincipal();
        String email = (principal instanceof UserDetails) ? ((UserDetails) principal).getUsername() : 
                      (principal instanceof User) ? ((User) principal).getEmailAddress() : principal.toString();
        Optional<User> userOptional = userRepository.findByEmailAddress(email);
 
        return userOptional.orElse(null);
    }
    
    public User findById(Long userId) {
        return userRepository.findById(userId).orElse(null);
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/utils/EntityMapper.java">
package com.pharmacyhub.utils;

import org.modelmapper.ModelMapper;
import org.modelmapper.convention.MatchingStrategies;
import org.springframework.stereotype.Component;

import java.util.Collection;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Centralized mapper for converting between entities and DTOs
 * Uses ModelMapper for consistent mapping across the application
 */
@Component
public class EntityMapper {
    private final ModelMapper modelMapper;
    
    public EntityMapper() {
        this.modelMapper = new ModelMapper();
        configureMapper();
    }
    
    /**
     * Configure the model mapper with custom settings and type mappings
     */
    private void configureMapper() {
        modelMapper.getConfiguration()
                .setMatchingStrategy(MatchingStrategies.STRICT)
                .setSkipNullEnabled(true)
                .setFieldMatchingEnabled(true)
                .setFieldAccessLevel(org.modelmapper.config.Configuration.AccessLevel.PRIVATE);
        
        // Add specific type mappings here
        // For example:
        // modelMapper.createTypeMap(Entity.class, DTO.class)
        //     .addMappings(mapper -> mapper.skip(DTO::setPassword));
    }
    
    /**
     * Convert an entity to a DTO
     */
    public <D, T> D map(final T entity, Class<D> dtoClass) {
        return modelMapper.map(entity, dtoClass);
    }
    
    /**
     * Convert a DTO to an entity
     */
    public <D, T> T mapToEntity(final D dto, Class<T> entityClass) {
        return modelMapper.map(dto, entityClass);
    }
    
    /**
     * Convert a collection of entities to a list of DTOs
     */
    public <D, T> List<D> mapList(final Collection<T> entityList, Class<D> dtoClass) {
        return entityList.stream()
                .map(entity -> map(entity, dtoClass))
                .collect(Collectors.toList());
    }
    
    /**
     * Map specific fields from the source object to the destination object
     */
    public void mapProperties(Object source, Object destination) {
        modelMapper.map(source, destination);
    }
    
    /**
     * Get the configured ModelMapper instance for custom mapping
     */
    public ModelMapper getModelMapper() {
        return modelMapper;
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/utils/LogUtils.java">
package com.pharmacyhub.utils;

import jakarta.servlet.http.HttpServletRequest;
import org.slf4j.Logger;
import org.slf4j.MDC;

import java.util.Optional;

/**
 * Utility class for logging with standardized formats
 */
public class LogUtils {
    
    /**
     * Private constructor to prevent instantiation
     */
    private LogUtils() {
        // Utility class, should not be instantiated
    }
    
    /**
     * Log an exception with detailed request information
     */
    public static void logException(Logger logger, HttpServletRequest request, Exception ex) {
        try {
            // Add context information to MDC for logging
            MDC.put("ip", request.getRemoteAddr());
            MDC.put("user", getUserInfo(request));
            MDC.put("method", request.getMethod());
            MDC.put("path", request.getRequestURI());
            MDC.put("userAgent", request.getHeader("User-Agent"));
            
            // Log the exception
            logger.error("Exception: {}, Message: {}", ex.getClass().getSimpleName(), ex.getMessage(), ex);
            
            // Clear MDC to prevent memory leaks
            MDC.clear();
        } catch (Exception e) {
            // Fallback logging in case something goes wrong with our logging
            logger.error("Exception during request processing: {}", ex.getMessage(), ex);
        }
    }
    
    /**
     * Log an access denied event with detailed request information
     */
    public static void logAccessDenied(Logger logger, HttpServletRequest request, String reason) {
        try {
            // Add context information to MDC for logging
            MDC.put("ip", request.getRemoteAddr());
            MDC.put("user", getUserInfo(request));
            MDC.put("method", request.getMethod());
            MDC.put("path", request.getRequestURI());
            MDC.put("userAgent", request.getHeader("User-Agent"));
            
            // Log the access denied event
            logger.warn("Access denied: {}", reason);
            
            // Clear MDC to prevent memory leaks
            MDC.clear();
        } catch (Exception e) {
            // Fallback logging in case something goes wrong with our logging
            logger.warn("Access denied during request processing: {}", reason);
        }
    }
    
    /**
     * Extract user information from the request
     */
    private static String getUserInfo(HttpServletRequest request) {
        return Optional.ofNullable(request.getUserPrincipal())
                .map(principal -> principal.getName())
                .orElse("anonymous");
    }
}
</file>

<file path="src/main/java/com/pharmacyhub/utils/SecurityUtils.java">
package com.pharmacyhub.utils;

import org.springframework.security.core.Authentication;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.stereotype.Component;

import java.util.Collections;
import java.util.Set;
import java.util.stream.Collectors;

@Component
public class SecurityUtils {

    /**
     * Get the current authenticated username
     * @return username or null if no authentication exists
     */
    public String getCurrentUsername() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            return null;
        }
        
        Object principal = authentication.getPrincipal();
        
        if (principal instanceof UserDetails) {
            return ((UserDetails) principal).getUsername();
        } else if (principal instanceof String) {
            return (String) principal;
        }
        else {
            return principal.toString();
        }
    }

    /**
     * Check if a user is authenticated
     * @return true if user is authenticated, false otherwise
     */
    public boolean isAuthenticated() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        return authentication != null && authentication.isAuthenticated() 
               && !"anonymousUser".equals(authentication.getPrincipal());
    }
    
    /**
     * Get the current authenticated user's authorities
     * @return Set of granted authority strings, or empty set if not authenticated
     */
    public Set<String> getCurrentUserAuthorities() {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        
        if (authentication == null || !authentication.isAuthenticated()) {
            return Collections.emptySet();
        }
        
        return authentication.getAuthorities()
            .stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.toSet());
    }
    
    /**
     * @deprecated Use getCurrentUsername() instead. This method is maintained for backward compatibility.
     * @return Always returns null as we've moved away from numeric IDs
     */
    @Deprecated
    public Long getCurrentUserId() {
        return null;
    }
}
</file>

<file path="src/main/resources/application.yml">
spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/pharmacyhub
    username: postgres
    password: postgres
    driver-class-name: org.postgresql.Driver
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false
    database-platform: org.hibernate.dialect.PostgreSQLDialect
    properties:
      hibernate:
        format_sql: true
  web:
    resources:
      static-locations: classpath:/META-INF/resources/,classpath:/resources/,classpath:/static/,classpath:/public/
  mail:
    username: syedus06@gmail.com
    password: lyce duoh tkeh uqtr
    host: smtp.gmail.com
    port: 587
    properties:
      mail:
        smtp:
          auth: true
          starttls:
            enable: true
  # Auto-create log directory
  application:
    name: pharmacyhub
  mvc:
    throw-exception-if-no-handler-found: true
  web.resources.add-mappings: false

server:
  port: 8080
  servlet:
    context-path: /
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain
  error:
    include-stacktrace: never
    include-message: always
    include-binding-errors: always
    whitelabel.enabled: false

# Logging configuration
logging:
  file:
    name: logs/pharmacyhub.log
    max-size: 10MB
    max-history: 30
  level:
    root: INFO
    com.pharmacyhub: INFO
    org.springframework.web: INFO
    org.springframework.security: INFO
    org.hibernate: INFO
    # Enable Spring Security debug logging temporarily for troubleshooting
    org.springframework.security.access: DEBUG
    org.springframework.security.authentication: DEBUG
    org.springframework.security.authorization: DEBUG

clientApp:
  name: PharmacyHub

pharmacyhub:
  seeder:
    engine: true
  test:
    data:
      pharmacist: 1-10
      pharmacy-manager: 11-20
      proprietor: 21-30
      salesman: 31-40
  security:
    jwt:
      secret: pharmacyhub_jwt_secret_key_for_token_generation_and_validation_2025
      token-validity-in-seconds: 18000  # 5 hours
  error-handling:
    include-debug-info: false  # Set to true in development environment
    log-request-details: true
    generic-error-message: "An unexpected error occurred. Please try again later or contact support."
</file>

<file path="src/main/resources/credentials.json">
{
  "web": {
    "client_id": "919555990168-5ncdcjifms0qoepfs0pnuo66d3d0ad1u.apps.googleusercontent.com",
    "project_id": "pharmacy-hub-402517",
    "auth_uri": "https://accounts.google.com/o/oauth2/auth",
    "token_uri": "https://oauth2.googleapis.com/token",
    "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
    "client_secret": "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",
    "redirect_uris": [
      "http://localhost:8080/login/oauth2/code/google"
    ],
    "javascript_origins": [
      "http://localhost:8080"
    ]
  }
}
</file>

<file path="src/main/resources/db/migration/V3__add_feature_operations.sql">
-- Add feature_operations table to support operation-level permissions
CREATE TABLE IF NOT EXISTS feature_operations (
    feature_id BIGINT NOT NULL,
    operation VARCHAR(255) NOT NULL,
    PRIMARY KEY (feature_id, operation),
    CONSTRAINT fk_feature_operations_feature FOREIGN KEY (feature_id) REFERENCES features (id)
);

-- Add common operations to existing features
-- For exam feature
INSERT INTO feature_operations (feature_id, operation)
SELECT id, 'READ' FROM features WHERE code = 'exams';

INSERT INTO feature_operations (feature_id, operation)
SELECT id, 'WRITE' FROM features WHERE code = 'exams';

INSERT INTO feature_operations (feature_id, operation)
SELECT id, 'DELETE' FROM features WHERE code = 'exams';

INSERT INTO feature_operations (feature_id, operation)
SELECT id, 'PUBLISH' FROM features WHERE code = 'exams';

INSERT INTO feature_operations (feature_id, operation)
SELECT id, 'TAKE' FROM features WHERE code = 'exams';

-- Create standard operation-specific permissions
INSERT INTO permissions (name, description, resource_type, operation_type)
VALUES 
('exams:READ', 'Permission to view exams', 'FEATURE', 'READ'),
('exams:WRITE', 'Permission to create and edit exams', 'FEATURE', 'WRITE'),
('exams:DELETE', 'Permission to delete exams', 'FEATURE', 'DELETE'),
('exams:PUBLISH', 'Permission to publish exams', 'FEATURE', 'MANAGE'),
('exams:TAKE', 'Permission to take exams', 'FEATURE', 'EXECUTE');

-- Assign these permissions to existing roles
-- For admin role
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id 
FROM roles r, permissions p 
WHERE r.name = 'ADMIN' AND p.name IN ('exams:READ', 'exams:WRITE', 'exams:DELETE', 'exams:PUBLISH');

-- For student role
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id 
FROM roles r, permissions p 
WHERE r.name = 'STUDENT' AND p.name IN ('exams:READ', 'exams:TAKE');

-- For instructor role
INSERT INTO role_permissions (role_id, permission_id)
SELECT r.id, p.id 
FROM roles r, permissions p 
WHERE r.name = 'INSTRUCTOR' AND p.name IN ('exams:READ', 'exams:WRITE', 'exams:PUBLISH');
</file>

<file path="src/main/resources/db/migration/V3__add_features_tables.sql">
-- Create features table
CREATE TABLE features (
    id BIGSERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    code VARCHAR(50) NOT NULL UNIQUE,
    active BOOLEAN NOT NULL DEFAULT TRUE,
    parent_feature_id BIGINT,
    CONSTRAINT fk_parent_feature FOREIGN KEY (parent_feature_id) REFERENCES features (id) ON DELETE SET NULL
);

-- Create feature_permissions junction table
CREATE TABLE feature_permissions (
    feature_id BIGINT NOT NULL,
    permission_id BIGINT NOT NULL,
    PRIMARY KEY (feature_id, permission_id),
    CONSTRAINT fk_feature_permission_feature FOREIGN KEY (feature_id) REFERENCES features (id) ON DELETE CASCADE,
    CONSTRAINT fk_feature_permission_permission FOREIGN KEY (permission_id) REFERENCES permissions (id) ON DELETE CASCADE
);

-- Create index for faster lookups
CREATE INDEX idx_feature_code ON features (code);
CREATE INDEX idx_feature_permission_feature_id ON feature_permissions (feature_id);
CREATE INDEX idx_feature_permission_permission_id ON feature_permissions (permission_id);

-- Insert basic features
INSERT INTO features (name, description, code, active) VALUES
('Dashboard', 'Main dashboard access', 'dashboard', true),
('User Management', 'User management features', 'user_management', true),
('Exam Management', 'Exam management features', 'exam_management', true),
('Paper Management', 'Paper management features', 'paper_management', true);

-- Insert child features
INSERT INTO features (name, description, code, active, parent_feature_id) VALUES
('User View', 'View user details', 'user_view', true, (SELECT id FROM features WHERE code = 'user_management')),
('User Create', 'Create new users', 'user_create', true, (SELECT id FROM features WHERE code = 'user_management')),
('User Edit', 'Edit existing users', 'user_edit', true, (SELECT id FROM features WHERE code = 'user_management')),
('User Delete', 'Delete users', 'user_delete', true, (SELECT id FROM features WHERE code = 'user_management')),

('Exam View', 'View exams', 'exam_view', true, (SELECT id FROM features WHERE code = 'exam_management')),
('Exam Create', 'Create new exams', 'exam_create', true, (SELECT id FROM features WHERE code = 'exam_management')),
('Exam Edit', 'Edit existing exams', 'exam_edit', true, (SELECT id FROM features WHERE code = 'exam_management')),
('Exam Delete', 'Delete exams', 'exam_delete', true, (SELECT id FROM features WHERE code = 'exam_management')),
('Exam Take', 'Take exams', 'exam_take', true, (SELECT id FROM features WHERE code = 'exam_management')),
('Exam Grade', 'Grade exams', 'exam_grade', true, (SELECT id FROM features WHERE code = 'exam_management')),

('Practice Papers', 'Manage practice papers', 'practice_papers', true, (SELECT id FROM features WHERE code = 'paper_management')),
('Model Papers', 'Manage model papers', 'model_papers', true, (SELECT id FROM features WHERE code = 'paper_management')),
('Past Papers', 'Manage past papers', 'past_papers', true, (SELECT id FROM features WHERE code = 'paper_management')),
('Subject Papers', 'Manage subject papers', 'subject_papers', true, (SELECT id FROM features WHERE code = 'paper_management'));
</file>

<file path="src/main/resources/db/migration/V4__add_exam_feature_operations.sql">
-- Insert exam feature
INSERT INTO features (name, description, code, active)
VALUES ('Exam Management', 'Features related to exam creation, management, and taking exams', 'exams', true);

-- Get the feature ID
SET @examFeatureId = LAST_INSERT_ID();

-- Add operations to the feature
INSERT INTO feature_operations (feature_id, operation) VALUES
(@examFeatureId, 'VIEW'),
(@examFeatureId, 'TAKE'),
(@examFeatureId, 'CREATE'),
(@examFeatureId, 'EDIT'),
(@examFeatureId, 'DELETE'),
(@examFeatureId, 'DUPLICATE'),
(@examFeatureId, 'MANAGE_QUESTIONS'),
(@examFeatureId, 'PUBLISH'),
(@examFeatureId, 'UNPUBLISH'),
(@examFeatureId, 'ASSIGN'),
(@examFeatureId, 'GRADE'),
(@examFeatureId, 'VIEW_RESULTS'),
(@examFeatureId, 'EXPORT_RESULTS'),
(@examFeatureId, 'VIEW_ANALYTICS');

-- Map existing permissions to feature operations
-- Get existing permission IDs
SET @viewPermissionId = (SELECT id FROM permissions WHERE name = 'exams:view');
SET @takePermissionId = (SELECT id FROM permissions WHERE name = 'exams:take');
SET @createPermissionId = (SELECT id FROM permissions WHERE name = 'exams:create');
SET @editPermissionId = (SELECT id FROM permissions WHERE name = 'exams:edit');
SET @deletePermissionId = (SELECT id FROM permissions WHERE name = 'exams:delete');
SET @duplicatePermissionId = (SELECT id FROM permissions WHERE name = 'exams:duplicate');
SET @manageQuestionsPermissionId = (SELECT id FROM permissions WHERE name = 'exams:manage-questions');
SET @publishPermissionId = (SELECT id FROM permissions WHERE name = 'exams:publish');
SET @unpublishPermissionId = (SELECT id FROM permissions WHERE name = 'exams:unpublish');
SET @assignPermissionId = (SELECT id FROM permissions WHERE name = 'exams:assign');
SET @gradePermissionId = (SELECT id FROM permissions WHERE name = 'exams:grade');
SET @viewResultsPermissionId = (SELECT id FROM permissions WHERE name = 'exams:view-results');
SET @exportResultsPermissionId = (SELECT id FROM permissions WHERE name = 'exams:export-results');
SET @viewAnalyticsPermissionId = (SELECT id FROM permissions WHERE name = 'exams:view-analytics');

-- Add permissions to feature
INSERT INTO feature_permissions (feature_id, permission_id)
SELECT @examFeatureId, id FROM permissions 
WHERE name IN (
    'exams:view', 'exams:take', 'exams:create', 'exams:edit', 'exams:delete',
    'exams:duplicate', 'exams:manage-questions', 'exams:publish', 'exams:unpublish',
    'exams:assign', 'exams:grade', 'exams:view-results', 'exams:export-results',
    'exams:view-analytics'
);
</file>

<file path="src/main/resources/logback-spring.xml">
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <!-- Console appender configuration -->
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %highlight(%-5level) %cyan(%logger{36}) - %msg%n</pattern>
        </encoder>
    </appender>
    
    <!-- File appender configuration for all logs -->
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/pharmacyhub.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/archived/pharmacyhub.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
            <totalSizeCap>3GB</totalSizeCap>
        </rollingPolicy>
    </appender>
    
    <!-- File appender configuration for error logs only -->
    <appender name="ERROR_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/error.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <filter class="ch.qos.logback.classic.filter.ThresholdFilter">
            <level>ERROR</level>
        </filter>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/archived/error.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
    </appender>
    
    <!-- Security logging configuration -->
    <appender name="SECURITY_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/security.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/archived/security.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
    </appender>
    
    <!-- HTTP request logging configuration -->
    <appender name="REQUEST_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/request.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%X{requestId}] %X{method} %X{path} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/archived/request.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
            <totalSizeCap>1GB</totalSizeCap>
        </rollingPolicy>
    </appender>
    
    <!-- Specific loggers configuration -->
    <logger name="com.pharmacyhub.config.RequestLoggingFilter" level="INFO" additivity="false">
        <appender-ref ref="REQUEST_FILE" />
        <appender-ref ref="CONSOLE" />
    </logger>
    
    <logger name="com.pharmacyhub.config.GlobalExceptionHandler" level="DEBUG" additivity="false">
        <appender-ref ref="ERROR_FILE" />
        <appender-ref ref="CONSOLE" />
    </logger>
    
    <logger name="com.pharmacyhub.security" level="DEBUG" additivity="false">
        <appender-ref ref="SECURITY_FILE" />
        <appender-ref ref="CONSOLE" />
    </logger>
    
    <!-- Spring security verbose logging for debugging -->
    <logger name="org.springframework.security" level="INFO" additivity="false">
        <appender-ref ref="SECURITY_FILE" />
        <appender-ref ref="CONSOLE" />
    </logger>
    
    <!-- Root logger configuration -->
    <root level="INFO">
        <appender-ref ref="CONSOLE" />
        <appender-ref ref="FILE" />
        <appender-ref ref="ERROR_FILE" />
    </root>
</configuration>
</file>

<file path="src/main/resources/sql/flagged_questions.sql">
-- Create flagged_questions table
CREATE TABLE IF NOT EXISTS flagged_questions (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    attempt_id BIGINT NOT NULL,
    question_id BIGINT NOT NULL,
    deleted BOOLEAN DEFAULT FALSE,
    FOREIGN KEY (attempt_id) REFERENCES exam_attempts(id),
    FOREIGN KEY (question_id) REFERENCES questions(id),
    UNIQUE (attempt_id, question_id)
);

-- Create index for faster lookup
CREATE INDEX IF NOT EXISTS idx_flagged_questions_attempt ON flagged_questions(attempt_id);
CREATE INDEX IF NOT EXISTS idx_flagged_questions_question ON flagged_questions(question_id);
</file>

<file path="src/main/resources/templates/EmailVerification.html">
<!DOCTYPE html>
<html>
<head>
    <style>
      body {
        font-family: 'Arial', sans-serif;
        background-color: #f4f4f4;
        margin: 0;
        padding: 0;
        color: #333333;
      }

      .container {
        max-width: 600px;
        background-color: #ffffff;
        margin: 20px auto;
        padding: 20px;
        border: 1px solid #dddddd;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .header {
        text-align: center;
        margin-bottom: 20px;
      }

      .header img {
        max-width: 100px;
      }

      .content {
        font-size: 16px;
        line-height: 1.6;
      }

      .verify-button {
        display: block;
        width: fit-content;
        margin: 20px auto;
        padding: 10px 20px;
        font-size: 16px;
        text-decoration: none;
        color: white;
        background-color: #007bff; /* Blue color for emphasis */
        border-radius: 5px;
        text-align: center;
      }

      .footer {
        text-align: center;
        font-size: 14px;
        color: #aaaaaa;
        margin-top: 20px;
      }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <img src="https://i.ibb.co/bH98XjQ/logo.png" alt="Pharmacy Hub Logo" />
    </div>
    <div class="content">
        <p>Hello,</p>
        <p>Thank you for registering at Pharmacy Hub. Please click the button below to verify your email address and complete your registration:</p>
        <a href="${verificationUrl}" class="verify-button">Verify Email</a>
        <p>This link is valid for <strong>30 minutes</strong>. Please do not share this link with anyone.</p>
        <p>If you did not request this, please ignore this email or contact our support team if you believe this to be an error.</p>
    </div>
    <div class="footer">
        <p>Thank you for choosing Pharmacy Hub.<br>Pharmacy Hub Team</p>
    </div>
</div>
</body>
</html>
</file>

<file path="src/main/resources/templates/OtpEmail.html">
<!DOCTYPE html>
<html>
<head>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
      }

      .container {
        max-width: 600px;
        margin: 20px auto;
        padding: 20px;
        background-color: #ffffff;
        border: 1px solid #dddddd;
        border-radius: 5px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .header {
        margin-bottom: 20px;
        text-align: center;
      }

      .header img {
        max-width: 100px;
      }

      .content {
        font-size: 16px;
        color: #333333;
        line-height: 1.6;
      }

      .footer {
        margin-top: 20px;
        text-align: center;
        font-size: 14px;
        color: #aaaaaa;
      }

      .otp-code {
        font-size: 24px;
        font-weight: bold;
        color: #007bff; /* Adjust the color to match your brand */
        margin: 20px 0;
        text-align: center;
      }
    </style>
</head>
<body>
<div class="container">
    <div class="header">
        <!-- Optionally include your logo here -->
<!--        <img src="data:image/png;base64,${encodedLogo}" alt="Logo">-->

        <img src="https://i.ibb.co/bH98XjQ/logo.png" alt="logo" border="0" />
    </div>
    <div class="content">
        <p>Hello,</p>
        <p>You requested a one-time password (OTP) for accessing your account. Please use the following code to
            proceed:</p>
        <div class="otp-code">${otp}</div>
        <p>This code is valid for <strong>10 minutes</strong> and can only be used once.</p>
        <p>If you did not request this code, please ignore this email or contact support if you have concerns about
            unauthorized activity on your account.</p>
    </div>
    <div class="footer">
        <p>Thank you,<br>Pharmacy Hub</p>
    </div>
</div>
</body>
</html>
</file>

<file path="TEST-GUIDE.md">
# PharmacyHub Backend Integration Test Guide

This document provides an overview of the integration tests for the PharmacyHub backend application.

## Test Structure

The integration tests are organized according to the following structure:

```
src/test/java/com/pharmacyhub/
├── config/                  # Test configuration classes
│   ├── BaseIntegrationTest.java
│   └── TestConfig.java
├── controller/              # Controller tests
│   ├── AuthControllerIntegrationTest.java
│   ├── EntryControllerIntegrationTest.java
│   ├── PharmacistControllerIntegrationTest.java
│   └── UserControllerIntegrationTest.java
├── security/                # Security-related tests
│   ├── JwtHelperTest.java
│   ├── RBACPermissionEvaluatorTest.java
│   └── service/
│       ├── RBACServiceIntegrationTest.java
│       └── RoleHierarchyServiceIntegrationTest.java
├── service/                 # Service tests
│   ├── EmailServiceTest.java
│   ├── EntryServiceIntegrationTest.java
│   ├── PharmacistServiceIntegrationTest.java
│   └── UserServiceIntegrationTest.java
└── util/                    # Test utilities
    ├── TestDataBuilder.java
    ├── TestSecurityUtils.java
    └── WithMockUserPrincipal.java
```

## Test Configuration

All tests use the following configuration:

1. H2 in-memory database for testing
2. Mockito for mocking dependencies
3. Spring Security Test for authentication and authorization testing
4. JUnit 5 as the testing framework

The test configuration is controlled by:

- `src/test/resources/application-test.yml`: Sets up the test database and other test-specific settings
- `src/test/resources/logback-test.xml`: Configures logging for tests

## Core Test Classes

### BaseIntegrationTest

All integration tests extend the `BaseIntegrationTest` class, which provides common configuration and utilities:

```java
@ExtendWith(SpringExtension.class)
@SpringBootTest
@ActiveProfiles("test")
@Transactional
public abstract class BaseIntegrationTest {
    // Common test utilities and setup
}
```

### TestDataBuilder

The `TestDataBuilder` class creates test data for various entities in the system:

```java
public class TestDataBuilder {
    public static User createUser(String email, String password, UserType userType) {
        // Create and return user
    }
    
    public static Pharmacist createPharmacist(User user) {
        // Create and return pharmacist
    }
    
    // Other data creation methods
}
```

### TestSecurityUtils

This utility class helps set up security contexts for tests:

```java
public class TestSecurityUtils {
    public static void setSecurityContext(User user) {
        // Set up security context with the provided user
    }
    
    public static void clearSecurityContext() {
        // Clear security context
    }
}
```

## Running Tests

### Using Maven

To run all tests:

```bash
mvn test
```

To run a specific test class:

```bash
mvn test -Dtest=PharmacistServiceIntegrationTest
```

To run a specific test method:

```bash
mvn test -Dtest=PharmacistServiceIntegrationTest#testSaveUser
```

### Using IDE

Tests can also be run directly from your IDE (IntelliJ IDEA, Eclipse, etc.) by right-clicking on the test class or method and selecting "Run Test."

## Test Coverage

The tests cover the following key areas of the application:

### Authentication and Authorization

- User registration and verification
- Login and JWT token generation
- Role-based access control (RBAC)
- Permission evaluation

### User Management

- User creation and updates
- Password management
- User profile management

### Pharmacist, Proprietor, and Other User Types

- User type-specific functionality
- Connection management between different user types

### Entry Management

- Creation and management of entries
- Search and filtering of entries

## Mocking External Services

External services are mocked to ensure tests run without external dependencies:

- Email Service: Mocked to avoid sending actual emails
- Google Contacts Service: Mocked to avoid actual API calls

## Test Reports

After running tests, you can find the test reports in:

- JUnit reports: `target/surefire-reports/`
- JaCoCo code coverage: `target/site/jacoco/`

To generate a coverage report:

```bash
mvn verify
```

Then open `target/site/jacoco/index.html` in a browser to view the code coverage report.

## Troubleshooting Common Test Issues

### Database Issues

If you encounter database-related errors:
- Ensure H2 dependency is properly included in pom.xml
- Check the application-test.yml configuration
- Verify that database migration scripts are compatible with H2

### Authentication Issues

For authentication-related test failures:
- Verify that the mocked authentication is set up correctly
- Check that the required roles and permissions are defined

### Spring Context Issues

If the Spring context fails to load:
- Check for conflicting bean definitions
- Ensure that all required beans are defined for the test context
- Use @MockBean for external dependencies

## Guidelines for Adding New Tests

When adding new functionality, follow these testing guidelines:

1. Create integration tests for all new controllers and services
2. Test both positive paths (successful operations) and negative paths (error handling)
3. Mock external dependencies to keep tests fast and reliable
4. Use the provided utility classes to create test data and security contexts
5. Keep tests focused on business functionality, not implementation details

## Security Testing Guidelines

When testing security features:

1. Test with different user roles to ensure proper authorization
2. Verify that endpoints enforce proper authentication
3. Test permission inheritance through the role hierarchy
4. Check that sensitive operations require appropriate permissions
</file>

</files>
